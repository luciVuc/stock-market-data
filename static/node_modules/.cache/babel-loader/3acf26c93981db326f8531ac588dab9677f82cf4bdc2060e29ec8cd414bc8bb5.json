{"ast":null,"code":"/**\r\n * Radar series module.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\nimport { LineSeries, LineSeriesDataItem } from \"./LineSeries\";\nimport { registry } from \"../../core/Registry\";\nimport * as $math from \"../../core/utils/Math\";\nimport * as $path from \"../../core/rendering/Path\";\n//import { AxisRendererCircular } from \"../axes/AxisRendererCircular\";\n//import { Sprite } from \"../../core/Sprite\";\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * Defines a [[DataItem]] for [[RadarSeries]].\r\n *\r\n * @see {@link DataItem}\r\n */\nvar RadarSeriesDataItem = /** @class */function (_super) {\n  __extends(RadarSeriesDataItem, _super);\n  /**\r\n   * Constructor\r\n   */\n  function RadarSeriesDataItem() {\n    var _this = _super.call(this) || this;\n    _this.className = \"RadarSeriesDataItem\";\n    _this.setLocation(\"dateX\", 0, 0);\n    _this.setLocation(\"dateY\", 0, 0);\n    _this.setLocation(\"categoryX\", 0, 0);\n    _this.setLocation(\"categoryY\", 0, 0);\n    _this.applyTheme();\n    return _this;\n  }\n  return RadarSeriesDataItem;\n}(LineSeriesDataItem);\nexport { RadarSeriesDataItem };\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * Defines [[Series]] for a radar graph.\r\n *\r\n * @see {@link IRadarSeriesEvents} for a list of available Events\r\n * @see {@link IRadarSeriesAdapters} for a list of available Adapters\r\n * @todo Example\r\n * @important\r\n */\nvar RadarSeries = /** @class */function (_super) {\n  __extends(RadarSeries, _super);\n  /**\r\n   * Constructor\r\n   */\n  function RadarSeries() {\n    var _this = _super.call(this) || this;\n    _this.className = \"RadarSeries\";\n    _this.connectEnds = true;\n    _this.applyTheme();\n    return _this;\n  }\n  /**\r\n   * (Re)validates the whole series, effectively causing it to redraw.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  RadarSeries.prototype.validate = function () {\n    // so that radius would be updated\n    if (this.chart.invalid) {\n      this.chart.validate();\n    }\n    _super.prototype.validate.call(this);\n  };\n  /**\r\n   * Returns a new/empty DataItem of the type appropriate for this object.\r\n   *\r\n   * @see {@link DataItem}\r\n   * @return Data Item\r\n   */\n  RadarSeries.prototype.createDataItem = function () {\n    return new RadarSeriesDataItem();\n  };\n  /**\r\n   * Returns an [[IPoint]] coordinates of the specific Serie's data point.\r\n   *\r\n   * @param    dataItem   Data item\r\n   * @param    xKey       Name of X data field\r\n   * @param    yKey       Name of Y data field\r\n   * @param    locationX  X location\r\n   * @param    locationY  Y location\r\n   * @param    stackKeyX  ?\r\n   * @param    stackKeyY  ?\r\n   * @returns             Coordinates\r\n   */\n  RadarSeries.prototype.getPoint = function (dataItem, xKey, yKey, locationX, locationY, stackKeyX, stackKeyY) {\n    if (!stackKeyX) {\n      stackKeyX = \"valueX\";\n    }\n    if (!stackKeyY) {\n      stackKeyY = \"valueY\";\n    }\n    var x = this.yAxis.getX(dataItem, yKey, locationY, stackKeyY);\n    var y = this.yAxis.getY(dataItem, yKey, locationY, stackKeyY);\n    var radius = $math.getDistance({\n      x: x,\n      y: y\n    });\n    // hack to be able to determine angle later\n    if (radius == 0) {\n      radius = 0.00001;\n    }\n    var angle = this.xAxis.getAngle(dataItem, xKey, locationX, stackKeyX);\n    var startAngle = this.chart.startAngle;\n    var endAngle = this.chart.endAngle;\n    //\t\tangle = $math.fitToRange(angle, startAngle, endAngle);\n    if (angle < startAngle || angle > endAngle) {\n      return undefined;\n    } else {\n      return {\n        x: radius * $math.cos(angle),\n        y: radius * $math.sin(angle)\n      };\n    }\n  };\n  /**\r\n   * [addPoints description]\r\n   *\r\n   * @todo Description\r\n   * @param points    [description]\r\n   * @param dataItem  [description]\r\n   * @param xField    [description]\r\n   * @param yField    [description]\r\n   * @param backwards [description]\r\n   */\n  RadarSeries.prototype.addPoints = function (points, dataItem, xField, yField, backwards) {\n    var point = this.getPoint(dataItem, xField, yField, dataItem.locations[xField], dataItem.locations[yField]);\n    if (point) {\n      points.push(point);\n    }\n  };\n  /**\r\n   * Returns an SVG path to be used as a mask for the series.\r\n   *\r\n   * @return SVG path\r\n   */\n  RadarSeries.prototype.getMaskPath = function () {\n    var renderer = this.yAxis.renderer;\n    return $path.arc(renderer.startAngle, renderer.endAngle - renderer.startAngle, renderer.pixelRadius, renderer.pixelInnerRadius);\n  };\n  /**\r\n   * [drawSegment description]\r\n   *\r\n   * @todo Description\r\n   * @param segment      [description]\r\n   * @param points       [description]\r\n   * @param closePoints  [description]\r\n   */\n  RadarSeries.prototype.drawSegment = function (segment, points, closePoints) {\n    var axis = this.yAxis;\n    var renderer = axis.renderer;\n    if (this.connectEnds && Math.abs(renderer.endAngle - renderer.startAngle) == 360) {\n      // adds one point to the beginning of closePoints array, if needed\n      if (this.dataFields[this._xOpenField] || this.dataFields[this._yOpenField] || this.stacked) {\n        points.push(points[0]);\n        if (closePoints.length > 0) {\n          closePoints.unshift(closePoints[closePoints.length - 1]);\n        }\n      }\n    }\n    _super.prototype.drawSegment.call(this, segment, points, closePoints);\n  };\n  Object.defineProperty(RadarSeries.prototype, \"connectEnds\", {\n    /**\r\n     * @return Connect?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"connectEnds\");\n    },\n    /**\r\n     * Should the last and and first data points be connected, forming a complete\r\n     * closed circle?\r\n     *\r\n     * @default true\r\n     * @param value  Connect?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"connectEnds\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  RadarSeries.prototype.positionBulletReal = function (bullet, positionX, positionY) {\n    var xAxis = this.xAxis;\n    var yAxis = this.yAxis;\n    if (positionX < xAxis.start || positionX > xAxis.end || positionY < yAxis.start || positionY > yAxis.end) {\n      bullet.visible = false;\n    }\n    bullet.moveTo(this.xAxis.renderer.positionToPoint(positionX, positionY));\n  };\n  RadarSeries.prototype.setXAxis = function (axis) {\n    _super.prototype.setXAxis.call(this, axis);\n    this.updateRendererRefs();\n  };\n  RadarSeries.prototype.setYAxis = function (axis) {\n    _super.prototype.setYAxis.call(this, axis);\n    this.updateRendererRefs();\n  };\n  RadarSeries.prototype.updateRendererRefs = function () {\n    var rendererX = this.xAxis.renderer;\n    var rendererY = this.yAxis.renderer;\n    rendererX.axisRendererY = rendererY;\n  };\n  return RadarSeries;\n}(LineSeries);\nexport { RadarSeries };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\nregistry.registeredClasses[\"RadarSeries\"] = RadarSeries;\nregistry.registeredClasses[\"RadarSeriesDataItem\"] = RadarSeriesDataItem;","map":{"version":3,"mappings":"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","names":["LineSeries","LineSeriesDataItem","registry","$math","$path","__extends","_super","_this","className","setLocation","applyTheme","connectEnds","RadarSeries","chart","invalid","validate","RadarSeriesDataItem","dataItem","xKey","yKey","locationX","locationY","stackKeyX","stackKeyY","x","yAxis","getX","y","getY","radius","getDistance","angle","xAxis","getAngle","startAngle","endAngle","undefined","cos","sin","points","xField","yField","backwards","point","getPoint","locations","push","renderer","arc","pixelRadius","pixelInnerRadius","segment","closePoints","axis","Math","abs","dataFields","_xOpenField","_yOpenField","stacked","length","unshift","drawSegment","Object","getPropertyValue","value","setPropertyValue","bullet","positionX","positionY","start","end","visible","moveTo","positionToPoint","setXAxis","updateRendererRefs","setYAxis","rendererX","rendererY","axisRendererY","registeredClasses"],"sources":["C:\\Users\\Lucian\\Documents\\DEV\\nodejs\\stock-market-api\\dev\\static\\node_modules\\src\\.internal\\charts\\series\\RadarSeries.ts"],"sourcesContent":["/**\r\n * Radar series module.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { LineSeries, LineSeriesDataItem, ILineSeriesDataFields, ILineSeriesProperties, ILineSeriesAdapters, ILineSeriesEvents } from \"./LineSeries\";\r\nimport { LineSeriesSegment } from \"./LineSeriesSegment\";\r\nimport { IPoint } from \"../../core/defs/IPoint\";\r\nimport { AxisRendererRadial } from \"../axes/AxisRendererRadial\";\r\nimport { AxisRendererCircular } from \"../axes/AxisRendererCircular\";\r\nimport { Axis } from \"../axes/Axis\";\r\nimport { RadarChart } from \"../types/RadarChart\";\r\nimport { registry } from \"../../core/Registry\";\r\nimport { Sprite } from \"../../core/Sprite\";\r\nimport * as $math from \"../../core/utils/Math\";\r\nimport * as $path from \"../../core/rendering/Path\";\r\n//import { AxisRendererCircular } from \"../axes/AxisRendererCircular\";\r\n//import { Sprite } from \"../../core/Sprite\";\r\n\r\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines a [[DataItem]] for [[RadarSeries]].\r\n *\r\n * @see {@link DataItem}\r\n */\r\nexport class RadarSeriesDataItem extends LineSeriesDataItem {\r\n\r\n\t/**\r\n\t * Defines a type of [[Component]] this data item is used for.\r\n\t */\r\n\tpublic _component!: RadarSeries;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"RadarSeriesDataItem\";\r\n\r\n\t\tthis.setLocation(\"dateX\", 0, 0);\r\n\t\tthis.setLocation(\"dateY\", 0, 0);\r\n\r\n\t\tthis.setLocation(\"categoryX\", 0, 0);\r\n\t\tthis.setLocation(\"categoryY\", 0, 0);\r\n\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines data fields for [[RadarSeries]].\r\n */\r\nexport interface IRadarSeriesDataFields extends ILineSeriesDataFields { }\r\n\r\n/**\r\n * Defines properties for [[RadarSeries]].\r\n */\r\nexport interface IRadarSeriesProperties extends ILineSeriesProperties {\r\n\r\n\t/**\r\n\t * Should the last and and first data points be connected, forming a complete\r\n\t * closed circle?\r\n\t *\r\n\t * @default true\r\n\t */\r\n\tconnectEnds?: boolean;\r\n\r\n}\r\n\r\n/**\r\n * Defines events for [[RadarSeries]].\r\n */\r\nexport interface IRadarSeriesEvents extends ILineSeriesEvents { }\r\n\r\n/**\r\n * Defines adapters for [[RadarSeries]].\r\n *\r\n * @see {@link Adapter}\r\n */\r\nexport interface IRadarSeriesAdapters extends ILineSeriesAdapters, IRadarSeriesProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines [[Series]] for a radar graph.\r\n *\r\n * @see {@link IRadarSeriesEvents} for a list of available Events\r\n * @see {@link IRadarSeriesAdapters} for a list of available Adapters\r\n * @todo Example\r\n * @important\r\n */\r\nexport class RadarSeries extends LineSeries {\r\n\r\n\t/**\r\n\t * Defines the type of data fields used for the series.\r\n\t */\r\n\tpublic _dataFields: IRadarSeriesDataFields;\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t */\r\n\tpublic _properties!: IRadarSeriesProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t */\r\n\tpublic _adapter!: IRadarSeriesAdapters;\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: IRadarSeriesEvents;\r\n\r\n\t/**\r\n\t * Defines the type of data item.\r\n\t */\r\n\tpublic _dataItem: RadarSeriesDataItem;\r\n\r\n\t/**\r\n\t * A chart series belongs to.\r\n\t */\r\n\tpublic _chart: RadarChart;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"RadarSeries\";\r\n\t\tthis.connectEnds = true;\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * (Re)validates the whole series, effectively causing it to redraw.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic validate(): void {\r\n\r\n\t\t// so that radius would be updated\r\n\t\tif (this.chart.invalid) {\r\n\t\t\tthis.chart.validate();\r\n\t\t}\r\n\r\n\t\tsuper.validate();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new/empty DataItem of the type appropriate for this object.\r\n\t *\r\n\t * @see {@link DataItem}\r\n\t * @return Data Item\r\n\t */\r\n\tprotected createDataItem(): this[\"_dataItem\"] {\r\n\t\treturn new RadarSeriesDataItem();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an [[IPoint]] coordinates of the specific Serie's data point.\r\n\t *\r\n\t * @param    dataItem   Data item\r\n\t * @param    xKey       Name of X data field\r\n\t * @param    yKey       Name of Y data field\r\n\t * @param    locationX  X location\r\n\t * @param    locationY  Y location\r\n\t * @param    stackKeyX  ?\r\n\t * @param    stackKeyY  ?\r\n\t * @returns             Coordinates\r\n\t */\r\n\tpublic getPoint(dataItem: RadarSeriesDataItem, xKey: string, yKey: string, locationX?: number, locationY?: number, stackKeyX?: string, stackKeyY?: string) {\r\n\t\tif (!stackKeyX) {\r\n\t\t\tstackKeyX = \"valueX\";\r\n\t\t}\r\n\t\tif (!stackKeyY) {\r\n\t\t\tstackKeyY = \"valueY\";\r\n\t\t}\r\n\r\n\t\tlet x: number = this.yAxis.getX(dataItem, yKey, locationY, stackKeyY);\r\n\t\tlet y: number = this.yAxis.getY(dataItem, yKey, locationY, stackKeyY);\r\n\r\n\t\tlet radius: number = $math.getDistance({ x: x, y: y });\r\n\r\n\t\t// hack to be able to determine angle later\r\n\t\tif (radius == 0) {\r\n\t\t\tradius = 0.00001;\r\n\t\t}\r\n\r\n\t\tlet angle: number = this.xAxis.getAngle(dataItem, xKey, locationX, stackKeyX);\r\n\r\n\t\tlet startAngle = this.chart.startAngle;\r\n\t\tlet endAngle = this.chart.endAngle;\r\n\r\n\t\t//\t\tangle = $math.fitToRange(angle, startAngle, endAngle);\r\n\t\tif (angle < startAngle || angle > endAngle) {\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn { x: radius * $math.cos(angle), y: radius * $math.sin(angle) };\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * [addPoints description]\r\n\t *\r\n\t * @todo Description\r\n\t * @param points    [description]\r\n\t * @param dataItem  [description]\r\n\t * @param xField    [description]\r\n\t * @param yField    [description]\r\n\t * @param backwards [description]\r\n\t */\r\n\tprotected addPoints(points: IPoint[], dataItem: this[\"_dataItem\"], xField: string, yField: string, backwards?: boolean): void {\r\n\t\tlet point = this.getPoint(dataItem, xField, yField, dataItem.locations[xField], dataItem.locations[yField]);\r\n\t\tif (point) {\r\n\t\t\tpoints.push(point);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an SVG path to be used as a mask for the series.\r\n\t *\r\n\t * @return SVG path\r\n\t */\r\n\tprotected getMaskPath(): string {\r\n\t\tlet renderer: AxisRendererRadial = <AxisRendererRadial>this.yAxis.renderer;\r\n\t\treturn $path.arc(renderer.startAngle, renderer.endAngle - renderer.startAngle, renderer.pixelRadius, renderer.pixelInnerRadius);\r\n\t}\r\n\r\n\t/**\r\n\t * [drawSegment description]\r\n\t *\r\n\t * @todo Description\r\n\t * @param segment      [description]\r\n\t * @param points       [description]\r\n\t * @param closePoints  [description]\r\n\t */\r\n\tprotected drawSegment(segment: LineSeriesSegment, points: IPoint[], closePoints: IPoint[]): void {\r\n\t\tlet axis: Axis = this.yAxis;\r\n\t\tlet renderer: AxisRendererRadial = <AxisRendererRadial>axis.renderer;\r\n\r\n\t\tif (this.connectEnds && Math.abs(renderer.endAngle - renderer.startAngle) == 360) {\r\n\t\t\t// adds one point to the beginning of closePoints array, if needed\r\n\t\t\tif (this.dataFields[<keyof this[\"_dataFields\"]>this._xOpenField] ||\r\n\t\t\t\tthis.dataFields[<keyof this[\"_dataFields\"]>this._yOpenField] ||\r\n\t\t\t\tthis.stacked) {\r\n\t\t\t\tpoints.push(points[0]);\r\n\t\t\t\tif (closePoints.length > 0) {\r\n\t\t\t\t\tclosePoints.unshift(closePoints[closePoints.length - 1]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tsuper.drawSegment(segment, points, closePoints);\r\n\t}\r\n\r\n\t/**\r\n\t * Should the last and and first data points be connected, forming a complete\r\n\t * closed circle?\r\n\t *\r\n\t * @default true\r\n\t * @param value  Connect?\r\n\t */\r\n\tpublic set connectEnds(value: boolean) {\r\n\t\tthis.setPropertyValue(\"connectEnds\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Connect?\r\n\t */\r\n\tpublic get connectEnds(): boolean {\r\n\t\treturn this.getPropertyValue(\"connectEnds\");\r\n\t}\r\n\r\n\tprotected positionBulletReal(bullet:Sprite, positionX:number, positionY:number){\r\n\t\tlet xAxis = this.xAxis;\r\n\t\tlet yAxis = this.yAxis;\r\n\r\n\t\tif(positionX < xAxis.start || positionX > xAxis.end || positionY < yAxis.start || positionY > yAxis.end){\r\n\t\t\tbullet.visible = false;\r\n\t\t}\r\n\t\t\r\n\t\tbullet.moveTo(this.xAxis.renderer.positionToPoint(positionX, positionY));\t\t\r\n\t}\r\n\r\n\r\n\tprotected setXAxis(axis: Axis) {\r\n\t\tsuper.setXAxis(axis);\r\n\t\tthis.updateRendererRefs();\r\n\t}\r\n\r\n\tprotected setYAxis(axis: Axis) {\r\n\t\tsuper.setYAxis(axis);\r\n\t\tthis.updateRendererRefs();\r\n\t}\r\n\r\n\tprotected updateRendererRefs() {\r\n\t\tlet rendererX = <AxisRendererCircular>this.xAxis.renderer;\r\n\t\tlet rendererY = <AxisRendererRadial>this.yAxis.renderer;\r\n\r\n\t\trendererX.axisRendererY = rendererY;\r\n\t}\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"RadarSeries\"] = RadarSeries;\r\nregistry.registeredClasses[\"RadarSeriesDataItem\"] = RadarSeriesDataItem;\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}