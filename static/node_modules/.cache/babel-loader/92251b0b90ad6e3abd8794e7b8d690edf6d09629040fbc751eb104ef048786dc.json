{"ast":null,"code":"/**\r\n * Data parser module.\r\n */\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\nimport { DateFormatter } from \"../formatters/DateFormatter\";\nimport * as $utils from \"../utils/Utils\";\nimport * as $type from \"../utils/Type\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * Base class for the data parsers.\r\n */\nvar DataParser = /** @class */function () {\n  function DataParser() {}\n  /**\r\n   * A \"placeholder\" function for real parsers to override.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param data  Source data\r\n   * @return Parsed data (empty)\r\n   */\n  DataParser.prototype.parse = function (data) {\n    return [];\n  };\n  ;\n  Object.defineProperty(DataParser.prototype, \"parsableNumbers\", {\n    /**\r\n     * Checks if there are any numeric fields that need to be converted to\r\n     * numbers.\r\n     *\r\n     * @return Numeric fields?\r\n     */\n    get: function () {\n      return this.options.numberFields && this.options.numberFields.length > 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Converts a value to 'number' if it is in `numberFields`.\r\n   *\r\n   * @param field  Field name\r\n   * @param value  Value\r\n   * @return Parsed or original value\r\n   */\n  DataParser.prototype.maybeToNumber = function (field, value) {\n    if (this.options.numberFields.indexOf(field) !== -1) {\n      return $utils.anyToNumber(value);\n    }\n    return value;\n  };\n  Object.defineProperty(DataParser.prototype, \"parsableDates\", {\n    /**\r\n     * Checks if there are any date fields that need to be converted to `Date`\r\n     * objects.\r\n     *\r\n     * @return Date fields?\r\n     */\n    get: function () {\n      return this.options.dateFields && this.options.dateFields.length > 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Converts a value to `Date` if it is in `dateFields`.\r\n   *\r\n   * @param field  Field name\r\n   * @param value  Value\r\n   * @return Parsed or original value\r\n   */\n  DataParser.prototype.maybeToDate = function (field, value) {\n    if (this.options.dateFields.indexOf(field) !== -1) {\n      return this.options.dateFormatter.parse(value, this.dateFormat);\n    }\n    return value;\n  };\n  /**\r\n   * Replaces empty value with something else.\r\n   *\r\n   * @param value  Source value\r\n   * @return Source value or replacement\r\n   */\n  DataParser.prototype.maybeToEmpty = function (value) {\n    if ((!$type.hasValue(value) || value == \"\") && $type.hasValue(this.options.emptyAs)) {\n      return this.options.emptyAs;\n    }\n    return value;\n  };\n  Object.defineProperty(DataParser.prototype, \"dateFormatter\", {\n    /**\r\n     * [[DateFormatter]] object for date parsing.\r\n     *\r\n     * If there was not [[DateFormatter]] supplied in parser options, a new one\r\n     * is created.\r\n     *\r\n     * @return Date formatter\r\n     * @see {@link DateFormatter}\r\n     */\n    get: function () {\n      if (!this.options.dateFormatter) {\n        this.options.dateFormatter = new DateFormatter();\n        if (this.options.dateFormat) {\n          this.options.dateFormat = this.options.dateFormat;\n        }\n      }\n      return this.options.dateFormatter;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DataParser.prototype, \"dateFormat\", {\n    /**\r\n     * A date format to use when parsing dates.\r\n     *\r\n     * @return Date format\r\n     * @see {@link DateFormatter}\r\n     */\n    get: function () {\n      return this.options.dateFormat || this.dateFormatter.inputDateFormat;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return DataParser;\n}();\nexport { DataParser };","map":{"version":3,"mappings":"AAAA;;;AAKA;;;;;;AAMA,SAASA,aAAa,QAAQ,6BAA6B;AAC3D,OAAO,KAAKC,MAAM,MAAM,gBAAgB;AACxC,OAAO,KAAKC,KAAK,MAAM,eAAe;AAuDtC;;;;;;AAOA;;;AAGA;EAAA,uBAmHA;EArGC;;;;;;;EAOOC,0BAAK,GAAZ,UAAaC,IAAY;IACxB,OAAO,EAAE;EACV,CAAC;EAAA;EAQDC,sBAAcF,uCAAe;IAN7B;;;;;;SAMA;MACC,OAAO,IAAI,CAACG,OAAO,CAACC,YAAY,IAAK,IAAI,CAACD,OAAO,CAACC,YAAY,CAACC,MAAM,GAAG,CAAE;IAC3E,CAAC;;;;EAED;;;;;;;EAOUL,kCAAa,GAAvB,UAAwBM,KAAa,EAAEC,KAAU;IAChD,IAAI,IAAI,CAACJ,OAAO,CAACC,YAAY,CAACI,OAAO,CAACF,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE;MACpD,OAAOR,MAAM,CAACW,WAAW,CAACF,KAAK,CAAC;;IAEjC,OAAOA,KAAK;EACb,CAAC;EAQDL,sBAAcF,qCAAa;IAN3B;;;;;;SAMA;MACC,OAAO,IAAI,CAACG,OAAO,CAACO,UAAU,IAAK,IAAI,CAACP,OAAO,CAACO,UAAU,CAACL,MAAM,GAAG,CAAE;IACvE,CAAC;;;;EAED;;;;;;;EAOUL,gCAAW,GAArB,UAAsBM,KAAa,EAAEC,KAAU;IAC9C,IAAI,IAAI,CAACJ,OAAO,CAACO,UAAU,CAACF,OAAO,CAACF,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE;MAClD,OAAO,IAAI,CAACH,OAAO,CAACQ,aAAa,CAACC,KAAK,CAACL,KAAK,EAAE,IAAI,CAACM,UAAU,CAAC;;IAEhE,OAAON,KAAK;EACb,CAAC;EAED;;;;;;EAMUP,iCAAY,GAAtB,UAAuBO,KAAU;IAChC,IAAI,CAAC,CAACR,KAAK,CAACe,QAAQ,CAACP,KAAK,CAAC,IAAIA,KAAK,IAAI,EAAE,KAAKR,KAAK,CAACe,QAAQ,CAAC,IAAI,CAACX,OAAO,CAACY,OAAO,CAAC,EAAE;MACpF,OAAO,IAAI,CAACZ,OAAO,CAACY,OAAO;;IAE5B,OAAOR,KAAK;EACb,CAAC;EAWDL,sBAAcF,qCAAa;IAT3B;;;;;;;;;SASA;MACC,IAAI,CAAC,IAAI,CAACG,OAAO,CAACQ,aAAa,EAAE;QAChC,IAAI,CAACR,OAAO,CAACQ,aAAa,GAAG,IAAId,aAAa;QAC9C,IAAI,IAAI,CAACM,OAAO,CAACU,UAAU,EAAE;UAC5B,IAAI,CAACV,OAAO,CAACU,UAAU,GAAG,IAAI,CAACV,OAAO,CAACU,UAAU;;;MAGnD,OAAO,IAAI,CAACV,OAAO,CAACQ,aAAa;IAClC,CAAC;;;;EAQDT,sBAAcF,kCAAU;IANxB;;;;;;SAMA;MACC,OAAO,IAAI,CAACG,OAAO,CAACU,UAAU,IAAI,IAAI,CAACF,aAAa,CAACK,eAAe;IACrE,CAAC;;;;EAEF,iBAAC;AAAD,CAAC,EAnHD","names":["DateFormatter","$utils","$type","DataParser","data","Object","options","numberFields","length","field","value","indexOf","anyToNumber","dateFields","dateFormatter","parse","dateFormat","hasValue","emptyAs","inputDateFormat"],"sources":["C:\\Users\\Lucian\\Documents\\DEV\\nodejs\\stock-market-api\\dev\\static\\node_modules\\src\\.internal\\core\\data\\DataParser.ts"],"sourcesContent":["/**\r\n * Data parser module.\r\n */\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { DateFormatter } from \"../formatters/DateFormatter\";\r\nimport * as $utils from \"../utils/Utils\";\r\nimport * as $type from \"../utils/Type\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines common options for all data parsers.\r\n */\r\nexport interface IDataParserOptions {\r\n\r\n\t/**\r\n\t * Empty values (e.g. empty strings, `null`, etc.) will be replaced with\r\n\t * this.\r\n\t */\r\n\temptyAs?: any;\r\n\r\n\t/**\r\n\t * List of fields in data that hold numeric values. Parser will try to\r\n\t * convert the value in those fields to a `number`.\r\n\t */\r\n\tnumberFields?: string[];\r\n\r\n\t/**\r\n\t * List of fields in data that need to be treated as Dates, i.e. converted\r\n\t * to `Date` objects from whatever source format they are currently in.\r\n\t */\r\n\tdateFields?: string[];\r\n\r\n\t/**\r\n\t * An instance of [[DateFormatter]] to use when parsing string-based dates.\r\n\t * If it's not set, the parser will create it's own instance of\r\n\t * [[DateFormatter]], should any date parsing required. (`dateFields` is set)\r\n\t *\r\n\t * Unless `dateFormat` is set in parser options, the parser will try to look\r\n\t * for `dateFormat` in `dateFormatter`.\r\n\t *\r\n\t * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-date-time/#Parsing_Dates} Tutorial on date parsing\r\n\t */\r\n\tdateFormatter?: DateFormatter;\r\n\r\n\t/**\r\n\t * Override date format set in `dateFormatter`.\r\n\t *\r\n\t * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-date-time/#Parsing_Dates} Tutorial on date parsing\r\n\t */\r\n\tdateFormat?: string;\r\n\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Base class for the data parsers.\r\n */\r\nexport class DataParser {\r\n\r\n\t/**\r\n\t * Content type, relevant to the specific format.\r\n\t */\r\n\tpublic contentType: string;\r\n\r\n\t/**\r\n\t * Parser options.\r\n\t *\r\n\t * @see {@link IDataParserOptions} for description of each option\r\n\t */\r\n\tpublic options: IDataParserOptions;\r\n\r\n\t/**\r\n\t * A \"placeholder\" function for real parsers to override.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param data  Source data\r\n\t * @return Parsed data (empty)\r\n\t */\r\n\tpublic parse(data: string): any {\r\n\t\treturn [];\r\n\t};\r\n\r\n\t/**\r\n\t * Checks if there are any numeric fields that need to be converted to\r\n\t * numbers.\r\n\t *\r\n\t * @return Numeric fields?\r\n\t */\r\n\tprotected get parsableNumbers(): boolean {\r\n\t\treturn this.options.numberFields && (this.options.numberFields.length > 0);\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a value to 'number' if it is in `numberFields`.\r\n\t *\r\n\t * @param field  Field name\r\n\t * @param value  Value\r\n\t * @return Parsed or original value\r\n\t */\r\n\tprotected maybeToNumber(field: string, value: any): any {\r\n\t\tif (this.options.numberFields.indexOf(field) !== -1) {\r\n\t\t\treturn $utils.anyToNumber(value);\r\n\t\t}\r\n\t\treturn value;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if there are any date fields that need to be converted to `Date`\r\n\t * objects.\r\n\t *\r\n\t * @return Date fields?\r\n\t */\r\n\tprotected get parsableDates(): boolean {\r\n\t\treturn this.options.dateFields && (this.options.dateFields.length > 0);\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a value to `Date` if it is in `dateFields`.\r\n\t *\r\n\t * @param field  Field name\r\n\t * @param value  Value\r\n\t * @return Parsed or original value\r\n\t */\r\n\tprotected maybeToDate(field: string, value: any): any {\r\n\t\tif (this.options.dateFields.indexOf(field) !== -1) {\r\n\t\t\treturn this.options.dateFormatter.parse(value, this.dateFormat);\r\n\t\t}\r\n\t\treturn value;\r\n\t}\r\n\r\n\t/**\r\n\t * Replaces empty value with something else.\r\n\t *\r\n\t * @param value  Source value\r\n\t * @return Source value or replacement\r\n\t */\r\n\tprotected maybeToEmpty(value: any): any {\r\n\t\tif ((!$type.hasValue(value) || value == \"\") && $type.hasValue(this.options.emptyAs)) {\r\n\t\t\treturn this.options.emptyAs;\r\n\t\t}\r\n\t\treturn value;\r\n\t}\r\n\r\n\t/**\r\n\t * [[DateFormatter]] object for date parsing.\r\n\t *\r\n\t * If there was not [[DateFormatter]] supplied in parser options, a new one\r\n\t * is created.\r\n\t *\r\n\t * @return Date formatter\r\n\t * @see {@link DateFormatter}\r\n\t */\r\n\tprotected get dateFormatter(): DateFormatter {\r\n\t\tif (!this.options.dateFormatter) {\r\n\t\t\tthis.options.dateFormatter = new DateFormatter;\r\n\t\t\tif (this.options.dateFormat) {\r\n\t\t\t\tthis.options.dateFormat = this.options.dateFormat;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this.options.dateFormatter;\r\n\t}\r\n\r\n\t/**\r\n\t * A date format to use when parsing dates.\r\n\t *\r\n\t * @return Date format\r\n\t * @see {@link DateFormatter}\r\n\t */\r\n\tprotected get dateFormat(): string {\r\n\t\treturn this.options.dateFormat || this.dateFormatter.inputDateFormat;\r\n\t}\r\n\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}