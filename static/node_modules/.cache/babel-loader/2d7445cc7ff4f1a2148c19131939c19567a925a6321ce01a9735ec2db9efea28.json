{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { MultiDisposer } from \"../util/Disposer\";\nimport { Label } from \"../render/Label\";\nimport { PointedRectangle } from \"../render/PointedRectangle\";\nimport { Container } from \"./Container\";\nimport { Percent } from \"../util/Percent\";\nimport { Color } from \"../util/Color\";\nimport * as $math from \"../util/Math\";\nimport * as $array from \"../util/Array\";\nimport * as $utils from \"../util/Utils\";\n/**\r\n * Creates a tooltip.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/tooltips/} for more info\r\n * @important\r\n */\nvar Tooltip = /** @class */function (_super) {\n  __extends(Tooltip, _super);\n  function Tooltip(root, settings, isReal, templates) {\n    if (templates === void 0) {\n      templates = [];\n    }\n    var _this = _super.call(this, root, settings, isReal, templates) || this;\n    Object.defineProperty(_this, \"_arrangeDisposer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_fx\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(_this, \"_fy\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(_this, \"_label\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_fillDp\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_strokeDp\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_labelDp\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_w\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(_this, \"_h\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(_this, \"_keepHoverDp\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    return _this;\n  }\n  Object.defineProperty(Tooltip.prototype, \"_afterNew\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n      this._settings.themeTags = $utils.mergeTags(this._settings.themeTags, [\"tooltip\"]);\n      _super.prototype._afterNew.call(this);\n      this.set(\"background\", PointedRectangle.new(this._root, {\n        themeTags: [\"tooltip\", \"background\"]\n      }));\n      this._label = this.children.push(Label.new(this._root, {}));\n      this._disposers.push(this._label.events.on(\"boundschanged\", function () {\n        _this._updateBackground();\n      }));\n      this.on(\"bounds\", function () {\n        _this._updateBackground();\n      });\n      this._updateTextColor();\n      this._root.tooltipContainer.children.push(this);\n      this.hide(0);\n      this._root._tooltips.push(this);\n    }\n  });\n  Object.defineProperty(Tooltip.prototype, \"label\", {\n    /**\r\n     * A [[Label]] element for the tooltip.\r\n     *\r\n     * @readonly\r\n     * @return Label\r\n     */\n    get: function () {\n      return this._label;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Permanently disposes the tooltip.\r\n   */\n  Object.defineProperty(Tooltip.prototype, \"dispose\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype.dispose.call(this);\n      $array.remove(this._root._tooltips, this);\n    }\n  });\n  Object.defineProperty(Tooltip.prototype, \"_updateChildren\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype._updateChildren.call(this);\n      var labelText = this.get(\"labelText\");\n      if (labelText != null) {\n        this.label.set(\"text\", this.get(\"labelText\"));\n      }\n      var labelHTML = this.get(\"labelHTML\");\n      if (labelHTML != null) {\n        this.label.set(\"html\", this.get(\"labelHTML\"));\n      }\n    }\n  });\n  Object.defineProperty(Tooltip.prototype, \"_changed\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n      _super.prototype._changed.call(this);\n      if (this.isDirty(\"pointTo\")) {\n        // can't compare to previous, as sometimes pointTo is set twice (when pointer moves, so the position won't be udpated)\n        this._updateBackground();\n      }\n      if (this.isDirty(\"tooltipTarget\")) {\n        this.updateBackgroundColor();\n      }\n      if (this.isDirty(\"keepTargetHover\")) {\n        var keephover = this.get(\"keepTargetHover\");\n        if (keephover) {\n          var bg = this.get(\"background\");\n          this._keepHoverDp = new MultiDisposer([bg.events.on(\"pointerover\", function (_ev) {\n            var target = _this.get(\"tooltipTarget\");\n            if (target) {\n              if (target.parent && target.parent.getPrivate(\"tooltipTarget\") == target) {\n                target = target.parent;\n              }\n              target.hover();\n            }\n          }), bg.events.on(\"pointerout\", function (_ev) {\n            var target = _this.get(\"tooltipTarget\");\n            if (target) {\n              if (target.parent && target.parent.getPrivate(\"tooltipTarget\") == target) {\n                target = target.parent;\n              }\n              target.unhover();\n            }\n          })]);\n        } else {\n          if (this._keepHoverDp) {\n            this._keepHoverDp.dispose();\n            this._keepHoverDp = undefined;\n          }\n        }\n      }\n    }\n  });\n  Object.defineProperty(Tooltip.prototype, \"_onShow\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype._onShow.call(this);\n      this.updateBackgroundColor();\n    }\n  });\n  Object.defineProperty(Tooltip.prototype, \"updateBackgroundColor\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n      var tooltipTarget = this.get(\"tooltipTarget\");\n      var background = this.get(\"background\");\n      var fill;\n      var stroke;\n      if (tooltipTarget && background) {\n        fill = tooltipTarget.get(\"fill\");\n        stroke = tooltipTarget.get(\"stroke\");\n        if (fill == null) {\n          fill = stroke;\n        }\n        if (this.get(\"getFillFromSprite\")) {\n          if (this._fillDp) {\n            this._fillDp.dispose();\n          }\n          if (fill != null) {\n            background.set(\"fill\", fill);\n          }\n          this._fillDp = tooltipTarget.on(\"fill\", function (fill) {\n            if (fill != null) {\n              background.set(\"fill\", fill);\n              _this._updateTextColor(fill);\n            }\n          });\n        }\n        if (this.get(\"getStrokeFromSprite\")) {\n          if (this._strokeDp) {\n            this._strokeDp.dispose();\n          }\n          if (fill != null) {\n            background.set(\"stroke\", fill);\n          }\n          this._strokeDp = tooltipTarget.on(\"fill\", function (fill) {\n            if (fill != null) {\n              background.set(\"stroke\", fill);\n            }\n          });\n        }\n        if (this.get(\"getLabelFillFromSprite\")) {\n          if (this._labelDp) {\n            this._labelDp.dispose();\n          }\n          if (fill != null) {\n            this.label.set(\"fill\", fill);\n          }\n          this._labelDp = tooltipTarget.on(\"fill\", function (fill) {\n            if (fill != null) {\n              _this.label.set(\"fill\", fill);\n            }\n          });\n        }\n      }\n      this._updateTextColor(fill);\n    }\n  });\n  Object.defineProperty(Tooltip.prototype, \"_updateTextColor\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (fill) {\n      if (this.get(\"autoTextColor\")) {\n        if (fill == null) {\n          fill = this.get(\"background\").get(\"fill\");\n        }\n        if (fill == null) {\n          fill = this._root.interfaceColors.get(\"background\");\n        }\n        if (fill instanceof Color) {\n          this.label.set(\"fill\", Color.alternative(fill, this._root.interfaceColors.get(\"alternativeText\"), this._root.interfaceColors.get(\"text\")));\n        }\n      }\n    }\n  });\n  Object.defineProperty(Tooltip.prototype, \"_setDataItem\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItem) {\n      _super.prototype._setDataItem.call(this, dataItem);\n      this.label._setDataItem(dataItem);\n    }\n  });\n  Object.defineProperty(Tooltip.prototype, \"_updateBackground\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype.updateBackground.call(this);\n      var parent = this._root.container;\n      if (parent) {\n        var cw = 0.5;\n        var ch = 0.5;\n        var centerX = this.get(\"centerX\");\n        if (centerX instanceof Percent) {\n          cw = centerX.value;\n        }\n        var centerY = this.get(\"centerY\");\n        if (centerY instanceof Percent) {\n          ch = centerY.value;\n        }\n        var parentW = parent.width();\n        var parentH = parent.height();\n        var tooltipContainer = this.parent;\n        var xx = 0;\n        var yy = 0;\n        if (tooltipContainer) {\n          xx = tooltipContainer.x();\n          yy = tooltipContainer.y();\n          var layerMargin = tooltipContainer.get(\"layerMargin\");\n          if (layerMargin) {\n            xx += layerMargin.left || 0;\n            yy += layerMargin.top || 0;\n            parentW += (layerMargin.left || 0) + (layerMargin.right || 0);\n            parentH += (layerMargin.top || 0) + (layerMargin.bottom || 0);\n          }\n        }\n        var bounds = this.get(\"bounds\", {\n          left: -xx,\n          top: -yy,\n          right: parentW - xx,\n          bottom: parentH - yy\n        });\n        this._updateBounds();\n        var w = this.width();\n        var h = this.height();\n        // use old w and h,as when tooltip is hidden, these are 0 and unneeded animation happens\n        if (w === 0) {\n          w = this._w;\n        }\n        if (h === 0) {\n          h = this._h;\n        }\n        var pointTo = this.get(\"pointTo\", {\n          x: parentW / 2,\n          y: parentH / 2\n        });\n        var x = pointTo.x;\n        var y = pointTo.y;\n        var pointerOrientation = this.get(\"pointerOrientation\");\n        var background = this.get(\"background\");\n        var pointerLength = 0;\n        var bgStrokeSizeY = 0;\n        var bgStrokeSizeX = 0;\n        if (background instanceof PointedRectangle) {\n          pointerLength = background.get(\"pointerLength\", 0);\n          bgStrokeSizeY = background.get(\"strokeWidth\", 0) / 2;\n          bgStrokeSizeX = bgStrokeSizeY;\n        }\n        var pointerX = 0;\n        var pointerY = 0;\n        var boundsW = bounds.right - bounds.left;\n        var boundsH = bounds.bottom - bounds.top;\n        // horizontal\n        if (pointerOrientation == \"horizontal\" || pointerOrientation == \"left\" || pointerOrientation == \"right\") {\n          bgStrokeSizeY = 0;\n          if (pointerOrientation == \"horizontal\") {\n            if (x > bounds.left + boundsW / 2) {\n              x -= w * (1 - cw) + pointerLength;\n              bgStrokeSizeX *= -1;\n            } else {\n              x += w * cw + pointerLength;\n            }\n          } else if (pointerOrientation == \"left\") {\n            x += w * (1 - cw) + pointerLength;\n          } else {\n            x -= w * cw + pointerLength;\n            bgStrokeSizeX *= -1;\n          }\n        }\n        // vertical pointer\n        else {\n          bgStrokeSizeX = 0;\n          if (pointerOrientation == \"vertical\") {\n            if (y > bounds.top + h / 2 + pointerLength) {\n              y -= h * (1 - ch) + pointerLength;\n            } else {\n              y += h * ch + pointerLength;\n              bgStrokeSizeY *= -1;\n            }\n          } else if (pointerOrientation == \"down\") {\n            y -= h * (1 - ch) + pointerLength;\n          } else {\n            y += h * ch + pointerLength;\n            bgStrokeSizeY *= -1;\n          }\n        }\n        x = $math.fitToRange(x, bounds.left + w * cw, bounds.left + boundsW - w * (1 - cw)) + bgStrokeSizeX;\n        y = $math.fitToRange(y, bounds.top + h * ch, bounds.top + boundsH - h * (1 - ch)) - bgStrokeSizeY;\n        pointerX = pointTo.x - x + w * cw + bgStrokeSizeX;\n        pointerY = pointTo.y - y + h * ch - bgStrokeSizeY;\n        this._fx = x;\n        this._fy = y;\n        var animationDuration = this.get(\"animationDuration\", 0);\n        if (animationDuration > 0 && this.get(\"visible\") && this.get(\"opacity\") > 0.1) {\n          var animationEasing = this.get(\"animationEasing\");\n          this.animate({\n            key: \"x\",\n            to: x,\n            duration: animationDuration,\n            easing: animationEasing\n          });\n          this.animate({\n            key: \"y\",\n            to: y,\n            duration: animationDuration,\n            easing: animationEasing\n          });\n        } else {\n          this.set(\"x\", x);\n          this.set(\"y\", y);\n        }\n        if (background instanceof PointedRectangle) {\n          background.set(\"pointerX\", pointerX);\n          background.set(\"pointerY\", pointerY);\n        }\n        if (w > 0) {\n          this._w = w;\n        }\n        if (h > 0) {\n          this._h = h;\n        }\n      }\n    }\n  });\n  Object.defineProperty(Tooltip, \"className\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: \"Tooltip\"\n  });\n  Object.defineProperty(Tooltip, \"classNames\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: Container.classNames.concat([Tooltip.className])\n  });\n  return Tooltip;\n}(Container);\nexport { Tooltip };","map":{"version":3,"mappings":"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","names":["MultiDisposer","Label","PointedRectangle","Container","Percent","Color","$math","$array","$utils","__extends","root","settings","isReal","templates","_super","Object","_settings","themeTags","mergeTags","_afterNew","set","new","_root","_label","children","push","_disposers","events","on","_this","_updateBackground","_updateTextColor","tooltipContainer","hide","_tooltips","Tooltip","dispose","remove","_updateChildren","labelText","get","label","labelHTML","_changed","isDirty","updateBackgroundColor","keephover","bg","_keepHoverDp","_ev","target","parent","getPrivate","hover","unhover","undefined","_onShow","tooltipTarget","background","fill","stroke","_fillDp","_strokeDp","_labelDp","interfaceColors","alternative","dataItem","_setDataItem","updateBackground","container","cw","ch","centerX","value","centerY","parentW","width","parentH","height","xx","yy","x","y","layerMargin","left","top","right","bottom","bounds","_updateBounds","w","h","_w","_h","pointTo","pointerOrientation","pointerLength","bgStrokeSizeY","bgStrokeSizeX","pointerX","pointerY","boundsW","boundsH","fitToRange","_fx","_fy","animationDuration","animationEasing","animate","key","to","duration","easing","classNames","concat","className"],"sources":["C:\\Users\\Lucian\\Documents\\DEV\\nodejs\\stock-market-api\\dev\\static\\node_modules\\src\\.internal\\core\\render\\Tooltip.ts"],"sourcesContent":["import type { IBounds } from \"../util/IBounds\";\nimport type { IPoint } from \"../util/IPoint\";\nimport type { Pattern } from \"../render/patterns/Pattern\";\nimport type { Time } from \"../util/Animation\";\nimport type { Sprite } from \"../render/Sprite\";\n\nimport { MultiDisposer, IDisposer } from \"../util/Disposer\";\nimport { Label } from \"../render/Label\";\nimport { PointedRectangle } from \"../render/PointedRectangle\";\nimport { Container, IContainerPrivate, IContainerSettings } from \"./Container\";\nimport { Percent } from \"../util/Percent\";\nimport { Color } from \"../util/Color\";\n\nimport * as $math from \"../util/Math\";\nimport * as $array from \"../util/Array\";\nimport * as $utils from \"../util/Utils\";\n//import * as $utils from \"../util/Utils\";\nimport type { DataItem, IComponentDataItem } from \"./Component\";\n\nimport type { Root } from \"../Root\";\nimport type { Template } from \"../util/Template\";\nimport type { Entity } from \"../util/Entity\";\n\n\nexport interface ITooltipSettings extends IContainerSettings {\n\n\t/**\n\t * Text to use for tooltip's label.\n\t */\n\tlabelText?: string\n\n\t/**\n\t * HTML content to use for tooltip's label.\n\t *\n\t * @since 5.2.11\n\t */\n\tlabelHTML?: string\n\n\t/**\n\t * A direction of the tooltip pointer.\n\t *\n\t * https://www.amcharts.com/docs/v5/concepts/common-elements/tooltips/#Orientation\n\t */\n\tpointerOrientation?: \"left\" | \"right\" | \"up\" | \"down\" | \"vertical\" | \"horizontal\";\n\n\t/**\n\t * If set to `true` will use the same `fill` color for its background as\n\t * its `tooltipTarget`.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/tooltips/#Colors} for more info\n\t * @default false\n\t */\n\tgetFillFromSprite?: boolean;\n\n\t/**\n\t * If set to `true` will use the same `fill` color as its `tooltipTarget`.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/tooltips/#Colors} for more info\n\t * @default false\n\t */\n\tgetLabelFillFromSprite?: boolean;\n\n\t/**\n\t * If set to `true` will use the same `stroke` color as its `tooltipTarget`.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/tooltips/#Colors} for more info\n\t * @default false\n\t */\n\tgetStrokeFromSprite?: boolean;\n\n\t/**\n\t * Scree bounds to constring tooltip within.\n\t */\n\tbounds?: IBounds;\n\n\t/**\n\t * If set to `true` tooltip will adjust its text color for better visibility\n\t * on its background.\n\t *\n\t * @default true\n\t */\n\tautoTextColor?: boolean;\n\n\t/**\n\t * Screen coordinates the tooltip show point to.\n\t */\n\tpointTo?: IPoint;\n\n\t/**\n\t * Duration in milliseconds for tooltip position change, e.g. when tooltip\n\t * is jumping from one target to another.\n\t */\n\tanimationDuration?: number;\n\n\t/**\n\t * Easing function for tooltip animation.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/animations/#Easing_functions} for more info\n\t */\n\tanimationEasing?: (t: Time) => Time;\n\n\t/**\n\t * A target element tooltip is shown fow.\n\t */\n\ttooltipTarget?: Sprite;\n\n\t/**\n\t * If set to `true`, tooltip's target element will considered to be hovered\n\t * when mouse pointer is over tooltip itself.\n\t *\n\t * @since 5.2.14\n\t */\n\tkeepTargetHover?: boolean;\n\n}\n\nexport interface ITooltipPrivate extends IContainerPrivate {\n}\n\n/**\n * Creates a tooltip.\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/tooltips/} for more info\n * @important\n */\nexport class Tooltip extends Container {\n\n\tprotected _arrangeDisposer: MultiDisposer | undefined;\n\n\tpublic _fx: number = 0;\n\tpublic _fy: number = 0;\n\n\tdeclare public _settings: ITooltipSettings;\n\tdeclare public _privateSettings: ITooltipPrivate;\n\n\tprotected _label!: Label;\n\tpublic static className: string = \"Tooltip\";\n\tpublic static classNames: Array<string> = Container.classNames.concat([Tooltip.className]);\n\n\tprotected _fillDp: IDisposer | undefined;\n\tprotected _strokeDp: IDisposer | undefined;\n\tprotected _labelDp: IDisposer | undefined;\n\n\tprotected _w: number = 0;\n\tprotected _h: number = 0;\n\n\tprotected _keepHoverDp: MultiDisposer | undefined;\n\n\tconstructor(root: Root, settings: Entity[\"_settings\"], isReal: boolean, templates: Array<Template<Entity>> = []) {\n\t\tsuper(root, settings, isReal, templates);\n\t}\n\n\tprotected _afterNew() {\n\t\tthis._settings.themeTags = $utils.mergeTags(this._settings.themeTags, [\"tooltip\"]);\n\n\t\tsuper._afterNew();\n\n\t\tthis.set(\"background\", PointedRectangle.new(this._root, {\n\t\t\tthemeTags: [\"tooltip\", \"background\"]\n\t\t}));\n\n\t\tthis._label = this.children.push(Label.new(this._root, {}));\n\n\t\tthis._disposers.push(this._label.events.on(\"boundschanged\", () => {\n\t\t\tthis._updateBackground();\n\t\t}))\n\n\t\tthis.on(\"bounds\", () => {\n\t\t\tthis._updateBackground();\n\t\t})\n\n\t\tthis._updateTextColor();\n\n\t\tthis._root.tooltipContainer.children.push(this);\n\t\tthis.hide(0);\n\n\t\tthis._root._tooltips.push(this);\n\t}\n\n\t/**\n\t * A [[Label]] element for the tooltip.\n\t *\n\t * @readonly\n\t * @return Label\n\t */\n\tpublic get label(): Label {\n\t\treturn this._label;\n\t}\n\n\t/**\n\t * Permanently disposes the tooltip.\n\t */\n\tpublic dispose() {\n\t\tsuper.dispose();\n\t\t$array.remove(this._root._tooltips, this);\n\t}\n\n\tpublic _updateChildren() {\n\t\tsuper._updateChildren();\n\t\tconst labelText = this.get(\"labelText\");\n\t\tif (labelText != null) {\n\t\t\tthis.label.set(\"text\", this.get(\"labelText\"));\n\t\t}\n\t\tconst labelHTML = this.get(\"labelHTML\");\n\t\tif (labelHTML != null) {\n\t\t\tthis.label.set(\"html\", this.get(\"labelHTML\"));\n\t\t}\n\t}\n\n\tpublic _changed() {\n\t\tsuper._changed();\n\n\t\tif (this.isDirty(\"pointTo\")) {\n\t\t\t// can't compare to previous, as sometimes pointTo is set twice (when pointer moves, so the position won't be udpated)\n\t\t\tthis._updateBackground();\n\t\t}\n\n\t\tif (this.isDirty(\"tooltipTarget\")) {\n\t\t\tthis.updateBackgroundColor();\n\t\t}\n\n\t\tif (this.isDirty(\"keepTargetHover\")) {\n\t\t\tconst keephover = this.get(\"keepTargetHover\");\n\t\t\tif (keephover) {\n\t\t\t\tconst bg = this.get(\"background\")!;\n\t\t\t\tthis._keepHoverDp = new MultiDisposer([\n\t\t\t\t\tbg.events.on(\"pointerover\", (_ev) => {\n\t\t\t\t\t\tlet target = this.get(\"tooltipTarget\");\n\t\t\t\t\t\tif (target) {\n\t\t\t\t\t\t\tif (target.parent && target.parent.getPrivate(\"tooltipTarget\") == target) {\n\t\t\t\t\t\t\t\ttarget = target.parent;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget.hover();\n\t\t\t\t\t\t}\n\t\t\t\t\t}),\n\t\t\t\t\tbg.events.on(\"pointerout\", (_ev) => {\n\t\t\t\t\t\tlet target = this.get(\"tooltipTarget\");\n\t\t\t\t\t\tif (target) {\n\t\t\t\t\t\t\tif (target.parent && target.parent.getPrivate(\"tooltipTarget\") == target) {\n\t\t\t\t\t\t\t\ttarget = target.parent;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget.unhover();\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (this._keepHoverDp) {\n\t\t\t\t\tthis._keepHoverDp.dispose();\n\t\t\t\t\tthis._keepHoverDp = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected _onShow() {\n\t\tsuper._onShow();\n\t\tthis.updateBackgroundColor();\n\t}\n\n\n\tpublic updateBackgroundColor() {\n\t\tlet tooltipTarget = this.get(\"tooltipTarget\");\n\t\tconst background = this.get(\"background\");\n\t\tlet fill: Color | undefined;\n\t\tlet stroke: Color | undefined;\n\n\n\t\tif (tooltipTarget && background) {\n\n\t\t\tfill = tooltipTarget.get(\"fill\" as any);\n\t\t\tstroke = tooltipTarget.get(\"stroke\" as any);\n\n\t\t\tif (fill == null) {\n\t\t\t\tfill = stroke;\n\t\t\t}\n\n\t\t\tif (this.get(\"getFillFromSprite\")) {\n\n\t\t\t\tif (this._fillDp) {\n\t\t\t\t\tthis._fillDp.dispose();\n\t\t\t\t}\n\n\t\t\t\tif (fill != null) {\n\t\t\t\t\tbackground.set(\"fill\", fill as any);\n\t\t\t\t}\n\n\t\t\t\tthis._fillDp = tooltipTarget.on(\"fill\" as any, (fill) => {\n\t\t\t\t\tif (fill != null) {\n\t\t\t\t\t\tbackground.set(\"fill\", fill as any);\n\t\t\t\t\t\tthis._updateTextColor(fill);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tif (this.get(\"getStrokeFromSprite\")) {\n\n\t\t\t\tif (this._strokeDp) {\n\t\t\t\t\tthis._strokeDp.dispose();\n\t\t\t\t}\n\n\t\t\t\tif (fill != null) {\n\t\t\t\t\tbackground.set(\"stroke\", fill as any);\n\t\t\t\t}\n\n\t\t\t\tthis._strokeDp = tooltipTarget.on(\"fill\" as any, (fill) => {\n\t\t\t\t\tif (fill != null) {\n\t\t\t\t\t\tbackground.set(\"stroke\", fill as any);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tif (this.get(\"getLabelFillFromSprite\")) {\n\n\t\t\t\tif (this._labelDp) {\n\t\t\t\t\tthis._labelDp.dispose();\n\t\t\t\t}\n\n\t\t\t\tif (fill != null) {\n\t\t\t\t\tthis.label.set(\"fill\", fill as any);\n\t\t\t\t}\n\n\t\t\t\tthis._labelDp = tooltipTarget.on(\"fill\" as any, (fill) => {\n\t\t\t\t\tif (fill != null) {\n\t\t\t\t\t\tthis.label.set(\"fill\", fill as any);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\tthis._updateTextColor(fill);\n\t}\n\n\n\tprotected _updateTextColor(fill?: Color | Pattern) {\n\t\tif (this.get(\"autoTextColor\")) {\n\t\t\tif (fill == null) {\n\t\t\t\tfill = this.get(\"background\")!.get(\"fill\") as Color;\n\t\t\t}\n\n\t\t\tif (fill == null) {\n\t\t\t\tfill = this._root.interfaceColors.get(\"background\");\n\t\t\t}\n\n\t\t\tif (fill instanceof Color) {\n\t\t\t\tthis.label.set(\"fill\", Color.alternative(fill, this._root.interfaceColors.get(\"alternativeText\"), this._root.interfaceColors.get(\"text\")));\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic _setDataItem(dataItem?: DataItem<IComponentDataItem>): void {\n\t\tsuper._setDataItem(dataItem);\n\t\tthis.label._setDataItem(dataItem);\n\t}\n\n\n\tprotected _updateBackground() {\n\t\tsuper.updateBackground();\n\t\tconst parent = this._root.container;\n\n\t\tif (parent) {\n\n\t\t\tlet cw = 0.5;\n\t\t\tlet ch = 0.5;\n\n\t\t\tlet centerX = this.get(\"centerX\");\n\t\t\tif (centerX instanceof Percent) {\n\t\t\t\tcw = centerX.value;\n\t\t\t}\n\n\t\t\tlet centerY = this.get(\"centerY\");\n\t\t\tif (centerY instanceof Percent) {\n\t\t\t\tch = centerY.value;\n\t\t\t}\n\n\t\t\tlet parentW = parent.width();\n\t\t\tlet parentH = parent.height();\n\n\t\t\tlet tooltipContainer = this.parent;\n\t\t\tlet xx = 0;\n\t\t\tlet yy = 0;\n\t\t\tif (tooltipContainer) {\n\t\t\t\txx = tooltipContainer.x();\n\t\t\t\tyy = tooltipContainer.y();\n\n\t\t\t\tconst layerMargin = tooltipContainer.get(\"layerMargin\");\n\t\t\t\tif (layerMargin) {\n\t\t\t\t\txx += layerMargin.left || 0;\n\t\t\t\t\tyy += layerMargin.top || 0;\n\t\t\t\t\tparentW += (layerMargin.left || 0) + (layerMargin.right || 0);\n\t\t\t\t\tparentH += (layerMargin.top || 0) + (layerMargin.bottom || 0);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst bounds = this.get(\"bounds\", { left: -xx, top: -yy, right: parentW - xx, bottom: parentH - yy });\n\n\t\t\tthis._updateBounds();\n\n\t\t\tlet w = this.width();\n\t\t\tlet h = this.height();\n\n\t\t\t// use old w and h,as when tooltip is hidden, these are 0 and unneeded animation happens\n\t\t\tif (w === 0) {\n\t\t\t\tw = this._w;\n\t\t\t}\n\n\t\t\tif (h === 0) {\n\t\t\t\th = this._h;\n\t\t\t}\n\n\t\t\tlet pointTo = this.get(\"pointTo\", { x: parentW / 2, y: parentH / 2 });\n\t\t\tlet x = pointTo.x;\n\t\t\tlet y = pointTo.y;\n\n\t\t\tlet pointerOrientation = this.get(\"pointerOrientation\");\n\n\t\t\tlet background = this.get(\"background\");\n\t\t\tlet pointerLength = 0;\n\t\t\tlet bgStrokeSizeY = 0;\n\t\t\tlet bgStrokeSizeX = 0;\n\n\t\t\tif (background instanceof PointedRectangle) {\n\t\t\t\tpointerLength = background.get(\"pointerLength\", 0);\n\t\t\t\tbgStrokeSizeY = background.get(\"strokeWidth\", 0) / 2;\n\t\t\t\tbgStrokeSizeX = bgStrokeSizeY;\n\t\t\t}\n\n\t\t\tlet pointerX = 0;\n\t\t\tlet pointerY = 0;\n\n\t\t\tlet boundsW = bounds.right - bounds.left;\n\t\t\tlet boundsH = bounds.bottom - bounds.top;\n\n\n\n\t\t\t// horizontal\n\t\t\tif (pointerOrientation == \"horizontal\" || pointerOrientation == \"left\" || pointerOrientation == \"right\") {\n\t\t\t\tbgStrokeSizeY = 0;\n\t\t\t\tif (pointerOrientation == \"horizontal\") {\n\t\t\t\t\tif (x > bounds.left + boundsW / 2) {\n\t\t\t\t\t\tx -= (w * (1 - cw) + pointerLength);\n\t\t\t\t\t\tbgStrokeSizeX *= -1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tx += (w * cw + pointerLength);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (pointerOrientation == \"left\") {\n\t\t\t\t\tx += (w * (1 - cw) + pointerLength);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tx -= (w * cw + pointerLength);\n\t\t\t\t\tbgStrokeSizeX *= -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// vertical pointer\n\t\t\telse {\n\t\t\t\tbgStrokeSizeX = 0;\n\t\t\t\tif (pointerOrientation == \"vertical\") {\n\t\t\t\t\tif (y > bounds.top + h / 2 + pointerLength) {\n\t\t\t\t\t\ty -= (h * (1 - ch) + pointerLength);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ty += (h * ch + pointerLength);\n\t\t\t\t\t\tbgStrokeSizeY *= -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (pointerOrientation == \"down\") {\n\t\t\t\t\ty -= (h * (1 - ch) + pointerLength);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ty += (h * ch + pointerLength);\n\t\t\t\t\tbgStrokeSizeY *= -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tx = $math.fitToRange(x, bounds.left + w * cw, bounds.left + boundsW - w * (1 - cw)) + bgStrokeSizeX;\n\t\t\ty = $math.fitToRange(y, bounds.top + h * ch, bounds.top + boundsH - h * (1 - ch)) - bgStrokeSizeY;\n\n\t\t\tpointerX = pointTo.x - x + w * cw + bgStrokeSizeX;\n\t\t\tpointerY = pointTo.y - y + h * ch - bgStrokeSizeY;\n\n\t\t\tthis._fx = x;\n\t\t\tthis._fy = y;\n\n\t\t\tconst animationDuration = this.get(\"animationDuration\", 0);\n\n\t\t\tif (animationDuration > 0 && this.get(\"visible\") && this.get(\"opacity\") > 0.1) {\n\t\t\t\tconst animationEasing = this.get(\"animationEasing\");\n\t\t\t\tthis.animate({ key: \"x\", to: x, duration: animationDuration, easing: animationEasing });\n\t\t\t\tthis.animate({ key: \"y\", to: y, duration: animationDuration, easing: animationEasing });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.set(\"x\", x);\n\t\t\t\tthis.set(\"y\", y);\n\t\t\t}\n\n\t\t\tif (background instanceof PointedRectangle) {\n\t\t\t\tbackground.set(\"pointerX\", pointerX);\n\t\t\t\tbackground.set(\"pointerY\", pointerY);\n\t\t\t}\n\n\t\t\tif (w > 0) {\n\t\t\t\tthis._w = w;\n\t\t\t}\n\t\t\tif (h > 0) {\n\t\t\t\tthis._h = h;\n\t\t\t}\n\t\t}\n\t}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}