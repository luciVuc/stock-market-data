{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Layout, eachChildren } from \"./Layout\";\nimport * as $array from \"../util/Array\";\nimport * as $math from \"../util/Math\";\n/**\r\n * A grid children layout for [[Container]].\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/containers/#Layout} for more info\r\n */\nvar GridLayout = /** @class */function (_super) {\n  __extends(GridLayout, _super);\n  function GridLayout() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  Object.defineProperty(GridLayout.prototype, \"_afterNew\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this._setRawDefault(\"maxColumns\", Number.MAX_VALUE);\n      _super.prototype._afterNew.call(this);\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n  Object.defineProperty(GridLayout.prototype, \"updateContainer\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (container) {\n      var paddingLeft = container.get(\"paddingLeft\", 0);\n      var paddingRight = container.get(\"paddingRight\", 0);\n      var paddingTop = container.get(\"paddingTop\", 0);\n      var availableWidth = container.maxWidth() - paddingLeft - paddingRight;\n      var minCellWidth = availableWidth;\n      var maxCellWidth = 1;\n      eachChildren(container, function (child) {\n        if (child.get(\"visible\") && child.getPrivate(\"visible\") && !child.get(\"forceHidden\")) {\n          if (child.get(\"position\") != \"absolute\") {\n            var childWidth = child.width();\n            if (childWidth < minCellWidth) {\n              minCellWidth = childWidth;\n            }\n            if (childWidth > maxCellWidth) {\n              maxCellWidth = childWidth;\n            }\n          }\n        }\n      });\n      minCellWidth = $math.fitToRange(minCellWidth, 1, availableWidth);\n      maxCellWidth = $math.fitToRange(maxCellWidth, 1, availableWidth);\n      var columnCount = 1;\n      if (this.get(\"fixedWidthGrid\")) {\n        columnCount = availableWidth / maxCellWidth;\n      } else {\n        columnCount = availableWidth / minCellWidth;\n      }\n      columnCount = Math.max(1, Math.floor(columnCount));\n      columnCount = Math.min(this.get(\"maxColumns\", Number.MAX_VALUE), columnCount);\n      var columnWidths = this.getColumnWidths(container, columnCount, maxCellWidth, availableWidth);\n      var prevY = paddingTop;\n      var column = 0;\n      var maxColumnHeight = 0;\n      columnCount = columnWidths.length;\n      var prevX = paddingLeft;\n      eachChildren(container, function (child) {\n        if (child.get(\"position\") == \"relative\" && child.isVisible()) {\n          var marginTop = child.get(\"marginTop\", 0);\n          var marginBottom = child.get(\"marginBottom\", 0);\n          var bounds = child.adjustedLocalBounds();\n          var marginLeft = child.get(\"marginLeft\", 0);\n          var marginRight = child.get(\"marginRight\", 0);\n          var x = prevX + marginLeft - bounds.left;\n          var y = prevY + marginTop - bounds.top;\n          child.setPrivate(\"x\", x);\n          child.setPrivate(\"y\", y);\n          prevX += columnWidths[column] + marginRight;\n          maxColumnHeight = Math.max(maxColumnHeight, child.height() + marginTop + marginBottom);\n          column++;\n          if (column >= columnCount) {\n            column = 0;\n            prevX = paddingLeft;\n            prevY += maxColumnHeight;\n          }\n        }\n      });\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n  Object.defineProperty(GridLayout.prototype, \"getColumnWidths\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (container, columnCount, maxCellWidth, availableWidth) {\n      var _this = this;\n      var totalWidth = 0;\n      var columnWidths = [];\n      var column = 0;\n      eachChildren(container, function (child) {\n        var bounds = child.adjustedLocalBounds();\n        if (child.get(\"position\") != \"absolute\" && child.isVisible()) {\n          if (_this.get(\"fixedWidthGrid\")) {\n            columnWidths[column] = maxCellWidth;\n          } else {\n            columnWidths[column] = Math.max(columnWidths[column] | 0, bounds.right - bounds.left + child.get(\"marginLeft\", 0) + child.get(\"marginRight\", 0));\n          }\n          if (column < container.children.length - 1) {\n            column++;\n            if (column == columnCount) {\n              column = 0;\n            }\n          }\n        }\n      });\n      $array.each(columnWidths, function (w) {\n        totalWidth += w;\n      });\n      if (totalWidth > availableWidth) {\n        if (columnCount > 2) {\n          columnCount -= 1;\n          return this.getColumnWidths(container, columnCount, maxCellWidth, availableWidth);\n        } else {\n          return [availableWidth];\n        }\n      }\n      return columnWidths;\n    }\n  });\n  Object.defineProperty(GridLayout, \"className\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: \"GridLayout\"\n  });\n  Object.defineProperty(GridLayout, \"classNames\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: Layout.classNames.concat([GridLayout.className])\n  });\n  return GridLayout;\n}(Layout);\nexport { GridLayout };","map":{"version":3,"mappings":"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","names":["Layout","eachChildren","$array","$math","__extends","_setRawDefault","Number","MAX_VALUE","_super","_afterNew","container","paddingLeft","get","paddingRight","paddingTop","availableWidth","maxWidth","minCellWidth","maxCellWidth","child","getPrivate","childWidth","width","fitToRange","columnCount","Math","max","floor","min","columnWidths","getColumnWidths","prevY","column","maxColumnHeight","length","prevX","isVisible","marginTop","marginBottom","bounds","adjustedLocalBounds","marginLeft","marginRight","x","left","y","top","setPrivate","height","totalWidth","_this","right","children","each","w","Object","classNames","concat","GridLayout","className"],"sources":["C:\\Users\\Lucian\\Documents\\DEV\\nodejs\\stock-market-api\\dev\\static\\node_modules\\src\\.internal\\core\\render\\GridLayout.ts"],"sourcesContent":["import { Layout, ILayoutSettings, ILayoutPrivate, eachChildren } from \"./Layout\";\nimport * as $array from \"../util/Array\";\nimport * as $math from \"../util/Math\";\nimport type { Container } from \"./Container\";\n\n\nexport interface IGridLayoutSettings extends ILayoutSettings {\n\n\t/**\n\t * If set to `true` all columns in the grid will be equal width.\n\t *\n\t * @default false\n\t */\n\tfixedWidthGrid?: boolean;\n\n\t/**\n\t * Maximum number of columns in the grid.\n\t */\n\tmaxColumns?: number;\n\n}\n\nexport interface IGridLayoutPrivate extends ILayoutPrivate {\n}\n\n/**\n * A grid children layout for [[Container]].\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/containers/#Layout} for more info\n */\nexport class GridLayout extends Layout {\n\n\tpublic static className: string = \"GridLayout\";\n\tpublic static classNames: Array<string> = Layout.classNames.concat([GridLayout.className]);\n\n\tdeclare public _settings: IGridLayoutSettings;\n\tdeclare public _privateSettings: IGridLayoutPrivate;\n\n\n\tprotected _afterNew() {\n\t\tthis._setRawDefault(\"maxColumns\", Number.MAX_VALUE);\n\t\tsuper._afterNew();\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic updateContainer(container: Container): void {\n\t\tlet paddingLeft = container.get(\"paddingLeft\", 0);\n\t\tlet paddingRight = container.get(\"paddingRight\", 0);\n\t\tlet paddingTop = container.get(\"paddingTop\", 0);\n\n\t\tlet availableWidth = container.maxWidth() - paddingLeft - paddingRight;\n\n\t\tlet minCellWidth = availableWidth;\n\t\tlet maxCellWidth = 1;\n\n\t\teachChildren(container, (child) => {\n\t\t\tif(child.get(\"visible\") && child.getPrivate(\"visible\") && !child.get(\"forceHidden\")){\n\t\t\t\tif (child.get(\"position\") != \"absolute\") {\n\t\t\t\t\tlet childWidth = child.width();\n\n\t\t\t\t\tif (childWidth < minCellWidth) {\n\t\t\t\t\t\tminCellWidth = childWidth;\n\t\t\t\t\t}\n\t\t\t\t\tif (childWidth > maxCellWidth) {\n\t\t\t\t\t\tmaxCellWidth = childWidth;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tminCellWidth = $math.fitToRange(minCellWidth, 1, availableWidth);\n\t\tmaxCellWidth = $math.fitToRange(maxCellWidth, 1, availableWidth);\n\n\t\tlet columnCount = 1;\n\t\tif (this.get(\"fixedWidthGrid\")) {\n\t\t\tcolumnCount = availableWidth / maxCellWidth;\n\t\t}\n\t\telse {\n\t\t\tcolumnCount = availableWidth / minCellWidth;\n\t\t}\n\n\t\tcolumnCount = Math.max(1, Math.floor(columnCount));\n\t\tcolumnCount = Math.min(this.get(\"maxColumns\", Number.MAX_VALUE), columnCount);\n\n\t\tlet columnWidths = this.getColumnWidths(container, columnCount, maxCellWidth, availableWidth);\n\n\t\tlet prevY = paddingTop;\n\n\t\tlet column = 0;\n\t\tlet maxColumnHeight = 0;\n\n\t\tcolumnCount = columnWidths.length;\n\n\t\tlet prevX = paddingLeft;\n\n\t\teachChildren(container, (child) => {\n\t\t\tif (child.get(\"position\") == \"relative\" && child.isVisible()) {\n\t\t\t\tconst marginTop = child.get(\"marginTop\", 0);\n\t\t\t\tconst marginBottom = child.get(\"marginBottom\", 0);\n\n\t\t\t\tlet bounds = child.adjustedLocalBounds();\n\n\t\t\t\tlet marginLeft = child.get(\"marginLeft\", 0);\n\t\t\t\tlet marginRight = child.get(\"marginRight\", 0);\n\t\t\t\tlet x = prevX + marginLeft - bounds.left;\n\t\t\t\tlet y = prevY + marginTop - bounds.top;\n\n\t\t\t\tchild.setPrivate(\"x\", x);\n\t\t\t\tchild.setPrivate(\"y\", y);\n\n\t\t\t\tprevX += columnWidths[column] + marginRight;\n\n\t\t\t\tmaxColumnHeight = Math.max(maxColumnHeight, child.height() + marginTop + marginBottom);\n\n\t\t\t\tcolumn++;\n\n\t\t\t\tif (column >= columnCount) {\n\t\t\t\t\tcolumn = 0;\n\t\t\t\t\tprevX = paddingLeft;\n\t\t\t\t\tprevY += maxColumnHeight;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getColumnWidths(container: Container, columnCount: number, maxCellWidth: number, availableWidth: number): number[] {\n\t\tlet totalWidth = 0;\n\t\tlet columnWidths: Array<number> = [];\n\t\tlet column = 0;\n\n\t\teachChildren(container, (child) => {\n\t\t\tlet bounds = child.adjustedLocalBounds();\n\t\t\tif (child.get(\"position\") != \"absolute\" && child.isVisible()) {\n\t\t\t\tif (this.get(\"fixedWidthGrid\")) {\n\t\t\t\t\tcolumnWidths[column] = maxCellWidth;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcolumnWidths[column] = Math.max(columnWidths[column] | 0, bounds.right - bounds.left + child.get(\"marginLeft\", 0) + child.get(\"marginRight\", 0));\n\t\t\t\t}\n\n\t\t\t\tif (column < container.children.length - 1) {\n\t\t\t\t\tcolumn++;\n\t\t\t\t\tif (column == columnCount) {\n\t\t\t\t\t\tcolumn = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t$array.each(columnWidths, (w) => {\n\t\t\ttotalWidth += w;\n\t\t})\n\n\t\tif (totalWidth > availableWidth) {\n\t\t\tif (columnCount > 2) {\n\t\t\t\tcolumnCount -= 1;\n\t\t\t\treturn this.getColumnWidths(container, columnCount, maxCellWidth, availableWidth);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn [availableWidth];\n\t\t\t}\n\t\t}\n\n\t\treturn columnWidths;\n\t}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}