{"ast":null,"code":"export class Candlestick {\n  constructor(_ref) {\n    let {\n      timestamp,\n      open,\n      close,\n      high,\n      low\n    } = _ref;\n    this.timestamp = void 0;\n    this.close = void 0;\n    this.high = void 0;\n    this.low = void 0;\n    this.open = void 0;\n    this.timestamp = parseInt(timestamp.toString());\n    this.open = parseFloat(open.toString());\n    this.close = parseFloat(close.toString());\n    this.high = parseFloat(high.toString());\n    this.low = parseFloat(low.toString());\n  }\n}\nexport class VolumeBar {\n  constructor(_ref2) {\n    let {\n      timestamp,\n      volume\n    } = _ref2;\n    this.timestamp = void 0;\n    this.volume = void 0;\n    this.timestamp = parseInt(timestamp.toString());\n    this.volume = parseFloat(volume.toString());\n  }\n}\nclass CandlestickChart extends HTMLCanvasElement {\n  // Returns an array of attributes that the browser will observe.\n  static observedAttributes() {}\n\n  // It’s called when the component is first initialized.\n  // It must call super() and can set any defaults or perform other pre-rendering processes.\n  constructor() {\n    super();\n    this.candlesticks = void 0;\n    this.gridColor = void 0;\n    this.gridTextColor = void 0;\n    this.mouseHoverBackgroundColor = void 0;\n    this.mouseHoverTextColor = void 0;\n    this.greenColor = void 0;\n    this.redHoverColor = void 0;\n    this.candleWidth = void 0;\n    this.marginLeft = void 0;\n    this.marginRight = void 0;\n    this.marginTop = void 0;\n    this.marginBottom = void 0;\n    this.yStart = void 0;\n    this.yEnd = void 0;\n    this.yRange = void 0;\n    this.yPixelRange = void 0;\n    this.xEnd = void 0;\n    this.xGridCells = void 0;\n    this.drawMouseOverlay = void 0;\n    this.mousePosition = void 0;\n    this.xMouseHover = void 0;\n    this.yMouseHover = void 0;\n    this.hoveredCandlestickID = void 0;\n    this.xPixelRange = void 0;\n    this.xStart = void 0;\n    this.xRange = void 0;\n    this.redColor = void 0;\n    this.greenHoverColor = void 0;\n    this.yGridCells = void 0;\n    const context = this.getContext('2d');\n    context.font = '12px sans-serif';\n    context.lineWidth = 1;\n    this.attachShadow({\n      mode: 'open'\n    });\n    this.addEventListener('mousemove', this.mouseMoveHandler.bind(this));\n    this.addEventListener('mouseout', this.mouseOutHandler.bind(this));\n    this.style.backgroundColor = '#252525';\n    this.gridColor = '#444444';\n    this.gridTextColor = '#aaaaaa';\n    this.mouseHoverBackgroundColor = '#eeeeee';\n    this.mouseHoverTextColor = '#000000';\n    this.greenColor = '#00cc00';\n    this.redColor = '#cc0000';\n    this.greenHoverColor = '#00ff00';\n    this.redHoverColor = '#ff0000';\n    this.candleWidth = 5;\n    this.marginLeft = 10;\n    this.marginRight = 100;\n    this.marginTop = 10;\n    this.marginBottom = 30;\n    this.yStart = 0;\n    this.yEnd = 0;\n    this.yRange = 0;\n    this.yPixelRange = this.height - this.marginTop - this.marginBottom;\n    this.xStart = 0;\n    this.xEnd = 0;\n    this.xRange = 0;\n    this.xPixelRange = this.width - this.marginLeft - this.marginRight;\n\n    // these are only approximations, the grid will be divided in a way so the numbers are nice\n    this.xGridCells = 16;\n    this.yGridCells = 16;\n    this.drawMouseOverlay = false;\n    this.mousePosition = {\n      x: 0,\n      y: 0\n    };\n    this.xMouseHover = 0;\n    this.yMouseHover = 0;\n    this.hoveredCandlestickID = 0;\n    this.candlesticks = [];\n  }\n\n  // Called whenever an observed attribute is changed.\n  // Those defined in HTML are passed immediately, but JavaScript can modify them:\n  attributeChangedCallback(propertyName, oldValue, newValue) {\n    // document.querySelector('hello-world').setAttribute('name', 'Everyone');\n    // The method may need to trigger a re-render when this occurs.\n  }\n\n  // // This function is called when the Web Component is appended to a Document Object Model.\n  // // It should run any required rendering.\n  // connectedCallback() {}\n\n  // // It’s called when the Web Component is removed from a Document Object Model.\n  // // This may be useful if you need to clean up, such as removing stored state or\n  // // aborting Ajax requests.\n  // disconnectedCallback() {}\n\n  // // This function is called when a Web Component is moved from one document to another.\n  // // You may find a use for this, although I’ve struggled to think of any cases!\n  // adoptedCallback() {}\n\n  addCandlestick(candlestick) {\n    this.candlesticks.push(candlestick);\n  }\n  mouseMoveHandler(event) {\n    this.mousePosition = this.getMousePos(event);\n    this.mousePosition.x += this.candleWidth / 2;\n    this.drawMouseOverlay = true;\n    if (this.mousePosition.x < this.marginLeft) this.drawMouseOverlay = false;\n    if (this.mousePosition.x > this.width - this.marginRight + this.candleWidth) this.drawMouseOverlay = false;\n    if (this.mousePosition.y > this.height - this.marginBottom) this.drawMouseOverlay = false;\n    if (this.drawMouseOverlay) {\n      this.yMouseHover = this.yToValueCoords(this.mousePosition.y);\n      this.xMouseHover = this.xToValueCoords(this.mousePosition.x);\n      // snap to candlesticks\n      const candlestickDelta = this.candlesticks[1].timestamp - this.candlesticks[0].timestamp;\n      this.hoveredCandlestickID = Math.floor((this.xMouseHover - this.candlesticks[0].timestamp) / candlestickDelta);\n      this.xMouseHover = Math.floor(this.xMouseHover / candlestickDelta) * candlestickDelta;\n      this.mousePosition.x = this.xToPixelCoords(this.xMouseHover);\n      this.draw();\n    } else this.draw();\n  }\n  mouseOutHandler(event) {\n    this.drawMouseOverlay = false;\n    this.draw();\n  }\n  getMousePos(event) {\n    const rect = this.getBoundingClientRect();\n    return {\n      x: event.clientX - rect.left,\n      y: event.clientY - rect.top\n    };\n  }\n  draw() {\n    const context = this.getContext('2d');\n\n    // clear background\n    context.clearRect(0, 0, this.width, this.height);\n    this.calculateYRange();\n    this.calculateXRange();\n    this.drawGrid();\n    this.candleWidth = this.xPixelRange / this.candlesticks.length;\n    this.candleWidth--;\n    if (this.candleWidth % 2 === 0) this.candleWidth--;\n    for (let color, candlestick, i = 0; i < this.candlesticks.length; ++i) {\n      candlestick = this.candlesticks[i];\n      color = candlestick.close > candlestick.open ? this.greenColor : this.redColor;\n      if (i === this.hoveredCandlestickID) {\n        if (color === this.greenColor) color = this.greenHoverColor;else if (color === this.redColor) color = this.redHoverColor;\n      }\n\n      // draw the wick\n      this.drawLine(this.xToPixelCoords(candlestick.timestamp), this.yToPixelCoords(candlestick.low), this.xToPixelCoords(candlestick.timestamp), this.yToPixelCoords(candlestick.high), color);\n\n      // draw the candle\n      this.fillRect(this.xToPixelCoords(candlestick.timestamp) - Math.floor(this.candleWidth / 2), this.yToPixelCoords(candlestick.open), this.candleWidth, this.yToPixelCoords(candlestick.close) - this.yToPixelCoords(candlestick.open), color);\n    }\n\n    // draw mouse hover\n    if (this.drawMouseOverlay && context) {\n      // price line\n      context.setLineDash([5, 5]);\n      this.drawLine(0, this.mousePosition.y, this.width, this.mousePosition.y, this.mouseHoverBackgroundColor);\n      context.setLineDash([]);\n      let str = this.roundPriceValue(this.yMouseHover).toString();\n      let textWidth = context.measureText(str).width;\n      this.fillRect(this.width - 70, this.mousePosition.y - 10, 70, 20, this.mouseHoverBackgroundColor);\n      context.fillStyle = this.mouseHoverTextColor;\n      context.fillText(str, this.width - textWidth - 5, this.mousePosition.y + 5);\n\n      // time line\n      context.setLineDash([5, 5]);\n      this.drawLine(this.mousePosition.x, 0, this.mousePosition.x, this.height, this.mouseHoverBackgroundColor);\n      context.setLineDash([]);\n      str = this.formatDate(new Date(this.xMouseHover)).toString();\n      textWidth = context.measureText(str).width;\n      this.fillRect(this.mousePosition.x - textWidth / 2 - 5, this.height - 20, textWidth + 10, 20, this.mouseHoverBackgroundColor);\n      context.fillStyle = this.mouseHoverTextColor;\n      context.fillText(str, this.mousePosition.x - textWidth / 2, this.height - 5);\n\n      // data\n      let yPos = this.mousePosition.y - 95;\n      if (yPos < 0) {\n        yPos = this.mousePosition.y + 15;\n      }\n      this.fillRect(this.mousePosition.x + 15, yPos, 100, 80, this.mouseHoverBackgroundColor);\n      const color = this.candlesticks[this.hoveredCandlestickID].close > this.candlesticks[this.hoveredCandlestickID].open ? this.greenColor : this.redColor;\n      this.fillRect(this.mousePosition.x + 15, yPos, 10, 80, color);\n      context.lineWidth = 2;\n      this.drawRect(this.mousePosition.x + 15, yPos, 100, 80, color);\n      context.lineWidth = 1;\n      context.fillStyle = this.mouseHoverTextColor;\n      context.fillText('O: ' + this.candlesticks[this.hoveredCandlestickID].open, this.mousePosition.x + 30, yPos + 15);\n      context.fillText('C: ' + this.candlesticks[this.hoveredCandlestickID].close, this.mousePosition.x + 30, yPos + 35);\n      context.fillText('H: ' + this.candlesticks[this.hoveredCandlestickID].high, this.mousePosition.x + 30, yPos + 55);\n      context.fillText('L: ' + this.candlesticks[this.hoveredCandlestickID].low, this.mousePosition.x + 30, yPos + 75);\n    }\n  }\n  drawGrid() {\n    const context = this.getContext('2d');\n\n    // roughly divide the yRange into cells\n    const yGridSize = this.yRange / this.yGridCells;\n\n    // try to find a nice number to round to\n    let niceNumber = Math.pow(10, Math.ceil(Math.log10(yGridSize)));\n    if (yGridSize < 0.25 * niceNumber) niceNumber = 0.25 * niceNumber;else if (yGridSize < 0.5 * niceNumber) niceNumber = 0.5 * niceNumber;\n\n    // find next largest nice number above yStart\n    const yStartRoundNumber = Math.ceil(this.yStart / niceNumber) * niceNumber;\n    // find next lowest nice number below yEnd\n    const yEndRoundNumber = Math.floor(this.yEnd / niceNumber) * niceNumber;\n    for (let textWidth, y = yStartRoundNumber; y <= yEndRoundNumber; y += niceNumber) {\n      this.drawLine(0, this.yToPixelCoords(y), this.width, this.yToPixelCoords(y), this.gridColor);\n      textWidth = context.measureText(this.roundPriceValue(y).toString()).width;\n      context.fillStyle = this.gridTextColor;\n      context.fillText(this.roundPriceValue(y).toString(), this.width - textWidth - 5, this.yToPixelCoords(y) - 5);\n    }\n\n    // roughly divide the xRange into cells\n    const xGridSize = this.xRange / this.xGridCells;\n\n    // try to find a nice number to round to\n    niceNumber = Math.pow(10, Math.ceil(Math.log10(xGridSize)));\n    if (xGridSize < 0.25 * niceNumber) {\n      niceNumber = 0.25 * niceNumber;\n    } else if (xGridSize < 0.5 * niceNumber) {\n      niceNumber = 0.5 * niceNumber;\n    }\n\n    // find next largest nice number above yStart\n    const xStartRoundNumber = Math.ceil(this.xStart / niceNumber) * niceNumber;\n    // find next lowest nice number below yEnd\n    const xEndRoundNumber = Math.floor(this.xEnd / niceNumber) * niceNumber;\n\n    // if the total x range is more than 5 days, format the timestamp as date instead of hours\n    let formatAsDate = this.xRange > 60 * 60 * 24 * 1000 * 5;\n    for (let day, month, minutes, date, dateStr, x = xStartRoundNumber; x <= xEndRoundNumber; x += niceNumber) {\n      this.drawLine(this.xToPixelCoords(x), 0, this.xToPixelCoords(x), this.height, this.gridColor);\n      date = new Date(x);\n      dateStr = '';\n      if (formatAsDate) {\n        day = date.getDate();\n        // if (day < 10) day = '0' + day;\n        month = date.getMonth() + 1;\n        // if (month < 10) month = '0' + month;\n        dateStr = `${day < 10 ? '0' + day : day}.${month < 10 ? '0' + month : month}`;\n      } else {\n        minutes = date.getMinutes();\n        if (minutes < 10) {\n          minutes = '0' + minutes;\n        }\n        dateStr = date.getHours() + ':' + minutes;\n      }\n      context.fillStyle = this.gridTextColor;\n      context.fillText(dateStr, this.xToPixelCoords(x) + 5, this.height - 5);\n    }\n  }\n  calculateYRange() {\n    for (let i = 0; i < this.candlesticks.length; ++i) {\n      if (i === 0) {\n        this.yStart = this.candlesticks[i].low;\n        this.yEnd = this.candlesticks[i].high;\n      } else {\n        if (this.candlesticks[i].low < this.yStart) {\n          this.yStart = this.candlesticks[i].low;\n        }\n        if (this.candlesticks[i].high > this.yEnd) {\n          this.yEnd = this.candlesticks[i].high;\n        }\n      }\n    }\n    this.yRange = this.yEnd - this.yStart;\n  }\n  calculateXRange() {\n    this.xStart = this.candlesticks[0].timestamp;\n    this.xEnd = this.candlesticks[this.candlesticks.length - 1].timestamp;\n    this.xRange = this.xEnd - this.xStart;\n  }\n  yToPixelCoords(y) {\n    return this.height - this.marginBottom - (y - this.yStart) * this.yPixelRange / this.yRange;\n  }\n  xToPixelCoords(x) {\n    return this.marginLeft + (x - this.xStart) * this.xPixelRange / this.xRange;\n  }\n  yToValueCoords(y) {\n    return this.yStart + (this.height - this.marginBottom - y) * this.yRange / this.yPixelRange;\n  }\n  xToValueCoords(x) {\n    return this.xStart + (x - this.marginLeft) * this.xRange / this.xPixelRange;\n  }\n  drawLine(xStart, yStart, xEnd, yEnd, color) {\n    const context = this.getContext('2d');\n    context.beginPath();\n    // to get a crisp 1 pixel wide line, we need to add 0.5 to the coords\n    context.moveTo(xStart + 0.5, yStart + 0.5);\n    context.lineTo(xEnd + 0.5, yEnd + 0.5);\n    context.strokeStyle = color;\n    context.stroke();\n  }\n  fillRect(x, y, width, height, color) {\n    const context = this.getContext('2d');\n    context.beginPath();\n    context.fillStyle = color;\n    context.rect(x, y, width, height);\n    context.fill();\n  }\n  drawRect(x, y, width, height, color) {\n    const context = this.getContext('2d');\n    context.beginPath();\n    context.strokeStyle = color;\n    context.rect(x, y, width, height);\n    context.stroke();\n  }\n  formatDate(date) {\n    const day = date.getDate();\n    const month = date.getMonth() + 1;\n    const hours = date.getHours();\n    const minutes = date.getMinutes();\n    const year = date.getFullYear();\n    return `${day < 10 ? '0' + day : day}/${month < 10 ? '0' + month : month}/${year} - ${hours < 10 ? '0' + hours : hours}:${minutes < 10 ? '0' + minutes : minutes}`;\n  }\n  roundPriceValue(value) {\n    if (value > 1.0) return Math.round(value * 100) / 100;\n    if (value > 0.001) return Math.round(value * 1000) / 1000;\n    if (value > 0.00001) return Math.round(value * 100000) / 100000;\n    if (value > 0.0000001) return Math.round(value * 10000000) / 10000000;else return Math.round(value * 1000000000) / 1000000000;\n  }\n}\n// export CandlestickChart;\nexport default CandlestickChart;\nwindow.customElements.define('candle-stick-chart', CandlestickChart, {\n  extends: 'canvas'\n});\n\n// class Chart extends HTMLCanvasElement {\n//   constructor() {\n//     super();\n//   }\n// }\n// window.customElements.define('candle-stick-chart', Chart, { extends: 'canvas' });","map":{"version":3,"names":["Candlestick","constructor","timestamp","open","close","high","low","parseInt","toString","parseFloat","VolumeBar","volume","CandlestickChart","HTMLCanvasElement","observedAttributes","candlesticks","gridColor","gridTextColor","mouseHoverBackgroundColor","mouseHoverTextColor","greenColor","redHoverColor","candleWidth","marginLeft","marginRight","marginTop","marginBottom","yStart","yEnd","yRange","yPixelRange","xEnd","xGridCells","drawMouseOverlay","mousePosition","xMouseHover","yMouseHover","hoveredCandlestickID","xPixelRange","xStart","xRange","redColor","greenHoverColor","yGridCells","context","getContext","font","lineWidth","attachShadow","mode","addEventListener","mouseMoveHandler","bind","mouseOutHandler","style","backgroundColor","height","width","x","y","attributeChangedCallback","propertyName","oldValue","newValue","addCandlestick","candlestick","push","event","getMousePos","yToValueCoords","xToValueCoords","candlestickDelta","Math","floor","xToPixelCoords","draw","rect","getBoundingClientRect","clientX","left","clientY","top","clearRect","calculateYRange","calculateXRange","drawGrid","length","color","i","drawLine","yToPixelCoords","fillRect","setLineDash","str","roundPriceValue","textWidth","measureText","fillStyle","fillText","formatDate","Date","yPos","drawRect","yGridSize","niceNumber","pow","ceil","log10","yStartRoundNumber","yEndRoundNumber","xGridSize","xStartRoundNumber","xEndRoundNumber","formatAsDate","day","month","minutes","date","dateStr","getDate","getMonth","getMinutes","getHours","beginPath","moveTo","lineTo","strokeStyle","stroke","fill","hours","year","getFullYear","value","round","window","customElements","define","extends"],"sources":["C:/Users/Lucian/Documents/DEV/nodejs/stock-market-api/dev/static/src/components/CandleStickChart.tsx"],"sourcesContent":["export class Candlestick {\r\n  timestamp: number;\r\n  close: number;\r\n  high: number;\r\n  low: number;\r\n  open: number;\r\n\r\n  constructor({ timestamp, open, close, high, low }: TCandleStick) {\r\n    this.timestamp = parseInt(timestamp.toString());\r\n    this.open = parseFloat(open.toString());\r\n    this.close = parseFloat(close.toString());\r\n    this.high = parseFloat(high.toString());\r\n    this.low = parseFloat(low.toString());\r\n  }\r\n}\r\n\r\nexport class VolumeBar {\r\n  timestamp: number;\r\n  volume: number;\r\n\r\n  constructor({ timestamp, volume }: TVolume) {\r\n    this.timestamp = parseInt(timestamp.toString());\r\n    this.volume = parseFloat(volume.toString());\r\n  }\r\n}\r\n\r\nclass CandlestickChart extends HTMLCanvasElement {\r\n  private candlesticks: Candlestick[];\r\n  gridColor: string;\r\n  gridTextColor: string;\r\n  mouseHoverBackgroundColor: string;\r\n  mouseHoverTextColor: string;\r\n  greenColor: string;\r\n  redHoverColor: string;\r\n  candleWidth: number;\r\n  marginLeft: number;\r\n  marginRight: number;\r\n  marginTop: number;\r\n  marginBottom: number;\r\n  yStart: number;\r\n  yEnd: number;\r\n  yRange: number;\r\n  yPixelRange: number;\r\n  xEnd: number;\r\n  xGridCells: number;\r\n  drawMouseOverlay: boolean;\r\n  mousePosition: { x: number; y: number; };\r\n  xMouseHover: number;\r\n  yMouseHover: number;\r\n  hoveredCandlestickID: number;\r\n  xPixelRange: number;\r\n  xStart: number;\r\n  xRange: number;\r\n  redColor: string;\r\n  greenHoverColor: string;\r\n  yGridCells: number;\r\n\r\n  // Returns an array of attributes that the browser will observe.\r\n  static observedAttributes() {}\r\n\r\n  // It’s called when the component is first initialized.\r\n  // It must call super() and can set any defaults or perform other pre-rendering processes.\r\n  constructor() {\r\n    super();\r\n\r\n    const context = this.getContext('2d') as CanvasRenderingContext2D;\r\n\r\n    context.font = '12px sans-serif';\r\n    context.lineWidth = 1;\r\n\r\n    this.attachShadow({ mode: 'open' });\r\n\r\n    this.addEventListener('mousemove', this.mouseMoveHandler.bind(this));\r\n    this.addEventListener('mouseout', this.mouseOutHandler.bind(this));\r\n\r\n    this.style.backgroundColor = '#252525';\r\n\r\n    this.gridColor = '#444444';\r\n    this.gridTextColor = '#aaaaaa';\r\n    this.mouseHoverBackgroundColor = '#eeeeee';\r\n    this.mouseHoverTextColor = '#000000';\r\n    this.greenColor = '#00cc00';\r\n    this.redColor = '#cc0000';\r\n    this.greenHoverColor = '#00ff00';\r\n    this.redHoverColor = '#ff0000';\r\n\r\n    this.candleWidth = 5;\r\n\r\n    this.marginLeft = 10;\r\n    this.marginRight = 100;\r\n    this.marginTop = 10;\r\n    this.marginBottom = 30;\r\n\r\n    this.yStart = 0;\r\n    this.yEnd = 0;\r\n    this.yRange = 0;\r\n    this.yPixelRange = this.height-this.marginTop-this.marginBottom;\r\n\r\n    this.xStart = 0;\r\n    this.xEnd = 0;\r\n    this.xRange = 0;\r\n    this.xPixelRange = this.width-this.marginLeft-this.marginRight;\r\n\r\n    // these are only approximations, the grid will be divided in a way so the numbers are nice\r\n    this.xGridCells = 16;\r\n    this.yGridCells = 16;\r\n\r\n    this.drawMouseOverlay = false;\r\n    this.mousePosition = { x: 0 , y: 0 };\r\n    this.xMouseHover = 0;\r\n    this.yMouseHover = 0;\r\n    this.hoveredCandlestickID = 0;\r\n\r\n    this.candlesticks = [];\r\n  }\r\n\r\n  // Called whenever an observed attribute is changed.\r\n  // Those defined in HTML are passed immediately, but JavaScript can modify them:\r\n  attributeChangedCallback(propertyName: string, oldValue: any, newValue: any) {\r\n    // document.querySelector('hello-world').setAttribute('name', 'Everyone');\r\n    // The method may need to trigger a re-render when this occurs.\r\n  }\r\n\r\n  // // This function is called when the Web Component is appended to a Document Object Model.\r\n  // // It should run any required rendering.\r\n  // connectedCallback() {}\r\n\r\n  // // It’s called when the Web Component is removed from a Document Object Model.\r\n  // // This may be useful if you need to clean up, such as removing stored state or\r\n  // // aborting Ajax requests.\r\n  // disconnectedCallback() {}\r\n\r\n  // // This function is called when a Web Component is moved from one document to another.\r\n  // // You may find a use for this, although I’ve struggled to think of any cases!\r\n  // adoptedCallback() {}\r\n\r\n  addCandlestick(candlestick: Candlestick) {\r\n    this.candlesticks.push(candlestick);\r\n  }\r\n\r\n  mouseMoveHandler(event: MouseEvent) {\r\n    this.mousePosition = this.getMousePos(event);\r\n    this.mousePosition.x += this.candleWidth / 2;\r\n    this.drawMouseOverlay = true;\r\n    if (this.mousePosition.x < this.marginLeft) this.drawMouseOverlay = false;\r\n    if (this.mousePosition.x > this.width - this.marginRight + this.candleWidth)\r\n      this.drawMouseOverlay = false;\r\n    if (this.mousePosition.y > this.height - this.marginBottom)\r\n      this.drawMouseOverlay = false;\r\n    if (this.drawMouseOverlay) {\r\n      this.yMouseHover = this.yToValueCoords(this.mousePosition.y);\r\n      this.xMouseHover = this.xToValueCoords(this.mousePosition.x);\r\n      // snap to candlesticks\r\n      const candlestickDelta = this.candlesticks[1].timestamp - this.candlesticks[0].timestamp;\r\n      this.hoveredCandlestickID = Math.floor( (this.xMouseHover - this.candlesticks[0].timestamp) / candlestickDelta);\r\n      this.xMouseHover = Math.floor(this.xMouseHover / candlestickDelta) * candlestickDelta;\r\n      this.mousePosition.x = this.xToPixelCoords(this.xMouseHover);\r\n      this.draw();\r\n    } else this.draw();\r\n  }\r\n\r\n  mouseOutHandler(event: MouseEvent) {\r\n    this.drawMouseOverlay = false;\r\n    this.draw();\r\n  }\r\n\r\n  getMousePos(event: MouseEvent) {\r\n    const rect = this.getBoundingClientRect();\r\n    return { x: event.clientX - rect.left, y: event.clientY - rect.top };\r\n  }\r\n\r\n  draw() {\r\n    const context = this.getContext('2d') as CanvasRenderingContext2D;\r\n\r\n    // clear background\r\n    context.clearRect(0, 0, this.width, this.height);\r\n    this.calculateYRange();\r\n    this.calculateXRange();\r\n\r\n    this.drawGrid();\r\n\r\n    this.candleWidth = this.xPixelRange / this.candlesticks.length;\r\n    this.candleWidth--;\r\n    if (this.candleWidth % 2 === 0) this.candleWidth--;\r\n\r\n    for (let color, candlestick, i = 0; i < this.candlesticks.length; ++i) {\r\n      candlestick = this.candlesticks[i];\r\n      color = candlestick.close > candlestick.open ? this.greenColor : this.redColor;\r\n\r\n      if (i === this.hoveredCandlestickID) {\r\n        if (color === this.greenColor) color = this.greenHoverColor;\r\n        else if (color === this.redColor) color = this.redHoverColor;\r\n      }\r\n\r\n      // draw the wick\r\n      this.drawLine(\r\n        this.xToPixelCoords(candlestick.timestamp),\r\n        this.yToPixelCoords(candlestick.low),\r\n        this.xToPixelCoords(candlestick.timestamp),\r\n        this.yToPixelCoords(candlestick.high),\r\n        color\r\n      );\r\n\r\n      // draw the candle\r\n      this.fillRect(\r\n        this.xToPixelCoords(candlestick.timestamp) - Math.floor(this.candleWidth / 2),\r\n        this.yToPixelCoords(candlestick.open),\r\n        this.candleWidth,\r\n        this.yToPixelCoords(candlestick.close) - this.yToPixelCoords(candlestick.open),\r\n        color\r\n      );\r\n    }\r\n\r\n    // draw mouse hover\r\n    if (this.drawMouseOverlay && context) {\r\n      // price line\r\n      context.setLineDash([5, 5]);\r\n      this.drawLine(0, this.mousePosition.y, this.width, this.mousePosition.y, this.mouseHoverBackgroundColor);\r\n      context.setLineDash([]);\r\n      let str = this.roundPriceValue(this.yMouseHover).toString();\r\n      let textWidth = context.measureText(str).width;\r\n      this.fillRect(this.width - 70, this.mousePosition.y - 10, 70, 20, this.mouseHoverBackgroundColor);\r\n      context.fillStyle = this.mouseHoverTextColor;\r\n      context.fillText(str, this.width - textWidth - 5, this.mousePosition.y + 5);\r\n\r\n      // time line\r\n      context.setLineDash([5, 5]);\r\n      this.drawLine(this.mousePosition.x, 0, this.mousePosition.x, this.height, this.mouseHoverBackgroundColor);\r\n      context.setLineDash([]);\r\n      str = this.formatDate(new Date(this.xMouseHover)).toString();\r\n      textWidth = context.measureText(str).width;\r\n      this.fillRect(this.mousePosition.x - textWidth / 2 - 5, this.height - 20, textWidth + 10, 20, this.mouseHoverBackgroundColor);\r\n      context.fillStyle = this.mouseHoverTextColor;\r\n      context.fillText(str, this.mousePosition.x - textWidth / 2, this.height - 5);\r\n\r\n      // data\r\n      let yPos = this.mousePosition.y - 95;\r\n      if (yPos < 0) {\r\n        yPos = this.mousePosition.y + 15;\r\n      }\r\n\r\n      this.fillRect(this.mousePosition.x + 15, yPos, 100, 80, this.mouseHoverBackgroundColor);\r\n      const color =\r\n        this.candlesticks[this.hoveredCandlestickID].close >\r\n        this.candlesticks[this.hoveredCandlestickID].open ? this.greenColor : this.redColor;\r\n      this.fillRect(this.mousePosition.x + 15, yPos, 10, 80, color);\r\n      context.lineWidth = 2;\r\n      this.drawRect(this.mousePosition.x + 15, yPos, 100, 80, color);\r\n      context.lineWidth = 1;\r\n\r\n      context.fillStyle = this.mouseHoverTextColor;\r\n      context.fillText(\r\n        'O: ' + this.candlesticks[this.hoveredCandlestickID].open,\r\n        this.mousePosition.x + 30,\r\n        yPos + 15\r\n      );\r\n      context.fillText(\r\n        'C: ' + this.candlesticks[this.hoveredCandlestickID].close,\r\n        this.mousePosition.x + 30,\r\n        yPos + 35\r\n      );\r\n      context.fillText(\r\n        'H: ' + this.candlesticks[this.hoveredCandlestickID].high,\r\n        this.mousePosition.x + 30,\r\n        yPos + 55\r\n      );\r\n      context.fillText(\r\n        'L: ' + this.candlesticks[this.hoveredCandlestickID].low,\r\n        this.mousePosition.x + 30,\r\n        yPos + 75\r\n      );\r\n    }\r\n  }\r\n\r\n  drawGrid() {\r\n    const context = this.getContext('2d') as CanvasRenderingContext2D ;\r\n\r\n    // roughly divide the yRange into cells\r\n    const yGridSize = this.yRange / this.yGridCells;\r\n  \r\n    // try to find a nice number to round to\r\n    let niceNumber = Math.pow(10, Math.ceil(Math.log10(yGridSize)));\r\n    if (yGridSize < 0.25 * niceNumber) niceNumber = 0.25 * niceNumber;\r\n    else if (yGridSize < 0.5 * niceNumber) niceNumber = 0.5 * niceNumber;\r\n  \r\n    // find next largest nice number above yStart\r\n    const yStartRoundNumber = Math.ceil(this.yStart / niceNumber) * niceNumber;\r\n    // find next lowest nice number below yEnd\r\n    const yEndRoundNumber = Math.floor(this.yEnd / niceNumber) * niceNumber;\r\n  \r\n    for (let textWidth, y = yStartRoundNumber; y <= yEndRoundNumber; y += niceNumber) {\r\n      this.drawLine(0, this.yToPixelCoords(y), this.width, this.yToPixelCoords(y), this.gridColor);\r\n      textWidth = context.measureText(this.roundPriceValue(y).toString()).width;\r\n      context.fillStyle = this.gridTextColor;\r\n      context.fillText(this.roundPriceValue(y).toString(), this.width - textWidth - 5, this.yToPixelCoords(y) - 5);\r\n    }\r\n  \r\n    // roughly divide the xRange into cells\r\n    const xGridSize = this.xRange / this.xGridCells;\r\n  \r\n    // try to find a nice number to round to\r\n    niceNumber = Math.pow(10, Math.ceil(Math.log10(xGridSize)));\r\n    if (xGridSize < 0.25 * niceNumber) {\r\n      niceNumber = 0.25 * niceNumber;\r\n    } else if (xGridSize < 0.5 * niceNumber) {\r\n      niceNumber = 0.5 * niceNumber;\r\n    }\r\n\r\n    // find next largest nice number above yStart\r\n    const xStartRoundNumber = Math.ceil(this.xStart / niceNumber) * niceNumber;\r\n    // find next lowest nice number below yEnd\r\n    const xEndRoundNumber = Math.floor(this.xEnd / niceNumber) * niceNumber;\r\n  \r\n    // if the total x range is more than 5 days, format the timestamp as date instead of hours\r\n    let formatAsDate = (this.xRange > 60 * 60 * 24 * 1000 * 5);\r\n  \r\n    for (let day, month, minutes, date, dateStr, x = xStartRoundNumber; x <= xEndRoundNumber; x += niceNumber) {\r\n      this.drawLine(this.xToPixelCoords(x), 0, this.xToPixelCoords(x), this.height, this.gridColor);\r\n      date = new Date(x);\r\n      dateStr = '';\r\n      if (formatAsDate) {\r\n        day = date.getDate();\r\n        // if (day < 10) day = '0' + day;\r\n        month = date.getMonth() + 1;\r\n        // if (month < 10) month = '0' + month;\r\n        dateStr = `${(day < 10) ? '0' + day : day}.${(month < 10) ? '0' + month : month}`;\r\n      } else {\r\n        minutes = date.getMinutes();\r\n        if (minutes < 10) {\r\n          minutes = '0' + minutes;\r\n        }\r\n        dateStr = date.getHours() + ':' + minutes;\r\n      }\r\n      context.fillStyle = this.gridTextColor;\r\n      context.fillText(dateStr, this.xToPixelCoords(x) + 5, this.height - 5);\r\n    }\r\n  }\r\n\r\n  calculateYRange() {\r\n    for (let i = 0; i < this.candlesticks.length; ++i) {\r\n      if (i === 0) {\r\n        this.yStart = this.candlesticks[i].low;\r\n        this.yEnd = this.candlesticks[i].high;\r\n      } else {\r\n        if (this.candlesticks[i].low < this.yStart) {\r\n          this.yStart = this.candlesticks[i].low;\r\n        }\r\n        if (this.candlesticks[i].high > this.yEnd) {\r\n          this.yEnd = this.candlesticks[i].high;\r\n        }\r\n      }\r\n    }\r\n    this.yRange = this.yEnd - this.yStart;\r\n  }\r\n\r\n  calculateXRange() {\r\n    this.xStart = this.candlesticks[0].timestamp;\r\n    this.xEnd = this.candlesticks[this.candlesticks.length - 1].timestamp;\r\n    this.xRange = this.xEnd - this.xStart;\r\n  }\r\n\r\n  yToPixelCoords(y: number) {\r\n    return (this.height - this.marginBottom - ((y - this.yStart) * this.yPixelRange) / this.yRange);\r\n  }\r\n\r\n  xToPixelCoords(x: number) {\r\n    return this.marginLeft + ((x - this.xStart) * this.xPixelRange) / this.xRange;\r\n  }\r\n\r\n  yToValueCoords(y: number) {\r\n    return (this.yStart + ((this.height - this.marginBottom - y) * this.yRange) / this.yPixelRange);\r\n  }\r\n\r\n  xToValueCoords(x: number) {\r\n    return this.xStart + ((x - this.marginLeft) * this.xRange) / this.xPixelRange;\r\n  }\r\n\r\n  drawLine( xStart: number, yStart: number, xEnd: number, yEnd: number, color: string | CanvasGradient | CanvasPattern) {\r\n    const context = this.getContext('2d') as CanvasRenderingContext2D ;\r\n    context.beginPath();\r\n    // to get a crisp 1 pixel wide line, we need to add 0.5 to the coords\r\n    context.moveTo(xStart + 0.5, yStart + 0.5);\r\n    context.lineTo(xEnd + 0.5, yEnd + 0.5);\r\n    context.strokeStyle = color;\r\n    context.stroke();\r\n  }\r\n\r\n  fillRect(x: number, y: number, width: number, height: number, color: string | CanvasGradient | CanvasPattern) {\r\n    const context = this.getContext('2d') as CanvasRenderingContext2D ;\r\n    context.beginPath();\r\n    context.fillStyle = color;\r\n    context.rect(x, y, width, height);\r\n    context.fill();\r\n  }\r\n  \r\n  drawRect(x: number, y: number, width: number, height: number, color: string | CanvasGradient | CanvasPattern) {\r\n    const context = this.getContext('2d') as CanvasRenderingContext2D ;\r\n    context.beginPath();\r\n    context.strokeStyle = color;\r\n    context.rect(x, y, width, height);\r\n    context.stroke();\r\n  }\r\n\r\n  formatDate(date: Date) {\r\n    const day = date.getDate();\r\n    const month = date.getMonth() + 1;\r\n    const hours = date.getHours();\r\n    const minutes = date.getMinutes();\r\n    const year = date.getFullYear();\r\n\r\n    return `${(day < 10) ? '0' + day : day}/${(month < 10) ? '0' + month : month}/${year} - ${(hours < 10) ? '0' + hours : hours}:${(minutes < 10) ? '0' + minutes : minutes}`;\r\n  }\r\n  \r\n  roundPriceValue(value: number) {\r\n    if (value > 1.0) return Math.round(value * 100) / 100;\r\n    if (value > 0.001) return Math.round(value * 1000) / 1000;\r\n    if (value > 0.00001) return Math.round(value * 100000) / 100000;\r\n    if (value > 0.0000001) return Math.round(value * 10000000) / 10000000;\r\n    else return Math.round(value * 1000000000) / 1000000000;\r\n  }\r\n}\r\n// export CandlestickChart;\r\nexport default CandlestickChart;\r\nwindow.customElements.define('candle-stick-chart', CandlestickChart, { extends: 'canvas' });\r\n\r\n// class Chart extends HTMLCanvasElement {\r\n//   constructor() {\r\n//     super();\r\n//   }\r\n// }\r\n// window.customElements.define('candle-stick-chart', Chart, { extends: 'canvas' });\r\n"],"mappings":"AAAA,OAAO,MAAMA,WAAW,CAAC;EAOvBC,WAAW,OAAsD;IAAA,IAArD;MAAEC,SAAS;MAAEC,IAAI;MAAEC,KAAK;MAAEC,IAAI;MAAEC;IAAkB,CAAC;IAAA,KAN/DJ,SAAS;IAAA,KACTE,KAAK;IAAA,KACLC,IAAI;IAAA,KACJC,GAAG;IAAA,KACHH,IAAI;IAGF,IAAI,CAACD,SAAS,GAAGK,QAAQ,CAACL,SAAS,CAACM,QAAQ,EAAE,CAAC;IAC/C,IAAI,CAACL,IAAI,GAAGM,UAAU,CAACN,IAAI,CAACK,QAAQ,EAAE,CAAC;IACvC,IAAI,CAACJ,KAAK,GAAGK,UAAU,CAACL,KAAK,CAACI,QAAQ,EAAE,CAAC;IACzC,IAAI,CAACH,IAAI,GAAGI,UAAU,CAACJ,IAAI,CAACG,QAAQ,EAAE,CAAC;IACvC,IAAI,CAACF,GAAG,GAAGG,UAAU,CAACH,GAAG,CAACE,QAAQ,EAAE,CAAC;EACvC;AACF;AAEA,OAAO,MAAME,SAAS,CAAC;EAIrBT,WAAW,QAAiC;IAAA,IAAhC;MAAEC,SAAS;MAAES;IAAgB,CAAC;IAAA,KAH1CT,SAAS;IAAA,KACTS,MAAM;IAGJ,IAAI,CAACT,SAAS,GAAGK,QAAQ,CAACL,SAAS,CAACM,QAAQ,EAAE,CAAC;IAC/C,IAAI,CAACG,MAAM,GAAGF,UAAU,CAACE,MAAM,CAACH,QAAQ,EAAE,CAAC;EAC7C;AACF;AAEA,MAAMI,gBAAgB,SAASC,iBAAiB,CAAC;EA+B/C;EACA,OAAOC,kBAAkB,GAAG,CAAC;;EAE7B;EACA;EACAb,WAAW,GAAG;IACZ,KAAK,EAAE;IAAC,KApCFc,YAAY;IAAA,KACpBC,SAAS;IAAA,KACTC,aAAa;IAAA,KACbC,yBAAyB;IAAA,KACzBC,mBAAmB;IAAA,KACnBC,UAAU;IAAA,KACVC,aAAa;IAAA,KACbC,WAAW;IAAA,KACXC,UAAU;IAAA,KACVC,WAAW;IAAA,KACXC,SAAS;IAAA,KACTC,YAAY;IAAA,KACZC,MAAM;IAAA,KACNC,IAAI;IAAA,KACJC,MAAM;IAAA,KACNC,WAAW;IAAA,KACXC,IAAI;IAAA,KACJC,UAAU;IAAA,KACVC,gBAAgB;IAAA,KAChBC,aAAa;IAAA,KACbC,WAAW;IAAA,KACXC,WAAW;IAAA,KACXC,oBAAoB;IAAA,KACpBC,WAAW;IAAA,KACXC,MAAM;IAAA,KACNC,MAAM;IAAA,KACNC,QAAQ;IAAA,KACRC,eAAe;IAAA,KACfC,UAAU;IAUR,MAAMC,OAAO,GAAG,IAAI,CAACC,UAAU,CAAC,IAAI,CAA6B;IAEjED,OAAO,CAACE,IAAI,GAAG,iBAAiB;IAChCF,OAAO,CAACG,SAAS,GAAG,CAAC;IAErB,IAAI,CAACC,YAAY,CAAC;MAAEC,IAAI,EAAE;IAAO,CAAC,CAAC;IAEnC,IAAI,CAACC,gBAAgB,CAAC,WAAW,EAAE,IAAI,CAACC,gBAAgB,CAACC,IAAI,CAAC,IAAI,CAAC,CAAC;IACpE,IAAI,CAACF,gBAAgB,CAAC,UAAU,EAAE,IAAI,CAACG,eAAe,CAACD,IAAI,CAAC,IAAI,CAAC,CAAC;IAElE,IAAI,CAACE,KAAK,CAACC,eAAe,GAAG,SAAS;IAEtC,IAAI,CAACvC,SAAS,GAAG,SAAS;IAC1B,IAAI,CAACC,aAAa,GAAG,SAAS;IAC9B,IAAI,CAACC,yBAAyB,GAAG,SAAS;IAC1C,IAAI,CAACC,mBAAmB,GAAG,SAAS;IACpC,IAAI,CAACC,UAAU,GAAG,SAAS;IAC3B,IAAI,CAACqB,QAAQ,GAAG,SAAS;IACzB,IAAI,CAACC,eAAe,GAAG,SAAS;IAChC,IAAI,CAACrB,aAAa,GAAG,SAAS;IAE9B,IAAI,CAACC,WAAW,GAAG,CAAC;IAEpB,IAAI,CAACC,UAAU,GAAG,EAAE;IACpB,IAAI,CAACC,WAAW,GAAG,GAAG;IACtB,IAAI,CAACC,SAAS,GAAG,EAAE;IACnB,IAAI,CAACC,YAAY,GAAG,EAAE;IAEtB,IAAI,CAACC,MAAM,GAAG,CAAC;IACf,IAAI,CAACC,IAAI,GAAG,CAAC;IACb,IAAI,CAACC,MAAM,GAAG,CAAC;IACf,IAAI,CAACC,WAAW,GAAG,IAAI,CAAC0B,MAAM,GAAC,IAAI,CAAC/B,SAAS,GAAC,IAAI,CAACC,YAAY;IAE/D,IAAI,CAACa,MAAM,GAAG,CAAC;IACf,IAAI,CAACR,IAAI,GAAG,CAAC;IACb,IAAI,CAACS,MAAM,GAAG,CAAC;IACf,IAAI,CAACF,WAAW,GAAG,IAAI,CAACmB,KAAK,GAAC,IAAI,CAAClC,UAAU,GAAC,IAAI,CAACC,WAAW;;IAE9D;IACA,IAAI,CAACQ,UAAU,GAAG,EAAE;IACpB,IAAI,CAACW,UAAU,GAAG,EAAE;IAEpB,IAAI,CAACV,gBAAgB,GAAG,KAAK;IAC7B,IAAI,CAACC,aAAa,GAAG;MAAEwB,CAAC,EAAE,CAAC;MAAGC,CAAC,EAAE;IAAE,CAAC;IACpC,IAAI,CAACxB,WAAW,GAAG,CAAC;IACpB,IAAI,CAACC,WAAW,GAAG,CAAC;IACpB,IAAI,CAACC,oBAAoB,GAAG,CAAC;IAE7B,IAAI,CAACtB,YAAY,GAAG,EAAE;EACxB;;EAEA;EACA;EACA6C,wBAAwB,CAACC,YAAoB,EAAEC,QAAa,EAAEC,QAAa,EAAE;IAC3E;IACA;EAAA;;EAGF;EACA;EACA;;EAEA;EACA;EACA;EACA;;EAEA;EACA;EACA;;EAEAC,cAAc,CAACC,WAAwB,EAAE;IACvC,IAAI,CAAClD,YAAY,CAACmD,IAAI,CAACD,WAAW,CAAC;EACrC;EAEAd,gBAAgB,CAACgB,KAAiB,EAAE;IAClC,IAAI,CAACjC,aAAa,GAAG,IAAI,CAACkC,WAAW,CAACD,KAAK,CAAC;IAC5C,IAAI,CAACjC,aAAa,CAACwB,CAAC,IAAI,IAAI,CAACpC,WAAW,GAAG,CAAC;IAC5C,IAAI,CAACW,gBAAgB,GAAG,IAAI;IAC5B,IAAI,IAAI,CAACC,aAAa,CAACwB,CAAC,GAAG,IAAI,CAACnC,UAAU,EAAE,IAAI,CAACU,gBAAgB,GAAG,KAAK;IACzE,IAAI,IAAI,CAACC,aAAa,CAACwB,CAAC,GAAG,IAAI,CAACD,KAAK,GAAG,IAAI,CAACjC,WAAW,GAAG,IAAI,CAACF,WAAW,EACzE,IAAI,CAACW,gBAAgB,GAAG,KAAK;IAC/B,IAAI,IAAI,CAACC,aAAa,CAACyB,CAAC,GAAG,IAAI,CAACH,MAAM,GAAG,IAAI,CAAC9B,YAAY,EACxD,IAAI,CAACO,gBAAgB,GAAG,KAAK;IAC/B,IAAI,IAAI,CAACA,gBAAgB,EAAE;MACzB,IAAI,CAACG,WAAW,GAAG,IAAI,CAACiC,cAAc,CAAC,IAAI,CAACnC,aAAa,CAACyB,CAAC,CAAC;MAC5D,IAAI,CAACxB,WAAW,GAAG,IAAI,CAACmC,cAAc,CAAC,IAAI,CAACpC,aAAa,CAACwB,CAAC,CAAC;MAC5D;MACA,MAAMa,gBAAgB,GAAG,IAAI,CAACxD,YAAY,CAAC,CAAC,CAAC,CAACb,SAAS,GAAG,IAAI,CAACa,YAAY,CAAC,CAAC,CAAC,CAACb,SAAS;MACxF,IAAI,CAACmC,oBAAoB,GAAGmC,IAAI,CAACC,KAAK,CAAE,CAAC,IAAI,CAACtC,WAAW,GAAG,IAAI,CAACpB,YAAY,CAAC,CAAC,CAAC,CAACb,SAAS,IAAIqE,gBAAgB,CAAC;MAC/G,IAAI,CAACpC,WAAW,GAAGqC,IAAI,CAACC,KAAK,CAAC,IAAI,CAACtC,WAAW,GAAGoC,gBAAgB,CAAC,GAAGA,gBAAgB;MACrF,IAAI,CAACrC,aAAa,CAACwB,CAAC,GAAG,IAAI,CAACgB,cAAc,CAAC,IAAI,CAACvC,WAAW,CAAC;MAC5D,IAAI,CAACwC,IAAI,EAAE;IACb,CAAC,MAAM,IAAI,CAACA,IAAI,EAAE;EACpB;EAEAtB,eAAe,CAACc,KAAiB,EAAE;IACjC,IAAI,CAAClC,gBAAgB,GAAG,KAAK;IAC7B,IAAI,CAAC0C,IAAI,EAAE;EACb;EAEAP,WAAW,CAACD,KAAiB,EAAE;IAC7B,MAAMS,IAAI,GAAG,IAAI,CAACC,qBAAqB,EAAE;IACzC,OAAO;MAAEnB,CAAC,EAAES,KAAK,CAACW,OAAO,GAAGF,IAAI,CAACG,IAAI;MAAEpB,CAAC,EAAEQ,KAAK,CAACa,OAAO,GAAGJ,IAAI,CAACK;IAAI,CAAC;EACtE;EAEAN,IAAI,GAAG;IACL,MAAM/B,OAAO,GAAG,IAAI,CAACC,UAAU,CAAC,IAAI,CAA6B;;IAEjE;IACAD,OAAO,CAACsC,SAAS,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,CAACzB,KAAK,EAAE,IAAI,CAACD,MAAM,CAAC;IAChD,IAAI,CAAC2B,eAAe,EAAE;IACtB,IAAI,CAACC,eAAe,EAAE;IAEtB,IAAI,CAACC,QAAQ,EAAE;IAEf,IAAI,CAAC/D,WAAW,GAAG,IAAI,CAACgB,WAAW,GAAG,IAAI,CAACvB,YAAY,CAACuE,MAAM;IAC9D,IAAI,CAAChE,WAAW,EAAE;IAClB,IAAI,IAAI,CAACA,WAAW,GAAG,CAAC,KAAK,CAAC,EAAE,IAAI,CAACA,WAAW,EAAE;IAElD,KAAK,IAAIiE,KAAK,EAAEtB,WAAW,EAAEuB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACzE,YAAY,CAACuE,MAAM,EAAE,EAAEE,CAAC,EAAE;MACrEvB,WAAW,GAAG,IAAI,CAAClD,YAAY,CAACyE,CAAC,CAAC;MAClCD,KAAK,GAAGtB,WAAW,CAAC7D,KAAK,GAAG6D,WAAW,CAAC9D,IAAI,GAAG,IAAI,CAACiB,UAAU,GAAG,IAAI,CAACqB,QAAQ;MAE9E,IAAI+C,CAAC,KAAK,IAAI,CAACnD,oBAAoB,EAAE;QACnC,IAAIkD,KAAK,KAAK,IAAI,CAACnE,UAAU,EAAEmE,KAAK,GAAG,IAAI,CAAC7C,eAAe,CAAC,KACvD,IAAI6C,KAAK,KAAK,IAAI,CAAC9C,QAAQ,EAAE8C,KAAK,GAAG,IAAI,CAAClE,aAAa;MAC9D;;MAEA;MACA,IAAI,CAACoE,QAAQ,CACX,IAAI,CAACf,cAAc,CAACT,WAAW,CAAC/D,SAAS,CAAC,EAC1C,IAAI,CAACwF,cAAc,CAACzB,WAAW,CAAC3D,GAAG,CAAC,EACpC,IAAI,CAACoE,cAAc,CAACT,WAAW,CAAC/D,SAAS,CAAC,EAC1C,IAAI,CAACwF,cAAc,CAACzB,WAAW,CAAC5D,IAAI,CAAC,EACrCkF,KAAK,CACN;;MAED;MACA,IAAI,CAACI,QAAQ,CACX,IAAI,CAACjB,cAAc,CAACT,WAAW,CAAC/D,SAAS,CAAC,GAAGsE,IAAI,CAACC,KAAK,CAAC,IAAI,CAACnD,WAAW,GAAG,CAAC,CAAC,EAC7E,IAAI,CAACoE,cAAc,CAACzB,WAAW,CAAC9D,IAAI,CAAC,EACrC,IAAI,CAACmB,WAAW,EAChB,IAAI,CAACoE,cAAc,CAACzB,WAAW,CAAC7D,KAAK,CAAC,GAAG,IAAI,CAACsF,cAAc,CAACzB,WAAW,CAAC9D,IAAI,CAAC,EAC9EoF,KAAK,CACN;IACH;;IAEA;IACA,IAAI,IAAI,CAACtD,gBAAgB,IAAIW,OAAO,EAAE;MACpC;MACAA,OAAO,CAACgD,WAAW,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;MAC3B,IAAI,CAACH,QAAQ,CAAC,CAAC,EAAE,IAAI,CAACvD,aAAa,CAACyB,CAAC,EAAE,IAAI,CAACF,KAAK,EAAE,IAAI,CAACvB,aAAa,CAACyB,CAAC,EAAE,IAAI,CAACzC,yBAAyB,CAAC;MACxG0B,OAAO,CAACgD,WAAW,CAAC,EAAE,CAAC;MACvB,IAAIC,GAAG,GAAG,IAAI,CAACC,eAAe,CAAC,IAAI,CAAC1D,WAAW,CAAC,CAAC5B,QAAQ,EAAE;MAC3D,IAAIuF,SAAS,GAAGnD,OAAO,CAACoD,WAAW,CAACH,GAAG,CAAC,CAACpC,KAAK;MAC9C,IAAI,CAACkC,QAAQ,CAAC,IAAI,CAAClC,KAAK,GAAG,EAAE,EAAE,IAAI,CAACvB,aAAa,CAACyB,CAAC,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,IAAI,CAACzC,yBAAyB,CAAC;MACjG0B,OAAO,CAACqD,SAAS,GAAG,IAAI,CAAC9E,mBAAmB;MAC5CyB,OAAO,CAACsD,QAAQ,CAACL,GAAG,EAAE,IAAI,CAACpC,KAAK,GAAGsC,SAAS,GAAG,CAAC,EAAE,IAAI,CAAC7D,aAAa,CAACyB,CAAC,GAAG,CAAC,CAAC;;MAE3E;MACAf,OAAO,CAACgD,WAAW,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;MAC3B,IAAI,CAACH,QAAQ,CAAC,IAAI,CAACvD,aAAa,CAACwB,CAAC,EAAE,CAAC,EAAE,IAAI,CAACxB,aAAa,CAACwB,CAAC,EAAE,IAAI,CAACF,MAAM,EAAE,IAAI,CAACtC,yBAAyB,CAAC;MACzG0B,OAAO,CAACgD,WAAW,CAAC,EAAE,CAAC;MACvBC,GAAG,GAAG,IAAI,CAACM,UAAU,CAAC,IAAIC,IAAI,CAAC,IAAI,CAACjE,WAAW,CAAC,CAAC,CAAC3B,QAAQ,EAAE;MAC5DuF,SAAS,GAAGnD,OAAO,CAACoD,WAAW,CAACH,GAAG,CAAC,CAACpC,KAAK;MAC1C,IAAI,CAACkC,QAAQ,CAAC,IAAI,CAACzD,aAAa,CAACwB,CAAC,GAAGqC,SAAS,GAAG,CAAC,GAAG,CAAC,EAAE,IAAI,CAACvC,MAAM,GAAG,EAAE,EAAEuC,SAAS,GAAG,EAAE,EAAE,EAAE,EAAE,IAAI,CAAC7E,yBAAyB,CAAC;MAC7H0B,OAAO,CAACqD,SAAS,GAAG,IAAI,CAAC9E,mBAAmB;MAC5CyB,OAAO,CAACsD,QAAQ,CAACL,GAAG,EAAE,IAAI,CAAC3D,aAAa,CAACwB,CAAC,GAAGqC,SAAS,GAAG,CAAC,EAAE,IAAI,CAACvC,MAAM,GAAG,CAAC,CAAC;;MAE5E;MACA,IAAI6C,IAAI,GAAG,IAAI,CAACnE,aAAa,CAACyB,CAAC,GAAG,EAAE;MACpC,IAAI0C,IAAI,GAAG,CAAC,EAAE;QACZA,IAAI,GAAG,IAAI,CAACnE,aAAa,CAACyB,CAAC,GAAG,EAAE;MAClC;MAEA,IAAI,CAACgC,QAAQ,CAAC,IAAI,CAACzD,aAAa,CAACwB,CAAC,GAAG,EAAE,EAAE2C,IAAI,EAAE,GAAG,EAAE,EAAE,EAAE,IAAI,CAACnF,yBAAyB,CAAC;MACvF,MAAMqE,KAAK,GACT,IAAI,CAACxE,YAAY,CAAC,IAAI,CAACsB,oBAAoB,CAAC,CAACjC,KAAK,GAClD,IAAI,CAACW,YAAY,CAAC,IAAI,CAACsB,oBAAoB,CAAC,CAAClC,IAAI,GAAG,IAAI,CAACiB,UAAU,GAAG,IAAI,CAACqB,QAAQ;MACrF,IAAI,CAACkD,QAAQ,CAAC,IAAI,CAACzD,aAAa,CAACwB,CAAC,GAAG,EAAE,EAAE2C,IAAI,EAAE,EAAE,EAAE,EAAE,EAAEd,KAAK,CAAC;MAC7D3C,OAAO,CAACG,SAAS,GAAG,CAAC;MACrB,IAAI,CAACuD,QAAQ,CAAC,IAAI,CAACpE,aAAa,CAACwB,CAAC,GAAG,EAAE,EAAE2C,IAAI,EAAE,GAAG,EAAE,EAAE,EAAEd,KAAK,CAAC;MAC9D3C,OAAO,CAACG,SAAS,GAAG,CAAC;MAErBH,OAAO,CAACqD,SAAS,GAAG,IAAI,CAAC9E,mBAAmB;MAC5CyB,OAAO,CAACsD,QAAQ,CACd,KAAK,GAAG,IAAI,CAACnF,YAAY,CAAC,IAAI,CAACsB,oBAAoB,CAAC,CAAClC,IAAI,EACzD,IAAI,CAAC+B,aAAa,CAACwB,CAAC,GAAG,EAAE,EACzB2C,IAAI,GAAG,EAAE,CACV;MACDzD,OAAO,CAACsD,QAAQ,CACd,KAAK,GAAG,IAAI,CAACnF,YAAY,CAAC,IAAI,CAACsB,oBAAoB,CAAC,CAACjC,KAAK,EAC1D,IAAI,CAAC8B,aAAa,CAACwB,CAAC,GAAG,EAAE,EACzB2C,IAAI,GAAG,EAAE,CACV;MACDzD,OAAO,CAACsD,QAAQ,CACd,KAAK,GAAG,IAAI,CAACnF,YAAY,CAAC,IAAI,CAACsB,oBAAoB,CAAC,CAAChC,IAAI,EACzD,IAAI,CAAC6B,aAAa,CAACwB,CAAC,GAAG,EAAE,EACzB2C,IAAI,GAAG,EAAE,CACV;MACDzD,OAAO,CAACsD,QAAQ,CACd,KAAK,GAAG,IAAI,CAACnF,YAAY,CAAC,IAAI,CAACsB,oBAAoB,CAAC,CAAC/B,GAAG,EACxD,IAAI,CAAC4B,aAAa,CAACwB,CAAC,GAAG,EAAE,EACzB2C,IAAI,GAAG,EAAE,CACV;IACH;EACF;EAEAhB,QAAQ,GAAG;IACT,MAAMzC,OAAO,GAAG,IAAI,CAACC,UAAU,CAAC,IAAI,CAA6B;;IAEjE;IACA,MAAM0D,SAAS,GAAG,IAAI,CAAC1E,MAAM,GAAG,IAAI,CAACc,UAAU;;IAE/C;IACA,IAAI6D,UAAU,GAAGhC,IAAI,CAACiC,GAAG,CAAC,EAAE,EAAEjC,IAAI,CAACkC,IAAI,CAAClC,IAAI,CAACmC,KAAK,CAACJ,SAAS,CAAC,CAAC,CAAC;IAC/D,IAAIA,SAAS,GAAG,IAAI,GAAGC,UAAU,EAAEA,UAAU,GAAG,IAAI,GAAGA,UAAU,CAAC,KAC7D,IAAID,SAAS,GAAG,GAAG,GAAGC,UAAU,EAAEA,UAAU,GAAG,GAAG,GAAGA,UAAU;;IAEpE;IACA,MAAMI,iBAAiB,GAAGpC,IAAI,CAACkC,IAAI,CAAC,IAAI,CAAC/E,MAAM,GAAG6E,UAAU,CAAC,GAAGA,UAAU;IAC1E;IACA,MAAMK,eAAe,GAAGrC,IAAI,CAACC,KAAK,CAAC,IAAI,CAAC7C,IAAI,GAAG4E,UAAU,CAAC,GAAGA,UAAU;IAEvE,KAAK,IAAIT,SAAS,EAAEpC,CAAC,GAAGiD,iBAAiB,EAAEjD,CAAC,IAAIkD,eAAe,EAAElD,CAAC,IAAI6C,UAAU,EAAE;MAChF,IAAI,CAACf,QAAQ,CAAC,CAAC,EAAE,IAAI,CAACC,cAAc,CAAC/B,CAAC,CAAC,EAAE,IAAI,CAACF,KAAK,EAAE,IAAI,CAACiC,cAAc,CAAC/B,CAAC,CAAC,EAAE,IAAI,CAAC3C,SAAS,CAAC;MAC5F+E,SAAS,GAAGnD,OAAO,CAACoD,WAAW,CAAC,IAAI,CAACF,eAAe,CAACnC,CAAC,CAAC,CAACnD,QAAQ,EAAE,CAAC,CAACiD,KAAK;MACzEb,OAAO,CAACqD,SAAS,GAAG,IAAI,CAAChF,aAAa;MACtC2B,OAAO,CAACsD,QAAQ,CAAC,IAAI,CAACJ,eAAe,CAACnC,CAAC,CAAC,CAACnD,QAAQ,EAAE,EAAE,IAAI,CAACiD,KAAK,GAAGsC,SAAS,GAAG,CAAC,EAAE,IAAI,CAACL,cAAc,CAAC/B,CAAC,CAAC,GAAG,CAAC,CAAC;IAC9G;;IAEA;IACA,MAAMmD,SAAS,GAAG,IAAI,CAACtE,MAAM,GAAG,IAAI,CAACR,UAAU;;IAE/C;IACAwE,UAAU,GAAGhC,IAAI,CAACiC,GAAG,CAAC,EAAE,EAAEjC,IAAI,CAACkC,IAAI,CAAClC,IAAI,CAACmC,KAAK,CAACG,SAAS,CAAC,CAAC,CAAC;IAC3D,IAAIA,SAAS,GAAG,IAAI,GAAGN,UAAU,EAAE;MACjCA,UAAU,GAAG,IAAI,GAAGA,UAAU;IAChC,CAAC,MAAM,IAAIM,SAAS,GAAG,GAAG,GAAGN,UAAU,EAAE;MACvCA,UAAU,GAAG,GAAG,GAAGA,UAAU;IAC/B;;IAEA;IACA,MAAMO,iBAAiB,GAAGvC,IAAI,CAACkC,IAAI,CAAC,IAAI,CAACnE,MAAM,GAAGiE,UAAU,CAAC,GAAGA,UAAU;IAC1E;IACA,MAAMQ,eAAe,GAAGxC,IAAI,CAACC,KAAK,CAAC,IAAI,CAAC1C,IAAI,GAAGyE,UAAU,CAAC,GAAGA,UAAU;;IAEvE;IACA,IAAIS,YAAY,GAAI,IAAI,CAACzE,MAAM,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI,GAAG,CAAE;IAE1D,KAAK,IAAI0E,GAAG,EAAEC,KAAK,EAAEC,OAAO,EAAEC,IAAI,EAAEC,OAAO,EAAE5D,CAAC,GAAGqD,iBAAiB,EAAErD,CAAC,IAAIsD,eAAe,EAAEtD,CAAC,IAAI8C,UAAU,EAAE;MACzG,IAAI,CAACf,QAAQ,CAAC,IAAI,CAACf,cAAc,CAAChB,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,CAACgB,cAAc,CAAChB,CAAC,CAAC,EAAE,IAAI,CAACF,MAAM,EAAE,IAAI,CAACxC,SAAS,CAAC;MAC7FqG,IAAI,GAAG,IAAIjB,IAAI,CAAC1C,CAAC,CAAC;MAClB4D,OAAO,GAAG,EAAE;MACZ,IAAIL,YAAY,EAAE;QAChBC,GAAG,GAAGG,IAAI,CAACE,OAAO,EAAE;QACpB;QACAJ,KAAK,GAAGE,IAAI,CAACG,QAAQ,EAAE,GAAG,CAAC;QAC3B;QACAF,OAAO,GAAI,GAAGJ,GAAG,GAAG,EAAE,GAAI,GAAG,GAAGA,GAAG,GAAGA,GAAI,IAAIC,KAAK,GAAG,EAAE,GAAI,GAAG,GAAGA,KAAK,GAAGA,KAAM,EAAC;MACnF,CAAC,MAAM;QACLC,OAAO,GAAGC,IAAI,CAACI,UAAU,EAAE;QAC3B,IAAIL,OAAO,GAAG,EAAE,EAAE;UAChBA,OAAO,GAAG,GAAG,GAAGA,OAAO;QACzB;QACAE,OAAO,GAAGD,IAAI,CAACK,QAAQ,EAAE,GAAG,GAAG,GAAGN,OAAO;MAC3C;MACAxE,OAAO,CAACqD,SAAS,GAAG,IAAI,CAAChF,aAAa;MACtC2B,OAAO,CAACsD,QAAQ,CAACoB,OAAO,EAAE,IAAI,CAAC5C,cAAc,CAAChB,CAAC,CAAC,GAAG,CAAC,EAAE,IAAI,CAACF,MAAM,GAAG,CAAC,CAAC;IACxE;EACF;EAEA2B,eAAe,GAAG;IAChB,KAAK,IAAIK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACzE,YAAY,CAACuE,MAAM,EAAE,EAAEE,CAAC,EAAE;MACjD,IAAIA,CAAC,KAAK,CAAC,EAAE;QACX,IAAI,CAAC7D,MAAM,GAAG,IAAI,CAACZ,YAAY,CAACyE,CAAC,CAAC,CAAClF,GAAG;QACtC,IAAI,CAACsB,IAAI,GAAG,IAAI,CAACb,YAAY,CAACyE,CAAC,CAAC,CAACnF,IAAI;MACvC,CAAC,MAAM;QACL,IAAI,IAAI,CAACU,YAAY,CAACyE,CAAC,CAAC,CAAClF,GAAG,GAAG,IAAI,CAACqB,MAAM,EAAE;UAC1C,IAAI,CAACA,MAAM,GAAG,IAAI,CAACZ,YAAY,CAACyE,CAAC,CAAC,CAAClF,GAAG;QACxC;QACA,IAAI,IAAI,CAACS,YAAY,CAACyE,CAAC,CAAC,CAACnF,IAAI,GAAG,IAAI,CAACuB,IAAI,EAAE;UACzC,IAAI,CAACA,IAAI,GAAG,IAAI,CAACb,YAAY,CAACyE,CAAC,CAAC,CAACnF,IAAI;QACvC;MACF;IACF;IACA,IAAI,CAACwB,MAAM,GAAG,IAAI,CAACD,IAAI,GAAG,IAAI,CAACD,MAAM;EACvC;EAEAyD,eAAe,GAAG;IAChB,IAAI,CAAC7C,MAAM,GAAG,IAAI,CAACxB,YAAY,CAAC,CAAC,CAAC,CAACb,SAAS;IAC5C,IAAI,CAAC6B,IAAI,GAAG,IAAI,CAAChB,YAAY,CAAC,IAAI,CAACA,YAAY,CAACuE,MAAM,GAAG,CAAC,CAAC,CAACpF,SAAS;IACrE,IAAI,CAACsC,MAAM,GAAG,IAAI,CAACT,IAAI,GAAG,IAAI,CAACQ,MAAM;EACvC;EAEAmD,cAAc,CAAC/B,CAAS,EAAE;IACxB,OAAQ,IAAI,CAACH,MAAM,GAAG,IAAI,CAAC9B,YAAY,GAAI,CAACiC,CAAC,GAAG,IAAI,CAAChC,MAAM,IAAI,IAAI,CAACG,WAAW,GAAI,IAAI,CAACD,MAAM;EAChG;EAEA6C,cAAc,CAAChB,CAAS,EAAE;IACxB,OAAO,IAAI,CAACnC,UAAU,GAAI,CAACmC,CAAC,GAAG,IAAI,CAACnB,MAAM,IAAI,IAAI,CAACD,WAAW,GAAI,IAAI,CAACE,MAAM;EAC/E;EAEA6B,cAAc,CAACV,CAAS,EAAE;IACxB,OAAQ,IAAI,CAAChC,MAAM,GAAI,CAAC,IAAI,CAAC6B,MAAM,GAAG,IAAI,CAAC9B,YAAY,GAAGiC,CAAC,IAAI,IAAI,CAAC9B,MAAM,GAAI,IAAI,CAACC,WAAW;EAChG;EAEAwC,cAAc,CAACZ,CAAS,EAAE;IACxB,OAAO,IAAI,CAACnB,MAAM,GAAI,CAACmB,CAAC,GAAG,IAAI,CAACnC,UAAU,IAAI,IAAI,CAACiB,MAAM,GAAI,IAAI,CAACF,WAAW;EAC/E;EAEAmD,QAAQ,CAAElD,MAAc,EAAEZ,MAAc,EAAEI,IAAY,EAAEH,IAAY,EAAE2D,KAA8C,EAAE;IACpH,MAAM3C,OAAO,GAAG,IAAI,CAACC,UAAU,CAAC,IAAI,CAA6B;IACjED,OAAO,CAAC+E,SAAS,EAAE;IACnB;IACA/E,OAAO,CAACgF,MAAM,CAACrF,MAAM,GAAG,GAAG,EAAEZ,MAAM,GAAG,GAAG,CAAC;IAC1CiB,OAAO,CAACiF,MAAM,CAAC9F,IAAI,GAAG,GAAG,EAAEH,IAAI,GAAG,GAAG,CAAC;IACtCgB,OAAO,CAACkF,WAAW,GAAGvC,KAAK;IAC3B3C,OAAO,CAACmF,MAAM,EAAE;EAClB;EAEApC,QAAQ,CAACjC,CAAS,EAAEC,CAAS,EAAEF,KAAa,EAAED,MAAc,EAAE+B,KAA8C,EAAE;IAC5G,MAAM3C,OAAO,GAAG,IAAI,CAACC,UAAU,CAAC,IAAI,CAA6B;IACjED,OAAO,CAAC+E,SAAS,EAAE;IACnB/E,OAAO,CAACqD,SAAS,GAAGV,KAAK;IACzB3C,OAAO,CAACgC,IAAI,CAAClB,CAAC,EAAEC,CAAC,EAAEF,KAAK,EAAED,MAAM,CAAC;IACjCZ,OAAO,CAACoF,IAAI,EAAE;EAChB;EAEA1B,QAAQ,CAAC5C,CAAS,EAAEC,CAAS,EAAEF,KAAa,EAAED,MAAc,EAAE+B,KAA8C,EAAE;IAC5G,MAAM3C,OAAO,GAAG,IAAI,CAACC,UAAU,CAAC,IAAI,CAA6B;IACjED,OAAO,CAAC+E,SAAS,EAAE;IACnB/E,OAAO,CAACkF,WAAW,GAAGvC,KAAK;IAC3B3C,OAAO,CAACgC,IAAI,CAAClB,CAAC,EAAEC,CAAC,EAAEF,KAAK,EAAED,MAAM,CAAC;IACjCZ,OAAO,CAACmF,MAAM,EAAE;EAClB;EAEA5B,UAAU,CAACkB,IAAU,EAAE;IACrB,MAAMH,GAAG,GAAGG,IAAI,CAACE,OAAO,EAAE;IAC1B,MAAMJ,KAAK,GAAGE,IAAI,CAACG,QAAQ,EAAE,GAAG,CAAC;IACjC,MAAMS,KAAK,GAAGZ,IAAI,CAACK,QAAQ,EAAE;IAC7B,MAAMN,OAAO,GAAGC,IAAI,CAACI,UAAU,EAAE;IACjC,MAAMS,IAAI,GAAGb,IAAI,CAACc,WAAW,EAAE;IAE/B,OAAQ,GAAGjB,GAAG,GAAG,EAAE,GAAI,GAAG,GAAGA,GAAG,GAAGA,GAAI,IAAIC,KAAK,GAAG,EAAE,GAAI,GAAG,GAAGA,KAAK,GAAGA,KAAM,IAAGe,IAAK,MAAMD,KAAK,GAAG,EAAE,GAAI,GAAG,GAAGA,KAAK,GAAGA,KAAM,IAAIb,OAAO,GAAG,EAAE,GAAI,GAAG,GAAGA,OAAO,GAAGA,OAAQ,EAAC;EAC5K;EAEAtB,eAAe,CAACsC,KAAa,EAAE;IAC7B,IAAIA,KAAK,GAAG,GAAG,EAAE,OAAO5D,IAAI,CAAC6D,KAAK,CAACD,KAAK,GAAG,GAAG,CAAC,GAAG,GAAG;IACrD,IAAIA,KAAK,GAAG,KAAK,EAAE,OAAO5D,IAAI,CAAC6D,KAAK,CAACD,KAAK,GAAG,IAAI,CAAC,GAAG,IAAI;IACzD,IAAIA,KAAK,GAAG,OAAO,EAAE,OAAO5D,IAAI,CAAC6D,KAAK,CAACD,KAAK,GAAG,MAAM,CAAC,GAAG,MAAM;IAC/D,IAAIA,KAAK,GAAG,SAAS,EAAE,OAAO5D,IAAI,CAAC6D,KAAK,CAACD,KAAK,GAAG,QAAQ,CAAC,GAAG,QAAQ,CAAC,KACjE,OAAO5D,IAAI,CAAC6D,KAAK,CAACD,KAAK,GAAG,UAAU,CAAC,GAAG,UAAU;EACzD;AACF;AACA;AACA,eAAexH,gBAAgB;AAC/B0H,MAAM,CAACC,cAAc,CAACC,MAAM,CAAC,oBAAoB,EAAE5H,gBAAgB,EAAE;EAAE6H,OAAO,EAAE;AAAS,CAAC,CAAC;;AAE3F;AACA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}