{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\nexports.default = financeDiscontinuousScale;\nvar _d3Collection = require(\"d3-collection\");\nvar _d3Array = require(\"d3-array\");\nvar _d3Scale = require(\"d3-scale\");\nvar _utils = require(\"../utils\");\nvar _levels = require(\"./levels\");\nvar MAX_LEVEL = _levels.levelDefinition.length - 1;\nfunction financeDiscontinuousScale(index, futureProvider) {\n  var backingLinearScale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : (0, _d3Scale.scaleLinear)();\n  if ((0, _utils.isNotDefined)(index)) throw new Error(\"Use the discontinuousTimeScaleProvider to create financeDiscontinuousScale\");\n  function scale(x) {\n    return backingLinearScale(x);\n  }\n  scale.invert = function (x) {\n    var inverted = backingLinearScale.invert(x);\n    return Math.round(inverted * 10000) / 10000;\n  };\n  scale.domain = function (x) {\n    if (!arguments.length) return backingLinearScale.domain();\n    backingLinearScale.domain(x);\n    return scale;\n  };\n  scale.range = function (x) {\n    if (!arguments.length) return backingLinearScale.range();\n    backingLinearScale.range(x);\n    return scale;\n  };\n  scale.rangeRound = function (x) {\n    return backingLinearScale.range(x);\n  };\n  scale.clamp = function (x) {\n    if (!arguments.length) return backingLinearScale.clamp();\n    backingLinearScale.clamp(x);\n    return scale;\n  };\n  scale.interpolate = function (x) {\n    if (!arguments.length) return backingLinearScale.interpolate();\n    backingLinearScale.interpolate(x);\n    return scale;\n  };\n  scale.ticks = function (m, flexTicks) {\n    var backingTicks = backingLinearScale.ticks(m);\n    var ticksMap = (0, _d3Collection.map)();\n    var _backingLinearScale$d = backingLinearScale.domain(),\n      _backingLinearScale$d2 = _slicedToArray(_backingLinearScale$d, 2),\n      domainStart = _backingLinearScale$d2[0],\n      domainEnd = _backingLinearScale$d2[1];\n    var start = Math.max(Math.ceil(domainStart), (0, _utils.head)(index).index) + Math.abs((0, _utils.head)(index).index);\n    var end = Math.min(Math.floor(domainEnd), (0, _utils.last)(index).index) + Math.abs((0, _utils.head)(index).index);\n    if (Math.floor(domainEnd) > end) {\n      // console.log(end, domainEnd, index);\n    }\n    var desiredTickCount = Math.ceil((end - start) / (domainEnd - domainStart) * backingTicks.length);\n    for (var i = MAX_LEVEL; i >= 0; i--) {\n      var ticksAtLevel = ticksMap.get(i);\n      var temp = (0, _utils.isNotDefined)(ticksAtLevel) ? [] : ticksAtLevel.slice();\n      for (var j = start; j <= end; j++) {\n        if (index[j].level === i) {\n          temp.push(index[j]);\n        }\n      }\n      ticksMap.set(i, temp);\n    }\n    var unsortedTicks = [];\n    for (var _i = MAX_LEVEL; _i >= 0; _i--) {\n      if (ticksMap.get(_i).length + unsortedTicks.length > desiredTickCount * 1.5) break;\n      unsortedTicks = unsortedTicks.concat(ticksMap.get(_i).map(function (d) {\n        return d.index;\n      }));\n    }\n    var ticks = unsortedTicks.sort(_d3Array.ascending);\n\n    // console.log(backingTicks.length, desiredTickCount, ticks, ticksMap);\n\n    if (!flexTicks && end - start > ticks.length) {\n      var ticksSet = (0, _d3Collection.set)(ticks);\n      var d = Math.abs((0, _utils.head)(index).index);\n\n      // ignore ticks within this distance\n      var distance = Math.ceil((backingTicks.length > 0 ? ((0, _utils.last)(backingTicks) - (0, _utils.head)(backingTicks)) / backingTicks.length / 4 : 1) * 1.5);\n      for (var _i2 = 0; _i2 < ticks.length - 1; _i2++) {\n        for (var _j = _i2 + 1; _j < ticks.length; _j++) {\n          if (ticks[_j] - ticks[_i2] <= distance) {\n            ticksSet.remove(index[ticks[_i2] + d].level >= index[ticks[_j] + d].level ? ticks[_j] : ticks[_i2]);\n          }\n        }\n      }\n      var tickValues = ticksSet.values().map(function (d) {\n        return parseInt(d, 10);\n      });\n\n      // console.log(ticks.length, tickValues, level);\n      // console.log(ticks, tickValues, distance);\n\n      return tickValues;\n    }\n    return ticks;\n  };\n  scale.tickFormat = function () {\n    return function (x) {\n      var d = Math.abs((0, _utils.head)(index).index);\n      var _index$Math$floor = index[Math.floor(x + d)],\n        format = _index$Math$floor.format,\n        date = _index$Math$floor.date;\n      return format(date);\n    };\n  };\n  scale.value = function (x) {\n    var d = Math.abs((0, _utils.head)(index).index);\n    if ((0, _utils.isDefined)(index[Math.floor(x + d)])) {\n      var date = index[Math.floor(x + d)].date;\n      return date;\n    }\n  };\n  scale.nice = function (m) {\n    backingLinearScale.nice(m);\n    return scale;\n  };\n  scale.index = function (x) {\n    if (!arguments.length) return index;\n    index = x;\n    return scale;\n  };\n  scale.copy = function () {\n    return financeDiscontinuousScale(index, futureProvider, backingLinearScale.copy());\n  };\n  return scale;\n}","map":{"version":3,"mappings":"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","names":["financeDiscontinuousScale","MAX_LEVEL","_levels","length","index","futureProvider","backingLinearScale","Error","scale","x","invert","inverted","Math","round","domain","arguments","range","rangeRound","clamp","interpolate","ticks","m","flexTicks","backingTicks","ticksMap","_backingLinearScale$d2","domainStart","domainEnd","start","max","ceil","abs","end","min","floor","desiredTickCount","i","ticksAtLevel","get","temp","slice","j","level","push","set","unsortedTicks","concat","map","d","sort","ticksSet","distance","remove","tickValues","values","parseInt","tickFormat","format","date","value","nice","copy"],"sources":["C:\\Users\\Lucian\\Documents\\DEV\\nodejs\\stock-market-api\\dev\\static\\node_modules\\src\\lib\\scale\\financeDiscontinuousScale.js"],"sourcesContent":["\n\nimport { set, map } from \"d3-collection\";\nimport { ascending } from \"d3-array\";\nimport { scaleLinear } from \"d3-scale\";\n\nimport { isDefined, isNotDefined, head, last } from \"../utils\";\nimport { levelDefinition } from \"./levels\";\n\nconst MAX_LEVEL = levelDefinition.length - 1;\n\nexport default function financeDiscontinuousScale(\n\tindex,\n\tfutureProvider,\n\tbackingLinearScale = scaleLinear()\n) {\n\n\tif (isNotDefined(index))\n\t\tthrow new Error(\"Use the discontinuousTimeScaleProvider to create financeDiscontinuousScale\");\n\n\tfunction scale(x) {\n\t\treturn backingLinearScale(x);\n\t}\n\tscale.invert = function(x) {\n\t\tconst inverted = backingLinearScale.invert(x);\n\t\treturn Math.round(inverted * 10000) / 10000;\n\t};\n\tscale.domain = function(x) {\n\t\tif (!arguments.length) return backingLinearScale.domain();\n\t\tbackingLinearScale.domain(x);\n\t\treturn scale;\n\t};\n\tscale.range = function(x) {\n\t\tif (!arguments.length) return backingLinearScale.range();\n\t\tbackingLinearScale.range(x);\n\t\treturn scale;\n\t};\n\tscale.rangeRound = function(x) {\n\t\treturn backingLinearScale.range(x);\n\t};\n\tscale.clamp = function(x) {\n\t\tif (!arguments.length) return backingLinearScale.clamp();\n\t\tbackingLinearScale.clamp(x);\n\t\treturn scale;\n\t};\n\tscale.interpolate = function(x) {\n\t\tif (!arguments.length) return backingLinearScale.interpolate();\n\t\tbackingLinearScale.interpolate(x);\n\t\treturn scale;\n\t};\n\tscale.ticks = function(m, flexTicks) {\n\t\tconst backingTicks = backingLinearScale.ticks(m);\n\t\tconst ticksMap = map();\n\n\t\tconst [domainStart, domainEnd] = backingLinearScale.domain();\n\n\t\tconst start = Math.max(Math.ceil(domainStart), head(index).index) + Math.abs(head(index).index);\n\t\tconst end = Math.min(Math.floor(domainEnd), last(index).index) + Math.abs(head(index).index);\n\n\t\tif (Math.floor(domainEnd) > end) {\n\t\t\t// console.log(end, domainEnd, index);\n\t\t}\n\n\t\tconst desiredTickCount = Math.ceil((end - start) / (domainEnd - domainStart) * backingTicks.length);\n\n\t\tfor (let i = MAX_LEVEL; i >= 0; i--) {\n\t\t\tconst ticksAtLevel = ticksMap.get(i);\n\t\t\tconst temp = isNotDefined(ticksAtLevel)\n\t\t\t\t? []\n\t\t\t\t: ticksAtLevel.slice();\n\n\t\t\tfor (let j = start; j <= end; j++) {\n\t\t\t\tif (index[j].level === i) {\n\t\t\t\t\ttemp.push(index[j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tticksMap.set(i, temp);\n\t\t}\n\n\t\tlet unsortedTicks = [];\n\t\tfor (let i = MAX_LEVEL; i >= 0; i--) {\n\t\t\tif ((ticksMap.get(i).length + unsortedTicks.length) > desiredTickCount * 1.5) break;\n\t\t\tunsortedTicks = unsortedTicks.concat(ticksMap.get(i).map(d => d.index));\n\t\t}\n\n\t\tconst ticks = unsortedTicks.sort(ascending);\n\n\t\t// console.log(backingTicks.length, desiredTickCount, ticks, ticksMap);\n\n\t\tif (!flexTicks && end - start > ticks.length) {\n\t\t\tconst ticksSet = set(ticks);\n\n\t\t\tconst d = Math.abs(head(index).index);\n\n\t\t\t// ignore ticks within this distance\n\t\t\tconst distance = Math.ceil(\n\t\t\t\t(backingTicks.length > 0\n\t\t\t\t\t? (last(backingTicks) - head(backingTicks)) / (backingTicks.length) / 4\n\t\t\t\t\t: 1) * 1.5);\n\n\t\t\tfor (let i = 0; i < ticks.length - 1; i++) {\n\t\t\t\tfor (let j = i + 1; j < ticks.length; j++) {\n\t\t\t\t\tif (ticks[j] - ticks[i] <= distance) {\n\t\t\t\t\t\tticksSet.remove(index[ticks[i] + d].level >= index[ticks[j] + d].level ? ticks[j] : ticks[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst tickValues = ticksSet.values().map(d => parseInt(d, 10));\n\n\t\t\t// console.log(ticks.length, tickValues, level);\n\t\t\t// console.log(ticks, tickValues, distance);\n\n\t\t\treturn tickValues;\n\t\t}\n\n\t\treturn ticks;\n\t};\n\tscale.tickFormat = function() {\n\t\treturn function(x) {\n\t\t\tconst d = Math.abs(head(index).index);\n\t\t\tconst { format, date } = index[Math.floor(x + d)];\n\t\t\treturn format(date);\n\t\t};\n\t};\n\tscale.value = function(x) {\n\t\tconst d = Math.abs(head(index).index);\n\t\tif (isDefined(index[Math.floor(x + d)])) {\n\t\t\tconst { date } = index[Math.floor(x + d)];\n\t\t\treturn date;\n\t\t}\n\t};\n\tscale.nice = function(m) {\n\t\tbackingLinearScale.nice(m);\n\t\treturn scale;\n\t};\n\tscale.index = function(x) {\n\t\tif (!arguments.length) return index;\n\t\tindex = x;\n\t\treturn scale;\n\t};\n\tscale.copy = function() {\n\t\treturn financeDiscontinuousScale(index, futureProvider, backingLinearScale.copy());\n\t};\n\treturn scale;\n}"]},"metadata":{},"sourceType":"script","externalDependencies":[]}