{"ast":null,"code":"/**\r\n * Handles formatting of pseudo-markup in text.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\nimport { BaseObject } from \"../Base\";\nimport { AMElement } from \"../rendering/AMElement\";\nimport { Adapter } from \"../utils/Adapter\";\nimport { registry } from \"../Registry\";\nimport * as $strings from \"../utils/Strings\";\nimport * as $type from \"../utils/Type\";\n/**\r\n * Handles formatting of pseudo-markdown in text.\r\n *\r\n * @todo Encode < > in output\r\n * @todo Add more adapters\r\n * @important\r\n */\nvar TextFormatter = /** @class */function (_super) {\n  __extends(TextFormatter, _super);\n  /**\r\n   * Constructor\r\n   */\n  function TextFormatter() {\n    var _this = _super.call(this) || this;\n    /**\r\n     * Adapter.\r\n     */\n    _this.adapter = new Adapter(_this);\n    _this.className = \"TextFormatter\";\n    _this.applyTheme();\n    return _this;\n  }\n  TextFormatter.prototype.debug = function () {};\n  /**\r\n   * Formats the text according to specifications passed in.\r\n   *\r\n   * @param text    Text to format\r\n   * @param output  Output format (svg, html)\r\n   * @return Formatted text\r\n   */\n  TextFormatter.prototype.format = function (text, output) {\n    // Apply default\n    if (!$type.hasValue(output)) {\n      output = \"svg\";\n    }\n    // Init return value\n    var formatted = \"\";\n    // Replace double (escaped) square spaces with remporary codes\n    text = this.escape(text);\n    // Divvy up the string by style tags\n    var styles = text.match(/\\[([^\\]]*?)\\]/gm);\n    if (!styles) {\n      // Nothing to do here - no formatting elements\n      return this.wrap(text, \"\", output);\n    }\n    // Get pure text - no style tags\n    var texts = text.split(/\\[[^\\[\\]]*\\]/);\n    // Go through each of the texts and wrap it in style tags\n    for (var i = 0, len = texts.length; i < len; i++) {\n      // Get text bit\n      var t = texts[i];\n      // Check if string is empty\n      if (t === \"\") {\n        continue;\n      }\n      // Run through an adapter\n      t = this.adapter.apply(\"chunk\", t);\n      // Get related style\n      var s = \"\";\n      if (i > 0) {\n        s = styles[i - 1].replace('[', '').replace(']', '');\n      }\n      // Wrap text in tag\n      formatted += this.wrap(t, s, output);\n    }\n    // Replace placeholders back\n    formatted = this.unescape(formatted);\n    // Return result\n    return this.cleanUp(formatted);\n  };\n  /**\r\n   * Replaces brackets with temporary placeholders.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Input text\r\n   * @return Escaped text\r\n   */\n  TextFormatter.prototype.escape = function (text) {\n    return text.replace(/\\[\\[/g, registry.getPlaceholder(\"1\")).replace(/([^\\/\\]]{1})\\]\\]/g, \"$1\" + registry.getPlaceholder(\"2\")).replace(/\\]\\]/g, registry.getPlaceholder(\"2\")).replace(/\\{\\{/g, registry.getPlaceholder(\"3\")).replace(/\\}\\}/g, registry.getPlaceholder(\"4\")).replace(/\\'\\'/g, registry.getPlaceholder(\"5\"));\n  };\n  /**\r\n   * Replaces placeholders back to brackets.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Escaped text\r\n   * @return Unescaped text\r\n   */\n  TextFormatter.prototype.unescape = function (text) {\n    return text.replace(new RegExp(registry.getPlaceholder(\"1\"), \"g\"), \"[[\").replace(new RegExp(registry.getPlaceholder(\"2\"), \"g\"), \"]]\").replace(new RegExp(registry.getPlaceholder(\"3\"), \"g\"), \"{{\").replace(new RegExp(registry.getPlaceholder(\"4\"), \"g\"), \"}}\").replace(new RegExp(registry.getPlaceholder(\"5\"), \"g\"), \"''\");\n  };\n  /**\r\n   * Cleans up the text text for leftover double square brackets.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Input text\r\n   * @return Cleaned up text\r\n   */\n  TextFormatter.prototype.cleanUp = function (text) {\n    return text.replace(/\\[\\[/g, \"[\").replace(/\\]\\]/g, \"]\").replace(/\\{\\{/g, \"{\").replace(/\\}\\}/g, \"}\").replace(/\\'\\'/g, \"'\");\n  };\n  /**\r\n   * Wraps text into corresponding tags.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text   Text to wrap\r\n   * @param style  Styles\r\n   * @param output  Format to output in (svg, html)\r\n   * @return Formatted string\r\n   */\n  TextFormatter.prototype.wrap = function (text, style, output) {\n    if (style === \"\" || style === \"/\") {\n      //return text;\n      style = \"\";\n    }\n    switch (output) {\n      case \"html\":\n        return this.wrapHtml(text, this.translateStyleShortcuts(style));\n      default:\n        return this.wrapSvg(text, this.translateStyleShortcuts(style));\n    }\n  };\n  /**\r\n   * Wraps text in styled SVG tag.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text   Text to wrap\r\n   * @param style  Style property\r\n   * @return Formatted tag\r\n   */\n  TextFormatter.prototype.wrapSvg = function (text, style) {\n    if (style === \"\") {\n      return \"<tspan>\" + text + \"</tspan>\";\n    } else {\n      return \"<tspan style='\" + style + \"'>\" + text + \"</tspan>\";\n    }\n  };\n  /**\r\n   * Returns an SVG `<tspan>` element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text   Text\r\n   * @param style  Style\r\n   * @return Element\r\n   */\n  TextFormatter.prototype.getSvgElement = function (text, style) {\n    var element = new AMElement(\"tspan\");\n    element.textContent = text;\n    if (style) {\n      element.node.setAttribute(\"style\", style);\n    }\n    return element;\n  };\n  /**\r\n   * Wraps text in HTML <span> tag.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text   Text to wrap\r\n   * @param style  Style property\r\n   * @return Formatted tag\r\n   * @todo Translate SVG styles into HTML ones\r\n   */\n  TextFormatter.prototype.wrapHtml = function (text, style) {\n    if (style === \"\") {\n      return \"<span>\" + text + \"</span>\";\n    } else {\n      return \"<span style='\" + this.styleSvgToHtml(style) + \"'>\" + text + \"</span>\";\n    }\n  };\n  /**\r\n   * Returns an HTML `<span>` element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text   Text/HTML\r\n   * @param style  Style definition\r\n   * @return HTML element\r\n   */\n  TextFormatter.prototype.getHtmlElement = function (text, style) {\n    var element = document.createElement(\"span\");\n    element.innerHTML = text;\n    if (style) {\n      element.setAttribute(\"style\", style);\n    }\n    return element;\n  };\n  /**\r\n   * Trabslates SVG CSS into HTML CSS.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param style  SVG CSS\r\n   * @return HTML CSS\r\n   * @todo Implement actual translation\r\n   */\n  TextFormatter.prototype.styleSvgToHtml = function (style) {\n    style = style.replace(/fill:/, \"color:\");\n    return style;\n  };\n  /**\r\n   * Translates style shortcuts into full styles, i.e.:\r\n   * \"bold\" => \"font-weight: bold\"\r\n   * \"#f00\" => \"fill: #f00\"\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param style  Untranslated style\r\n   * @return Translated style\r\n   * @todo Implement actual translation\r\n   */\n  TextFormatter.prototype.translateStyleShortcuts = function (style) {\n    if (style == \"\" || style == \"[ ]\") {\n      return \"\";\n    }\n    var cached = registry.getCache(\"translateStyleShortcuts_\" + style);\n    if (cached) {\n      return cached;\n    }\n    // Pre-process quoted text\n    var q = style.match(/('[^']*')|(\"[^\"]*\")/gi);\n    if (q) {\n      for (var i = 0; i < q.length; i++) {\n        style = style.replace(q[i], q[i].replace(/['\"]*/g, \"\").replace(/[ ]+/g, \"+\"));\n      }\n    }\n    // Get style parts\n    var b = style.match(/([\\w\\-]*:[\\s]?[^;\\s\\]]*)|(\\#[\\w]{1,6})|([\\w]+)|(\\/)/gi);\n    // Empty?\n    if (!b) {\n      return style;\n    }\n    // Check each part\n    for (var i = 0; i < b.length; i++) {\n      if (b[i].match(/^bold$/i)) {\n        // Bold\n        b[i] = \"font-weight:\" + b[i];\n      } else if (b[i] == \"/\") {\n        // Just closing tag\n        // Do nothing\n        b[i] = \"\";\n      } else if (!b[i].match(/:/)) {\n        // Color\n        b[i] = \"fill:\" + b[i];\n      } else {\n        b[i] = b[i].replace(/\\+/g, \" \");\n      }\n    }\n    var res = b.join(';');\n    registry.setCache(\"translateStyleShortcuts_\" + style, res);\n    return res;\n  };\n  /**\r\n   * Splits string into chunks. (style blocks, quoted blocks, regular blocks)\r\n   *\r\n   * If the second parameter `quotedBlocks` is set to `true` this method will\r\n   * also single out text blocks enclosed within single quotes that no\r\n   * formatting should be applied to, and they should be displayed as is.\r\n   *\r\n   * Default for the above is `false`, so that you can use single quote in text\r\n   * without escaping it.\r\n   *\r\n   * If enabled, single quotes can be escaped by doubling it - adding two\r\n   * single quotes, which will be replaced by a one single quote in the final\r\n   * output.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text          Text to chunk\r\n   * @param quotedBlocks  Use quoted blocks\r\n   * @param noFormatting  Formatting blocks will be treated as regular text\r\n   * @return Array of string chunks\r\n   */\n  TextFormatter.prototype.chunk = function (text, quotedBlocks, noFormatting) {\n    if (quotedBlocks === void 0) {\n      quotedBlocks = false;\n    }\n    if (noFormatting === void 0) {\n      noFormatting = false;\n    }\n    // Init result\n    var res = [];\n    // Replace double (escaped) square spaces and quotes with temporary codes\n    text = this.escape(text);\n    // Deal with style blocks\n    var chunks = quotedBlocks ? text.split(\"'\") : [text];\n    for (var i = 0; i < chunks.length; i++) {\n      var chunk = chunks[i];\n      // Empty?\n      if (chunk === \"\") {\n        continue;\n      }\n      if (i % 2 === 0) {\n        // Text outside quotes\n        // Parse for style blocks which are \"text\" chunks, the rest chunks are\n        // \"value\"\n        chunk = chunk.replace(/\\]\\[/g, \"]\" + $strings.PLACEHOLDER + \"[\");\n        chunk = chunk.replace(/\\[\\]/g, \"[ ]\");\n        var chunks2 = chunk.split(/[\\[\\]]+/);\n        for (var i2 = 0; i2 < chunks2.length; i2++) {\n          var chunk2 = this.cleanUp(this.unescape(chunks2[i2]));\n          // Placeholder?\n          if (chunk2 === $strings.PLACEHOLDER) {\n            continue;\n          }\n          // Empty?\n          if (chunk2 === \"\") {\n            continue;\n          }\n          // Block or value\n          if (i2 % 2 === 0) {\n            res.push({\n              \"type\": \"value\",\n              \"text\": this.adapter.apply(\"chunk\", chunk2)\n            });\n          } else {\n            res.push({\n              \"type\": noFormatting ? \"value\" : \"format\",\n              \"text\": \"[\" + chunk2 + \"]\"\n            });\n          }\n        }\n      } else {\n        // A text within doublequotes\n        // All chunks are \"text\"\n        var chunks2 = chunk.split(/[\\[\\]]+/);\n        for (var i2 = 0; i2 < chunks2.length; i2++) {\n          var chunk2 = this.cleanUp(this.unescape(chunks2[i2]));\n          // Empty?\n          if (chunk2 === \"\") {\n            continue;\n          }\n          // Block or text\n          if (i2 % 2 === 0) {\n            res.push({\n              \"type\": \"text\",\n              \"text\": chunk2\n            });\n          } else if (this.isImage(chunk2)) {\n            res.push({\n              \"type\": \"image\",\n              \"text\": \"[\" + chunk2 + \"]\"\n            });\n          } else {\n            res.push({\n              \"type\": \"format\",\n              \"text\": \"[\" + chunk2 + \"]\"\n            });\n          }\n        }\n      }\n    }\n    return res;\n  };\n  /**\r\n   * Checks if supplied format contains image information and should be\r\n   * formatted as such.\r\n   * I.e.: `[img: myImage.png]`\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Format\r\n   * @return `true` if it is an image\r\n   */\n  TextFormatter.prototype.isImage = function (text) {\n    return text.match(/img[ ]?:/) ? true : false;\n  };\n  return TextFormatter;\n}(BaseObject);\nexport { TextFormatter };\nvar formatter;\n/**\r\n * Returns the global instance of [[TextFormatter]].\r\n *\r\n * All classes and instances should reuse this universal text formatter,\r\n * rather than create their own instance of it.\r\n */\nexport function getTextFormatter() {\n  if (formatter == null) {\n    formatter = new TextFormatter();\n  }\n  return formatter;\n}\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\nregistry.registeredClasses[\"TextFormatter\"] = TextFormatter;","map":{"version":3,"mappings":"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","names":["BaseObject","AMElement","Adapter","registry","$strings","$type","__extends","_super","_this","className","applyTheme","TextFormatter","text","output","hasValue","formatted","escape","styles","match","wrap","texts","split","i","len","length","t","adapter","apply","s","replace","unescape","cleanUp","getPlaceholder","RegExp","style","wrapHtml","translateStyleShortcuts","wrapSvg","element","textContent","node","setAttribute","styleSvgToHtml","document","createElement","innerHTML","cached","getCache","q","b","res","join","setCache","quotedBlocks","noFormatting","chunks","chunk","PLACEHOLDER","chunks2","i2","chunk2","push","isImage","formatter","getTextFormatter","registeredClasses"],"sources":["C:\\Users\\Lucian\\Documents\\DEV\\nodejs\\stock-market-api\\dev\\static\\node_modules\\src\\.internal\\core\\formatters\\TextFormatter.ts"],"sourcesContent":["/**\r\n * Handles formatting of pseudo-markup in text.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { BaseObject } from \"../Base\";\r\nimport { AMElement } from \"../rendering/AMElement\";\r\nimport { Adapter } from \"../utils/Adapter\";\r\nimport { registry } from \"../Registry\";\r\nimport * as $strings from \"../utils/Strings\";\r\nimport * as $type from \"../utils/Type\";\r\n\r\n/**\r\n * Defines an interface for an object that holds a chunk of text.\r\n */\r\nexport interface ITextChunk {\r\n\r\n\t/**\r\n\t * Type of the chunk.\r\n\t */\r\n\t\"type\": \"value\" | \"text\" | \"format\" | \"image\",\r\n\r\n\t/**\r\n\t * Text.\r\n\t */\r\n\t\"text\": string\r\n\r\n}\r\n\r\n/**\r\n * A list of Adapters for [[TextFormatter]].\r\n */\r\nexport interface ITextFormatterAdapters {\r\n\r\n\t/**\r\n\t * Applied to each chunk of text when it is parsed and added to chunk list.\r\n\t */\r\n\tchunk: string\r\n\r\n}\r\n\r\n/**\r\n * Handles formatting of pseudo-markdown in text.\r\n *\r\n * @todo Encode < > in output\r\n * @todo Add more adapters\r\n * @important\r\n */\r\nexport class TextFormatter extends BaseObject {\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t */\r\n\tpublic _adapter!: ITextFormatterAdapters;\r\n\r\n\t/**\r\n\t * Adapter.\r\n\t */\r\n\tpublic adapter = new Adapter<TextFormatter, ITextFormatterAdapters>(this);\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"TextFormatter\";\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\tprotected debug(): void { }\r\n\r\n\t/**\r\n\t * Formats the text according to specifications passed in.\r\n\t *\r\n\t * @param text    Text to format\r\n\t * @param output  Output format (svg, html)\r\n\t * @return Formatted text\r\n\t */\r\n\tpublic format(text: string, output?: string): string {\r\n\r\n\t\t// Apply default\r\n\t\tif (!$type.hasValue(output)) {\r\n\t\t\toutput = \"svg\";\r\n\t\t}\r\n\r\n\t\t// Init return value\r\n\t\tlet formatted: string = \"\";\r\n\r\n\t\t// Replace double (escaped) square spaces with remporary codes\r\n\t\ttext = this.escape(text);\r\n\r\n\t\t// Divvy up the string by style tags\r\n\t\tlet styles: string[] | null = text.match(/\\[([^\\]]*?)\\]/gm);\r\n\r\n\t\tif (!styles) {\r\n\t\t\t// Nothing to do here - no formatting elements\r\n\t\t\treturn this.wrap(text, \"\", output);\r\n\t\t}\r\n\r\n\t\t// Get pure text - no style tags\r\n\t\tlet texts: string[] = text.split(/\\[[^\\[\\]]*\\]/);\r\n\r\n\t\t// Go through each of the texts and wrap it in style tags\r\n\t\tfor (let i = 0, len = texts.length; i < len; i++) {\r\n\r\n\t\t\t// Get text bit\r\n\t\t\tlet t: string = texts[i];\r\n\r\n\t\t\t// Check if string is empty\r\n\t\t\tif (t === \"\") {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// Run through an adapter\r\n\t\t\tt = this.adapter.apply(\"chunk\", t);\r\n\r\n\t\t\t// Get related style\r\n\t\t\tlet s: string = \"\";\r\n\t\t\tif (i > 0) {\r\n\t\t\t\ts = styles[i - 1].replace('[', '').replace(']', '');\r\n\t\t\t}\r\n\r\n\t\t\t// Wrap text in tag\r\n\t\t\tformatted += this.wrap(t, s, output);\r\n\t\t}\r\n\r\n\t\t// Replace placeholders back\r\n\t\tformatted = this.unescape(formatted);\r\n\r\n\t\t// Return result\r\n\t\treturn this.cleanUp(formatted);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Replaces brackets with temporary placeholders.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text  Input text\r\n\t * @return Escaped text\r\n\t */\r\n\tpublic escape(text: string): string {\r\n\t\treturn text.\r\n\t\t\treplace(/\\[\\[/g, registry.getPlaceholder(\"1\")).\r\n\t\t\treplace(/([^\\/\\]]{1})\\]\\]/g, \"$1\" + registry.getPlaceholder(\"2\")).\r\n\t\t\treplace(/\\]\\]/g, registry.getPlaceholder(\"2\")).\r\n\t\t\treplace(/\\{\\{/g, registry.getPlaceholder(\"3\")).\r\n\t\t\treplace(/\\}\\}/g, registry.getPlaceholder(\"4\")).\r\n\t\t\treplace(/\\'\\'/g, registry.getPlaceholder(\"5\"));\r\n\t}\r\n\r\n\t/**\r\n\t * Replaces placeholders back to brackets.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text  Escaped text\r\n\t * @return Unescaped text\r\n\t */\r\n\tpublic unescape(text: string): string {\r\n\t\treturn text.\r\n\t\t\treplace(new RegExp(registry.getPlaceholder(\"1\"), \"g\"), \"[[\").\r\n\t\t\treplace(new RegExp(registry.getPlaceholder(\"2\"), \"g\"), \"]]\").\r\n\t\t\treplace(new RegExp(registry.getPlaceholder(\"3\"), \"g\"), \"{{\").\r\n\t\t\treplace(new RegExp(registry.getPlaceholder(\"4\"), \"g\"), \"}}\").\r\n\t\t\treplace(new RegExp(registry.getPlaceholder(\"5\"), \"g\"), \"''\");\r\n\t}\r\n\r\n\t/**\r\n\t * Cleans up the text text for leftover double square brackets.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text  Input text\r\n\t * @return Cleaned up text\r\n\t */\r\n\tpublic cleanUp(text: string): string {\r\n\t\treturn text.\r\n\t\t\treplace(/\\[\\[/g, \"[\").\r\n\t\t\treplace(/\\]\\]/g, \"]\").\r\n\t\t\treplace(/\\{\\{/g, \"{\").\r\n\t\t\treplace(/\\}\\}/g, \"}\").\r\n\t\t\treplace(/\\'\\'/g, \"'\");\r\n\t}\r\n\r\n\t/**\r\n\t * Wraps text into corresponding tags.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text   Text to wrap\r\n\t * @param style  Styles\r\n\t * @param output  Format to output in (svg, html)\r\n\t * @return Formatted string\r\n\t */\r\n\tpublic wrap(text: string, style: string, output: string): string {\r\n\r\n\t\tif (style === \"\" || style === \"/\") {\r\n\t\t\t//return text;\r\n\t\t\tstyle = \"\";\r\n\t\t}\r\n\r\n\t\tswitch (output) {\r\n\t\t\tcase \"html\":\r\n\t\t\t\treturn this.wrapHtml(text, this.translateStyleShortcuts(style));\r\n\t\t\tdefault:\r\n\t\t\t\treturn this.wrapSvg(text, this.translateStyleShortcuts(style));\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Wraps text in styled SVG tag.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text   Text to wrap\r\n\t * @param style  Style property\r\n\t * @return Formatted tag\r\n\t */\r\n\tpublic wrapSvg(text: string, style: string): string {\r\n\t\tif (style === \"\") {\r\n\t\t\treturn \"<tspan>\" + text + \"</tspan>\";\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn \"<tspan style='\" + style + \"'>\" + text + \"</tspan>\";\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an SVG `<tspan>` element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text   Text\r\n\t * @param style  Style\r\n\t * @return Element\r\n\t */\r\n\tpublic getSvgElement(text: string, style?: string): AMElement {\r\n\t\tlet element = new AMElement(\"tspan\");\r\n\t\telement.textContent = text;\r\n\t\tif (style) {\r\n\t\t\telement.node.setAttribute(\"style\", style);\r\n\t\t}\r\n\t\treturn element;\r\n\t}\r\n\r\n\t/**\r\n\t * Wraps text in HTML <span> tag.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text   Text to wrap\r\n\t * @param style  Style property\r\n\t * @return Formatted tag\r\n\t * @todo Translate SVG styles into HTML ones\r\n\t */\r\n\tpublic wrapHtml(text: string, style: string): string {\r\n\t\tif (style === \"\") {\r\n\t\t\treturn \"<span>\" + text + \"</span>\";\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn \"<span style='\" + this.styleSvgToHtml(style) + \"'>\" + text + \"</span>\";\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an HTML `<span>` element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text   Text/HTML\r\n\t * @param style  Style definition\r\n\t * @return HTML element\r\n\t */\r\n\tpublic getHtmlElement(text: string, style?: string): HTMLElement {\r\n\t\tlet element = document.createElement(\"span\");\r\n\t\telement.innerHTML = text;\r\n\t\tif (style) {\r\n\t\t\telement.setAttribute(\"style\", style);\r\n\t\t}\r\n\t\treturn element;\r\n\t}\r\n\r\n\t/**\r\n\t * Trabslates SVG CSS into HTML CSS.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param style  SVG CSS\r\n\t * @return HTML CSS\r\n\t * @todo Implement actual translation\r\n\t */\r\n\tpublic styleSvgToHtml(style: string): string {\r\n\t\tstyle = style.replace(/fill:/, \"color:\");\r\n\t\treturn style;\r\n\t}\r\n\r\n\t/**\r\n\t * Translates style shortcuts into full styles, i.e.:\r\n\t * \"bold\" => \"font-weight: bold\"\r\n\t * \"#f00\" => \"fill: #f00\"\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param style  Untranslated style\r\n\t * @return Translated style\r\n\t * @todo Implement actual translation\r\n\t */\r\n\tpublic translateStyleShortcuts(style: string): string {\r\n\r\n\r\n\t\tif (style == \"\" || style == \"[ ]\") {\r\n\t\t\treturn \"\";\r\n\t\t}\r\n\r\n\t\tlet cached = registry.getCache(\"translateStyleShortcuts_\" + style);\r\n\t\tif (cached) {\r\n\t\t\treturn cached;\r\n\t\t}\r\n\r\n\t\t// Pre-process quoted text\r\n\t\tconst q = style.match(/('[^']*')|(\"[^\"]*\")/gi);\r\n\t\tif (q) {\r\n\t\t\tfor (let i: number = 0; i < q.length; i++) {\r\n\t\t\t\tstyle = style.replace(q[i], q[i].replace(/['\"]*/g, \"\").replace(/[ ]+/g, \"+\"));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Get style parts\r\n\t\tlet b: string[] | null = style.match(/([\\w\\-]*:[\\s]?[^;\\s\\]]*)|(\\#[\\w]{1,6})|([\\w]+)|(\\/)/gi);\r\n\r\n\t\t// Empty?\r\n\t\tif (!b) {\r\n\t\t\treturn style;\r\n\t\t}\r\n\r\n\t\t// Check each part\r\n\t\tfor (let i: number = 0; i < b.length; i++) {\r\n\r\n\t\t\tif (b[i].match(/^bold$/i)) {\r\n\t\t\t\t// Bold\r\n\t\t\t\tb[i] = \"font-weight:\" + b[i];\r\n\t\t\t}\r\n\t\t\telse if (b[i] == \"/\") {\r\n\t\t\t\t// Just closing tag\r\n\t\t\t\t// Do nothing\r\n\t\t\t\tb[i] = \"\";\r\n\t\t\t}\r\n\t\t\telse if (!b[i].match(/:/)) {\r\n\t\t\t\t// Color\r\n\t\t\t\tb[i] = \"fill:\" + b[i];\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tb[i] = b[i].replace(/\\+/g, \" \");\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tlet res = b.join(';');\r\n\t\tregistry.setCache(\"translateStyleShortcuts_\" + style, res);\r\n\r\n\t\treturn res;\r\n\t}\r\n\r\n\t/**\r\n\t * Splits string into chunks. (style blocks, quoted blocks, regular blocks)\r\n\t *\r\n\t * If the second parameter `quotedBlocks` is set to `true` this method will\r\n\t * also single out text blocks enclosed within single quotes that no\r\n\t * formatting should be applied to, and they should be displayed as is.\r\n\t *\r\n\t * Default for the above is `false`, so that you can use single quote in text\r\n\t * without escaping it.\r\n\t *\r\n\t * If enabled, single quotes can be escaped by doubling it - adding two\r\n\t * single quotes, which will be replaced by a one single quote in the final\r\n\t * output.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text          Text to chunk\r\n\t * @param quotedBlocks  Use quoted blocks\r\n\t * @param noFormatting  Formatting blocks will be treated as regular text\r\n\t * @return Array of string chunks\r\n\t */\r\n\tpublic chunk(text: string, quotedBlocks: boolean = false, noFormatting: boolean = false): ITextChunk[] {\r\n\r\n\t\t// Init result\r\n\t\tlet res: ITextChunk[] = [];\r\n\r\n\t\t// Replace double (escaped) square spaces and quotes with temporary codes\r\n\t\ttext = this.escape(text);\r\n\r\n\t\t// Deal with style blocks\r\n\t\tlet chunks = quotedBlocks ? text.split(\"'\") : [text];\r\n\t\tfor (let i: number = 0; i < chunks.length; i++) {\r\n\t\t\tlet chunk = chunks[i];\r\n\r\n\t\t\t// Empty?\r\n\t\t\tif (chunk === \"\") {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tif ((i % 2) === 0) {\r\n\r\n\t\t\t\t// Text outside quotes\r\n\t\t\t\t// Parse for style blocks which are \"text\" chunks, the rest chunks are\r\n\t\t\t\t// \"value\"\r\n\r\n\t\t\t\tchunk = chunk.replace(/\\]\\[/g, \"]\" + $strings.PLACEHOLDER + \"[\");\r\n\t\t\t\tchunk = chunk.replace(/\\[\\]/g, \"[ ]\");\r\n\t\t\t\tlet chunks2 = chunk.split(/[\\[\\]]+/);\r\n\t\t\t\tfor (let i2: number = 0; i2 < chunks2.length; i2++) {\r\n\t\t\t\t\tlet chunk2 = this.cleanUp(this.unescape(chunks2[i2]));\r\n\r\n\t\t\t\t\t// Placeholder?\r\n\t\t\t\t\tif (chunk2 === $strings.PLACEHOLDER) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Empty?\r\n\t\t\t\t\tif (chunk2 === \"\") {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Block or value\r\n\t\t\t\t\tif ((i2 % 2) === 0) {\r\n\t\t\t\t\t\tres.push({\r\n\t\t\t\t\t\t\t\"type\": \"value\",\r\n\t\t\t\t\t\t\t\"text\": this.adapter.apply(\"chunk\", chunk2)\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tres.push({\r\n\t\t\t\t\t\t\t\"type\": noFormatting ? \"value\" : \"format\",\r\n\t\t\t\t\t\t\t\"text\": \"[\" + chunk2 + \"]\"\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\telse {\r\n\r\n\t\t\t\t// A text within doublequotes\r\n\t\t\t\t// All chunks are \"text\"\r\n\r\n\t\t\t\tlet chunks2 = chunk.split(/[\\[\\]]+/);\r\n\t\t\t\tfor (let i2: number = 0; i2 < chunks2.length; i2++) {\r\n\t\t\t\t\tlet chunk2 = this.cleanUp(this.unescape(chunks2[i2]));\r\n\r\n\t\t\t\t\t// Empty?\r\n\t\t\t\t\tif (chunk2 === \"\") {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Block or text\r\n\t\t\t\t\tif ((i2 % 2) === 0) {\r\n\t\t\t\t\t\tres.push({\r\n\t\t\t\t\t\t\t\"type\": \"text\",\r\n\t\t\t\t\t\t\t\"text\": chunk2\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (this.isImage(chunk2)) {\r\n\t\t\t\t\t\tres.push({\r\n\t\t\t\t\t\t\t\"type\": \"image\",\r\n\t\t\t\t\t\t\t\"text\": \"[\" + chunk2 + \"]\"\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tres.push({\r\n\t\t\t\t\t\t\t\"type\": \"format\",\r\n\t\t\t\t\t\t\t\"text\": \"[\" + chunk2 + \"]\"\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn res;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if supplied format contains image information and should be\r\n\t * formatted as such.\r\n\t * I.e.: `[img: myImage.png]`\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text  Format\r\n\t * @return `true` if it is an image\r\n\t */\r\n\tpublic isImage(text: string): boolean {\r\n\t\treturn text.match(/img[ ]?:/) ? true : false;\r\n\t}\r\n\r\n}\r\n\r\n\r\nlet formatter: TextFormatter;\r\n\r\n/**\r\n * Returns the global instance of [[TextFormatter]].\r\n *\r\n * All classes and instances should reuse this universal text formatter,\r\n * rather than create their own instance of it.\r\n */\r\nexport function getTextFormatter(): TextFormatter {\r\n\tif (formatter == null) {\r\n\t\tformatter = new TextFormatter();\r\n\t}\r\n\r\n\treturn formatter;\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"TextFormatter\"] = TextFormatter;\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}