{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { XYCursor } from \"./XYCursor\";\nimport { Percent, percent } from \"../../core/utils/Percent\";\nimport { registry } from \"../../core/Registry\";\nimport * as $path from \"../../core/rendering/Path\";\nimport * as $math from \"../../core/utils/Math\";\nimport * as $utils from \"../../core/utils/Utils\";\nimport * as $type from \"../../core/utils/Type\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * Cursor for [[RadarChart]].\r\n *\r\n * @see {@link IRadarCursorEvents} for a list of available events\r\n * @see {@link IRadarCursorAdapters} for a list of available Adapters\r\n */\nvar RadarCursor = /** @class */function (_super) {\n  __extends(RadarCursor, _super);\n  /**\r\n   * Constructor\r\n   */\n  function RadarCursor() {\n    var _this =\n    // Init\n    _super.call(this) || this;\n    _this.className = \"RadarCursor\";\n    _this.radius = percent(100);\n    _this.innerRadius = percent(0);\n    // Apply theme\n    _this.applyTheme();\n    _this.mask = undefined;\n    return _this;\n  }\n  /**\r\n   * Checks if point is within bounds of a container.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param point  Point to check\r\n   * @return Fits within container?\r\n   */\n  RadarCursor.prototype.fitsToBounds = function (point) {\n    var radius = $math.getDistance(point);\n    //if(!$math.isAngleInRange(angle, this.startAngle, this.endAngle)){\n    //return false;\n    //}\n    if (radius < this.truePixelRadius + 1 && radius > this.pixelInnerRadius - 1) {\n      // ok to add/remove some\n      return true;\n    }\n    return false;\n  };\n  Object.defineProperty(RadarCursor.prototype, \"startAngle\", {\n    /**\r\n     * @return Start angle\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"startAngle\");\n    },\n    /**\r\n     * Starting angle of the cursor's radial line.\r\n     *\r\n     * @param value Start angle\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"startAngle\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(RadarCursor.prototype, \"endAngle\", {\n    /**\r\n     * @return End angle\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"endAngle\");\n    },\n    /**\r\n     * End angle of the cursor's radial line.\r\n     *\r\n     * @param value End angle\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"endAngle\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  RadarCursor.prototype.triggerMoveReal = function (point, force) {\n    if (!this.xAxis || this.xAxis && (!this.xAxis.cursorTooltipEnabled || this.xAxis.tooltip.disabled)) {\n      this.updateLineX(this.point);\n    }\n    if (!this.yAxis || this.yAxis && (!this.yAxis.cursorTooltipEnabled || this.yAxis.tooltip.disabled)) {\n      this.updateLineY(this.point);\n    }\n    this.updateSelection();\n    _super.prototype.triggerMoveReal.call(this, point, force);\n  };\n  /**\r\n   * (Re)draws the horizontal (circular) cursor's line.\r\n   *\r\n   * @param point New target point\r\n   */\n  RadarCursor.prototype.updateLineX = function (point) {\n    var radius = this.pixelRadius;\n    var startAngle = this.startAngle;\n    var endAngle = this.endAngle;\n    var innerRadius = this.pixelInnerRadius;\n    if (radius > 0 && $type.isNumber(startAngle) && $type.isNumber(endAngle) && $type.isNumber(innerRadius)) {\n      var angle = $math.fitAngleToRange($math.getAngle(point), startAngle, endAngle);\n      var path = void 0;\n      if (this.lineX && this.lineX.visible) {\n        this.lineX.moveTo({\n          x: 0,\n          y: 0\n        });\n        // fill\n        if (this.xAxis && this.fullWidthLineX) {\n          var startPoint = this.xAxis.currentItemStartPoint;\n          var endPoint = this.xAxis.currentItemEndPoint;\n          if (startPoint && endPoint) {\n            var fillStartAngle = $math.fitAngleToRange($math.getAngle(startPoint), startAngle, endAngle);\n            var fillEndAngle = $math.fitAngleToRange($math.getAngle(endPoint), startAngle, endAngle);\n            var arc = fillEndAngle - fillStartAngle;\n            // clockwise\n            // this is needed, normalizeAngle doesn't solve it\n            if (startAngle < endAngle) {\n              if (arc < 0) {\n                arc += 360;\n              }\n            }\n            // ccw\n            else {\n              if (arc > 0) {\n                arc -= 360;\n              }\n            }\n            angle -= arc / 2;\n            path = $path.moveTo({\n              x: innerRadius * $math.cos(angle),\n              y: innerRadius * $math.sin(angle)\n            }) + $path.lineTo({\n              x: radius * $math.cos(angle),\n              y: radius * $math.sin(angle)\n            }) + $path.arcTo(angle, arc, radius) + $path.lineTo({\n              x: innerRadius * $math.cos(angle + arc),\n              y: innerRadius * $math.sin(angle + arc)\n            }) + $path.arcTo(angle + arc, -arc, innerRadius);\n          }\n        }\n        // line\n        if (!path) {\n          path = $path.moveTo({\n            x: innerRadius * $math.cos(angle),\n            y: innerRadius * $math.sin(angle)\n          }) + $path.lineTo({\n            x: radius * $math.cos(angle),\n            y: radius * $math.sin(angle)\n          });\n        }\n        this.lineX.path = path;\n      }\n    }\n  };\n  /**\r\n   * (Re)draws the vertical (radial) cursor's line.\r\n   *\r\n   * @param point New target point\r\n   */\n  RadarCursor.prototype.updateLineY = function (point) {\n    if (this.lineY && this.lineY.visible) {\n      var startAngle = this.startAngle;\n      var endAngle = this.endAngle;\n      var truePixelRadius = this.truePixelRadius;\n      var radius = $math.fitToRange($math.getDistance(point), 0, this.truePixelRadius);\n      if ($type.isNumber(radius) && $type.isNumber(startAngle)) {\n        this.lineY.moveTo({\n          x: 0,\n          y: 0\n        });\n        var path = void 0;\n        var arc = endAngle - startAngle;\n        if (this.yAxis && this.fullWidthLineY) {\n          // fill\n          var startPoint = this.yAxis.currentItemStartPoint;\n          var endPoint = this.yAxis.currentItemEndPoint;\n          if (startPoint && endPoint) {\n            var innerRadius = $math.fitToRange($math.getDistance(startPoint), 0, truePixelRadius);\n            radius = $math.fitToRange($math.getDistance(endPoint), 0, truePixelRadius);\n            path = $path.moveTo({\n              x: radius * $math.cos(startAngle),\n              y: radius * $math.sin(startAngle)\n            }) + $path.arcTo(startAngle, arc, radius);\n            path += $path.moveTo({\n              x: innerRadius * $math.cos(endAngle),\n              y: innerRadius * $math.sin(endAngle)\n            }) + $path.arcTo(endAngle, -arc, innerRadius);\n          }\n        }\n        if (!path) {\n          path = $path.moveTo({\n            x: radius * $math.cos(startAngle),\n            y: radius * $math.sin(startAngle)\n          }) + $path.arcTo(startAngle, endAngle - startAngle, radius);\n        }\n        this.lineY.path = path;\n      }\n    }\n  };\n  /**\r\n   * Updates selection dimensions on size change.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  RadarCursor.prototype.updateSelection = function () {\n    if (this._usesSelection) {\n      var downPoint = this.downPoint;\n      if (downPoint) {\n        var point = this.point;\n        var radius = this.pixelRadius;\n        var truePixelRadius = this.truePixelRadius;\n        var innerRadius = this.pixelInnerRadius;\n        var startAngle = Math.min(this.startAngle, this.endAngle);\n        var endAngle = Math.max(this.startAngle, this.endAngle);\n        var downAngle = $math.fitAngleToRange($math.getAngle(downPoint), startAngle, endAngle);\n        var angle = $math.fitAngleToRange($math.getAngle(point), startAngle, endAngle);\n        var downRadius = $math.getDistance(downPoint);\n        if (downRadius < truePixelRadius) {\n          var currentRadius = $math.fitToRange($math.getDistance(point), 0, truePixelRadius);\n          this._prevAngle = angle;\n          var path = $path.moveTo({\n            x: 0,\n            y: 0\n          });\n          var downSin = $math.sin(downAngle);\n          var downCos = $math.cos(downAngle);\n          var sin = $math.sin(angle);\n          var cos = $math.cos(angle);\n          var behavior = this.behavior;\n          if (behavior == \"zoomX\" || behavior == \"selectX\") {\n            path += $path.lineTo({\n              x: radius * downCos,\n              y: radius * downSin\n            }) + $path.arcTo(downAngle, angle - downAngle, radius) + $path.lineTo({\n              x: innerRadius * cos,\n              y: innerRadius * sin\n            }) + $path.arcTo(angle, downAngle - angle, innerRadius);\n          } else if (behavior == \"zoomY\" || behavior == \"selectY\") {\n            path = $path.moveTo({\n              x: currentRadius * $math.cos(startAngle),\n              y: currentRadius * $math.sin(startAngle)\n            }) + $path.arcTo(startAngle, endAngle - startAngle, currentRadius) + $path.lineTo({\n              x: downRadius * $math.cos(endAngle),\n              y: downRadius * $math.sin(endAngle)\n            }) + $path.arcTo(endAngle, startAngle - endAngle, downRadius) + $path.closePath();\n          } else if (behavior == \"zoomXY\") {\n            path = $path.moveTo({\n              x: currentRadius * $math.cos(downAngle),\n              y: currentRadius * $math.sin(downAngle)\n            }) + $path.arcTo(downAngle, angle - downAngle, currentRadius) + $path.lineTo({\n              x: downRadius * $math.cos(angle),\n              y: downRadius * $math.sin(angle)\n            }) + $path.arcTo(angle, downAngle - angle, downRadius) + $path.closePath();\n          }\n          this.selection.path = path;\n        }\n        this.selection.moveTo({\n          x: 0,\n          y: 0\n        });\n      }\n    }\n  };\n  /**\r\n   * Updates cursors current positions.\r\n   */\n  RadarCursor.prototype.getPositions = function () {\n    // positions are used by axes or series\n    var chart = this.chart;\n    if (chart) {\n      var innerRadius = this.pixelInnerRadius;\n      var radius = this.truePixelRadius - innerRadius;\n      var startAngle = this.startAngle;\n      var endAngle = this.endAngle;\n      var angle = $math.fitAngleToRange($math.getAngle(this.point), startAngle, endAngle);\n      var xPosition = (angle - startAngle) / (endAngle - startAngle);\n      this.xPosition = xPosition;\n      this.yPosition = $math.fitToRange(($math.getDistance(this.point) - innerRadius) / radius, 0, 1);\n    }\n  };\n  /**\r\n   * Overriding inherited method, so that nothing happens when it's triggered.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  RadarCursor.prototype.updatePoint = function (point) {};\n  /**\r\n   * Updates Cursor's position when axis tooltip changes horizontal position.\r\n   *\r\n   * @param event Axis event\r\n   */\n  RadarCursor.prototype.handleXTooltipPosition = function (event) {\n    if (this.xAxis.cursorTooltipEnabled) {\n      var tooltip = this.xAxis.tooltip;\n      this.updateLineX($utils.svgPointToSprite({\n        x: tooltip.pixelX,\n        y: tooltip.pixelY\n      }, this));\n    }\n  };\n  /**\r\n   * Updates Cursor's position when axis tooltip changes vertical position.\r\n   *\r\n   * @todo Description\r\n   * @param event Axis event\r\n   */\n  RadarCursor.prototype.handleYTooltipPosition = function (event) {\n    if (this.yAxis.cursorTooltipEnabled) {\n      var tooltip = this.yAxis.tooltip;\n      this.updateLineY($utils.svgPointToSprite({\n        x: tooltip.pixelX,\n        y: tooltip.pixelY\n      }, this));\n    }\n  };\n  /**\r\n   * needs to be overriden\r\n   * @ignore\r\n   */\n  RadarCursor.prototype.updateLinePositions = function (point) {};\n  /**\r\n   * [getRanges description]\r\n   *\r\n   * @todo Description\r\n   */\n  RadarCursor.prototype.getRanges = function () {\n    var downPoint = this.downPoint;\n    if (downPoint) {\n      var upPoint = this.upPoint;\n      var chart = this.chart;\n      if (chart) {\n        var radius = this.pixelRadius;\n        var startAngle = this.startAngle;\n        var endAngle = this.endAngle;\n        var downAngle = $math.fitAngleToRange($math.getAngle(downPoint), this.startAngle, this.endAngle);\n        var upAngle = $math.fitAngleToRange($math.getAngle(upPoint), this.startAngle, this.endAngle);\n        var downRadius = $math.fitToRange($math.getDistance(downPoint), 0, radius);\n        var upRadius = $math.fitToRange($math.getDistance(upPoint), 0, radius);\n        var startX = 0;\n        var endX = 1;\n        var startY = 0;\n        var endY = 1;\n        var behavior = this.behavior;\n        if (behavior == \"zoomX\" || behavior == \"selectX\" || behavior == \"zoomXY\" || behavior == \"selectXY\") {\n          var arc = endAngle - startAngle;\n          startX = $math.round((downAngle - startAngle) / arc, 5);\n          endX = $math.round((upAngle - startAngle) / arc, 5);\n        }\n        if (behavior == \"zoomY\" || behavior == \"selectY\" || behavior == \"zoomXY\" || behavior == \"selectXY\") {\n          startY = $math.round(downRadius / radius, 5);\n          endY = $math.round(upRadius / radius, 5);\n        }\n        this.xRange = {\n          start: Math.min(startX, endX),\n          end: Math.max(startX, endX)\n        };\n        this.yRange = {\n          start: Math.min(startY, endY),\n          end: Math.max(startY, endY)\n        };\n        if (this.behavior == \"selectX\" || this.behavior == \"selectY\" || this.behavior == \"selectXY\") {\n          // void\n        } else {\n          this.selection.hide();\n        }\n      }\n    }\n  };\n  /**\r\n   * Overriding inherited method, so that nothing happens when `updateSize`\r\n   * is triggered.\r\n   *\r\n   * RadarCursor is quite complicated and needs own sizing logic.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  RadarCursor.prototype.updateSize = function () {};\n  Object.defineProperty(RadarCursor.prototype, \"radius\", {\n    /**\r\n     * @return Outer radius\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"radius\");\n    },\n    /**\r\n     * Outer radius of the cursor's circular line.\r\n     * Absolute (px) or relative ([[Percent]]).\r\n     *\r\n     * @param value  Outer radius\r\n     */\n    set: function (value) {\n      this.setPercentProperty(\"radius\", value, false, false, 10, false);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(RadarCursor.prototype, \"pixelRadius\", {\n    /**\r\n     * Outer radius of the circular line in pixels.\r\n     *\r\n     * @return Outer radius (px)\r\n     * @readonly\r\n     */\n    get: function () {\n      return $utils.relativeRadiusToValue(this.radius, this.truePixelRadius);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(RadarCursor.prototype, \"truePixelRadius\", {\n    /**\r\n     * [truePixelRadius description]\r\n     *\r\n     * @todo Description\r\n     * @return Outer radius (px)\r\n     * @readonly\r\n     */\n    get: function () {\n      return $utils.relativeToValue(percent(100), $math.min(this.innerWidth / 2, this.innerHeight / 2));\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(RadarCursor.prototype, \"innerRadius\", {\n    /**\r\n     * @return Inner radius\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"innerRadius\");\n    },\n    /**\r\n     * Inner radius of the cursor's circular line.\r\n     * Absolute (px) or relative ([[Percent]]).\r\n     *\r\n     * @param value  Inner radius\r\n     */\n    set: function (value) {\n      this.setPercentProperty(\"innerRadius\", value, false, false, 10, false);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(RadarCursor.prototype, \"pixelInnerRadius\", {\n    /**\r\n     * Inner radius of the circular line in pixels.\r\n     *\r\n     * @return Inner radius (px)\r\n     * @readonly\r\n     */\n    get: function () {\n      var innerRadius = this.innerRadius;\n      if (innerRadius instanceof Percent) {\n        innerRadius = percent(100 * innerRadius.value * this.chart.innerRadiusModifyer);\n      }\n      return $utils.relativeRadiusToValue(innerRadius, this.truePixelRadius) || 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  RadarCursor.prototype.fixPoint = function (point) {\n    // overriding xy method\n    return point;\n  };\n  return RadarCursor;\n}(XYCursor);\nexport { RadarCursor };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\nregistry.registeredClasses[\"RadarCursor\"] = RadarCursor;","map":{"version":3,"mappings":"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","names":["XYCursor","Percent","percent","registry","$path","$math","$utils","$type","__extends","_super","_this","className","radius","innerRadius","applyTheme","mask","undefined","RadarCursor","point","getDistance","truePixelRadius","pixelInnerRadius","Object","getPropertyValue","value","setPropertyValue","force","xAxis","cursorTooltipEnabled","tooltip","disabled","updateLineX","yAxis","updateLineY","updateSelection","triggerMoveReal","pixelRadius","startAngle","endAngle","isNumber","angle","fitAngleToRange","getAngle","path","lineX","visible","moveTo","x","y","fullWidthLineX","startPoint","currentItemStartPoint","endPoint","currentItemEndPoint","fillStartAngle","fillEndAngle","arc","cos","sin","lineTo","arcTo","lineY","fitToRange","fullWidthLineY","_usesSelection","downPoint","Math","min","max","downAngle","downRadius","currentRadius","_prevAngle","downSin","downCos","behavior","closePath","selection","chart","xPosition","yPosition","event","svgPointToSprite","pixelX","pixelY","upPoint","upAngle","upRadius","startX","endX","startY","endY","round","xRange","start","end","yRange","hide","setPercentProperty","relativeRadiusToValue","relativeToValue","innerWidth","innerHeight","innerRadiusModifyer","registeredClasses"],"sources":["C:\\Users\\Lucian\\Documents\\DEV\\nodejs\\stock-market-api\\dev\\static\\node_modules\\src\\.internal\\charts\\cursors\\RadarCursor.ts"],"sourcesContent":["/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { RadarChart } from \"../types/RadarChart\";\r\nimport { XYCursor, IXYCursorAdapters, IXYCursorEvents, IXYCursorProperties } from \"./XYCursor\";\r\nimport { IPoint } from \"../../core/defs/IPoint\";\r\nimport { ISpriteEvents } from \"../../core/Sprite\";\r\nimport { Tooltip } from \"../../core/elements/Tooltip\";\r\nimport { Percent, percent } from \"../../core/utils/Percent\";\r\nimport { registry } from \"../../core/Registry\";\r\nimport * as $path from \"../../core/rendering/Path\";\r\nimport * as $math from \"../../core/utils/Math\";\r\nimport * as $utils from \"../../core/utils/Utils\";\r\nimport * as $type from \"../../core/utils/Type\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines properties for [[RadarCursor]].\r\n */\r\nexport interface IRadarCursorProperties extends IXYCursorProperties {\r\n\r\n\t/**\r\n\t * Inner radius of the cursor's circular line.\r\n\t * Absolute (px) or relative ([[Percent]]).\r\n\t */\r\n\tinnerRadius: number | Percent;\r\n\r\n\t/**\r\n\t * Outer radius of the cursor's circular line.\r\n\t * Absolute (px) or relative ([[Percent]]).\r\n\t */\r\n\tradius: number | Percent;\r\n\r\n\t/**\r\n\t * Starting angle of the cursor's radial line.\r\n\t */\r\n\tstartAngle: number;\r\n\r\n\t/**\r\n\t * Ending angle of the cursor's radial line.\r\n\t */\r\n\tendAngle: number;\r\n\r\n}\r\n\r\n/**\r\n * Defines events for [[RadarCursor]].\r\n */\r\nexport interface IRadarCursorEvents extends IXYCursorEvents { }\r\n\r\n/**\r\n * Defines adapters for [[RadarCursor]].\r\n *\r\n * @see {@link Adapter}\r\n */\r\nexport interface IRadarCursorAdapters extends IXYCursorAdapters, IRadarCursorProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Cursor for [[RadarChart]].\r\n *\r\n * @see {@link IRadarCursorEvents} for a list of available events\r\n * @see {@link IRadarCursorAdapters} for a list of available Adapters\r\n */\r\nexport class RadarCursor extends XYCursor {\r\n\r\n\t/**\r\n\t * Defines available properties\r\n\t */\r\n\tpublic _properties!: IRadarCursorProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters\r\n\t */\r\n\tpublic _adapter!: IRadarCursorAdapters;\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: IRadarCursorEvents;\r\n\r\n\t/**\r\n\t * A reference to chart cursor belongs to.\r\n\t */\r\n\tpublic _chart: RadarChart;\r\n\r\n\r\n\tprotected _prevAngle: number;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\r\n\t\t// Init\r\n\t\tsuper();\r\n\t\tthis.className = \"RadarCursor\";\r\n\t\tthis.radius = percent(100);\r\n\t\tthis.innerRadius = percent(0);\r\n\r\n\t\t// Apply theme\r\n\t\tthis.applyTheme();\r\n\r\n\t\tthis.mask = undefined;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if point is within bounds of a container.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param point  Point to check\r\n\t * @return Fits within container?\r\n\t */\r\n\tpublic fitsToBounds(point: IPoint): boolean {\r\n\t\tlet radius = $math.getDistance(point);\r\n\r\n\t\t//if(!$math.isAngleInRange(angle, this.startAngle, this.endAngle)){\r\n\t\t\t//return false;\r\n\t\t//}\r\n\t\tif (radius < this.truePixelRadius + 1 && radius > this.pixelInnerRadius - 1) { // ok to add/remove some\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * Starting angle of the cursor's radial line.\r\n\t *\r\n\t * @param value Start angle\r\n\t */\r\n\tpublic set startAngle(value: number) {\r\n\t\tthis.setPropertyValue(\"startAngle\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Start angle\r\n\t */\r\n\tpublic get startAngle(): number {\r\n\t\treturn this.getPropertyValue(\"startAngle\");\r\n\t}\r\n\r\n\t/**\r\n\t * End angle of the cursor's radial line.\r\n\t *\r\n\t * @param value End angle\r\n\t */\r\n\tpublic set endAngle(value: number) {\r\n\t\tthis.setPropertyValue(\"endAngle\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return End angle\r\n\t */\r\n\tpublic get endAngle(): number {\r\n\t\treturn this.getPropertyValue(\"endAngle\");\r\n\t}\r\n\r\n\r\n\tprotected triggerMoveReal(point:IPoint, force?:boolean) {\r\n\r\n\t\tif (!this.xAxis || (this.xAxis && (!this.xAxis.cursorTooltipEnabled || this.xAxis.tooltip.disabled))) {\r\n\t\t\tthis.updateLineX(this.point);\r\n\t\t}\r\n\t\tif (!this.yAxis || (this.yAxis && (!this.yAxis.cursorTooltipEnabled || this.yAxis.tooltip.disabled))) {\r\n\t\t\tthis.updateLineY(this.point);\r\n\t\t}\r\n\r\n\t\tthis.updateSelection();\r\n\t\tsuper.triggerMoveReal(point, force);\r\n\t}\r\n\r\n\t/**\r\n\t * (Re)draws the horizontal (circular) cursor's line.\r\n\t *\r\n\t * @param point New target point\r\n\t */\r\n\tprotected updateLineX(point: IPoint) {\r\n\r\n\t\tlet radius: number = this.pixelRadius;\r\n\t\tlet startAngle: number = this.startAngle;\r\n\t\tlet endAngle: number = this.endAngle;\r\n\t\tlet innerRadius: number = this.pixelInnerRadius;\r\n\r\n\t\tif (radius > 0 && $type.isNumber(startAngle) && $type.isNumber(endAngle) && $type.isNumber(innerRadius)) {\r\n\t\t\tlet angle: number = $math.fitAngleToRange($math.getAngle(point), startAngle, endAngle);\r\n\t\t\tlet path: string;\r\n\r\n\t\t\tif (this.lineX && this.lineX.visible) {\r\n\r\n\t\t\t\tthis.lineX.moveTo({ x: 0, y: 0 });\r\n\r\n\t\t\t\t// fill\r\n\t\t\t\tif (this.xAxis && this.fullWidthLineX) {\r\n\r\n\t\t\t\t\tlet startPoint: IPoint = this.xAxis.currentItemStartPoint;\r\n\t\t\t\t\tlet endPoint: IPoint = this.xAxis.currentItemEndPoint;\r\n\r\n\t\t\t\t\tif (startPoint && endPoint) {\r\n\t\t\t\t\t\tlet fillStartAngle: number = $math.fitAngleToRange($math.getAngle(startPoint), startAngle, endAngle);\r\n\t\t\t\t\t\tlet fillEndAngle: number = $math.fitAngleToRange($math.getAngle(endPoint), startAngle, endAngle);\r\n\r\n\t\t\t\t\t\tlet arc: number = fillEndAngle - fillStartAngle;\r\n\r\n\t\t\t\t\t\t// clockwise\r\n\t\t\t\t\t\t// this is needed, normalizeAngle doesn't solve it\r\n\t\t\t\t\t\tif (startAngle < endAngle) {\r\n\t\t\t\t\t\t\tif (arc < 0) {\r\n\t\t\t\t\t\t\t\tarc += 360;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// ccw\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tif (arc > 0) {\r\n\t\t\t\t\t\t\t\tarc -= 360;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tangle -= arc / 2;\r\n\r\n\t\t\t\t\t\tpath = $path.moveTo({ x: innerRadius * $math.cos(angle), y: innerRadius * $math.sin(angle) })\r\n\t\t\t\t\t\t\t+ $path.lineTo({ x: radius * $math.cos(angle), y: radius * $math.sin(angle) })\r\n\t\t\t\t\t\t\t+ $path.arcTo(angle, arc, radius)\r\n\t\t\t\t\t\t\t+ $path.lineTo({ x: innerRadius * $math.cos(angle + arc), y: innerRadius * $math.sin(angle + arc) })\r\n\t\t\t\t\t\t\t+ $path.arcTo(angle + arc, -arc, innerRadius);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// line\r\n\t\t\t\tif (!path) {\r\n\t\t\t\t\tpath = $path.moveTo({ x: innerRadius * $math.cos(angle), y: innerRadius * $math.sin(angle) }) + $path.lineTo({ x: radius * $math.cos(angle), y: radius * $math.sin(angle) });\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.lineX.path = path;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * (Re)draws the vertical (radial) cursor's line.\r\n\t *\r\n\t * @param point New target point\r\n\t */\r\n\tprotected updateLineY(point: IPoint) {\r\n\t\tif (this.lineY && this.lineY.visible) {\r\n\t\t\tlet startAngle = this.startAngle;\r\n\t\t\tlet endAngle = this.endAngle;\r\n\t\t\tlet truePixelRadius = this.truePixelRadius;\r\n\t\t\tlet radius = $math.fitToRange($math.getDistance(point), 0, this.truePixelRadius);\r\n\t\t\tif ($type.isNumber(radius) && $type.isNumber(startAngle)) {\r\n\t\t\t\tthis.lineY.moveTo({ x: 0, y: 0 });\r\n\r\n\t\t\t\tlet path: string;\r\n\t\t\t\tlet arc: number = endAngle - startAngle;\r\n\r\n\t\t\t\tif (this.yAxis && this.fullWidthLineY) {\r\n\t\t\t\t\t// fill\r\n\t\t\t\t\tlet startPoint: IPoint = this.yAxis.currentItemStartPoint;\r\n\t\t\t\t\tlet endPoint: IPoint = this.yAxis.currentItemEndPoint;\r\n\r\n\t\t\t\t\tif (startPoint && endPoint) {\r\n\t\t\t\t\t\tlet innerRadius: number = $math.fitToRange($math.getDistance(startPoint), 0, truePixelRadius);\r\n\t\t\t\t\t\tradius = $math.fitToRange($math.getDistance(endPoint), 0, truePixelRadius);\r\n\r\n\t\t\t\t\t\tpath = $path.moveTo({ x: radius * $math.cos(startAngle), y: radius * $math.sin(startAngle) }) + $path.arcTo(startAngle, arc, radius);\r\n\t\t\t\t\t\tpath += $path.moveTo({ x: innerRadius * $math.cos(endAngle), y: innerRadius * $math.sin(endAngle) }) + $path.arcTo(endAngle, -arc, innerRadius);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!path) {\r\n\t\t\t\t\tpath = $path.moveTo({ x: radius * $math.cos(startAngle), y: radius * $math.sin(startAngle) }) + $path.arcTo(startAngle, endAngle - startAngle, radius);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.lineY.path = path;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Updates selection dimensions on size change.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic updateSelection(): void {\r\n\t\tif (this._usesSelection) {\r\n\t\t\tlet downPoint: IPoint = this.downPoint;\r\n\r\n\t\t\tif (downPoint) {\r\n\r\n\t\t\t\tlet point: IPoint = this.point;\r\n\r\n\t\t\t\tlet radius: number = this.pixelRadius;\r\n\t\t\t\tlet truePixelRadius: number = this.truePixelRadius;\r\n\t\t\t\tlet innerRadius: number = this.pixelInnerRadius;\r\n\r\n\t\t\t\tlet startAngle: number = Math.min(this.startAngle, this.endAngle);\r\n\t\t\t\tlet endAngle: number = Math.max(this.startAngle, this.endAngle);\r\n\r\n\t\t\t\tlet downAngle: number = $math.fitAngleToRange($math.getAngle(downPoint), startAngle, endAngle);\r\n\t\t\t\tlet angle: number = $math.fitAngleToRange($math.getAngle(point), startAngle, endAngle);\r\n\r\n\t\t\t\tlet downRadius: number = $math.getDistance(downPoint);\r\n\t\t\t\tif (downRadius < truePixelRadius) {\r\n\r\n\t\t\t\t\tlet currentRadius = $math.fitToRange($math.getDistance(point), 0, truePixelRadius);\r\n\r\n\t\t\t\t\tthis._prevAngle = angle;\r\n\r\n\t\t\t\t\tlet path: string = $path.moveTo({ x: 0, y: 0 });\r\n\r\n\t\t\t\t\tlet downSin: number = $math.sin(downAngle);\r\n\t\t\t\t\tlet downCos: number = $math.cos(downAngle);\r\n\r\n\t\t\t\t\tlet sin: number = $math.sin(angle);\r\n\t\t\t\t\tlet cos: number = $math.cos(angle);\r\n\r\n\t\t\t\t\tlet behavior = this.behavior;\r\n\t\t\t\t\tif (behavior == \"zoomX\" || behavior == \"selectX\") {\r\n\t\t\t\t\t\tpath += $path.lineTo({ x: radius * downCos, y: radius * downSin }) + $path.arcTo(downAngle, angle - downAngle, radius) + $path.lineTo({ x: innerRadius * cos, y: innerRadius * sin }) + $path.arcTo(angle, downAngle - angle, innerRadius);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (behavior == \"zoomY\" || behavior == \"selectY\") {\r\n\t\t\t\t\t\tpath = $path.moveTo({ x: currentRadius * $math.cos(startAngle), y: currentRadius * $math.sin(startAngle) }) + $path.arcTo(startAngle, endAngle - startAngle, currentRadius) + $path.lineTo({ x: downRadius * $math.cos(endAngle), y: downRadius * $math.sin(endAngle) }) + $path.arcTo(endAngle, startAngle - endAngle, downRadius) + $path.closePath();\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (behavior == \"zoomXY\") {\r\n\t\t\t\t\t\tpath = $path.moveTo({ x: currentRadius * $math.cos(downAngle), y: currentRadius * $math.sin(downAngle) }) + $path.arcTo(downAngle, angle - downAngle, currentRadius) + $path.lineTo({ x: downRadius * $math.cos(angle), y: downRadius * $math.sin(angle) }) + $path.arcTo(angle, downAngle - angle, downRadius) + $path.closePath();\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthis.selection.path = path;\r\n\t\t\t\t}\r\n\t\t\t\tthis.selection.moveTo({ x: 0, y: 0 });\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Updates cursors current positions.\r\n\t */\r\n\tprotected getPositions() {\r\n\t\t// positions are used by axes or series\r\n\t\tlet chart: RadarChart = this.chart;\r\n\t\tif (chart) {\r\n\t\t\tlet innerRadius = this.pixelInnerRadius;\r\n\t\t\tlet radius: number = this.truePixelRadius - innerRadius;\r\n\r\n\t\t\tlet startAngle: number = this.startAngle;\r\n\t\t\tlet endAngle: number = this.endAngle;\r\n\r\n\t\t\tlet angle: number = $math.fitAngleToRange($math.getAngle(this.point), startAngle, endAngle);\r\n\t\t\tlet xPosition = ((angle - startAngle) / (endAngle - startAngle));\r\n\t\t\tthis.xPosition = xPosition;\r\n\r\n\t\t\tthis.yPosition = $math.fitToRange(($math.getDistance(this.point) - innerRadius) / radius, 0, 1);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Overriding inherited method, so that nothing happens when it's triggered.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tprotected updatePoint(point: IPoint) {\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Updates Cursor's position when axis tooltip changes horizontal position.\r\n\t *\r\n\t * @param event Axis event\r\n\t */\r\n\tprotected handleXTooltipPosition(event: ISpriteEvents[\"positionchanged\"]): void {\r\n\t\tif (this.xAxis.cursorTooltipEnabled) {\r\n\t\t\tlet tooltip: Tooltip = this.xAxis.tooltip;\r\n\t\t\tthis.updateLineX($utils.svgPointToSprite({ x: tooltip.pixelX, y: tooltip.pixelY }, this));\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Updates Cursor's position when axis tooltip changes vertical position.\r\n\t *\r\n\t * @todo Description\r\n\t * @param event Axis event\r\n\t */\r\n\tprotected handleYTooltipPosition(event: ISpriteEvents[\"positionchanged\"]): void {\r\n\t\tif (this.yAxis.cursorTooltipEnabled) {\r\n\t\t\tlet tooltip: Tooltip = this.yAxis.tooltip;\r\n\t\t\tthis.updateLineY($utils.svgPointToSprite({ x: tooltip.pixelX, y: tooltip.pixelY }, this));\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * needs to be overriden\r\n\t * @ignore\r\n\t */\r\n\tprotected updateLinePositions(point: IPoint) {\r\n\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * [getRanges description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprotected getRanges(): void {\r\n\t\tlet downPoint = this.downPoint;\r\n\t\tif (downPoint) {\r\n\t\t\tlet upPoint: IPoint = this.upPoint;\r\n\r\n\t\t\tlet chart: RadarChart = this.chart;\r\n\t\t\tif (chart) {\r\n\t\t\t\tlet radius: number = this.pixelRadius;\r\n\t\t\t\tlet startAngle: number = this.startAngle;\r\n\t\t\t\tlet endAngle: number = this.endAngle;\r\n\r\n\t\t\t\tlet downAngle: number = $math.fitAngleToRange($math.getAngle(downPoint), this.startAngle, this.endAngle);\r\n\t\t\t\tlet upAngle: number = $math.fitAngleToRange($math.getAngle(upPoint), this.startAngle, this.endAngle);\r\n\r\n\t\t\t\tlet downRadius = $math.fitToRange($math.getDistance(downPoint), 0, radius);\r\n\t\t\t\tlet upRadius = $math.fitToRange($math.getDistance(upPoint), 0, radius);\r\n\r\n\t\t\t\tlet startX: number = 0;\r\n\t\t\t\tlet endX: number = 1;\r\n\r\n\t\t\t\tlet startY: number = 0;\r\n\t\t\t\tlet endY: number = 1;\r\n\r\n\t\t\t\tlet behavior = this.behavior;\r\n\t\t\t\tif (behavior == \"zoomX\" || behavior == \"selectX\" || behavior == \"zoomXY\" || behavior == \"selectXY\") {\r\n\t\t\t\t\tlet arc: number = endAngle - startAngle;\r\n\t\t\t\t\tstartX = $math.round((downAngle - startAngle) / arc, 5);\r\n\t\t\t\t\tendX = $math.round((upAngle - startAngle) / arc, 5);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (behavior == \"zoomY\" || behavior == \"selectY\" || behavior == \"zoomXY\" || behavior == \"selectXY\") {\r\n\t\t\t\t\tstartY = $math.round(downRadius / radius, 5);\r\n\t\t\t\t\tendY = $math.round(upRadius / radius, 5);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.xRange = { start: Math.min(startX, endX), end: Math.max(startX, endX) };\r\n\t\t\t\tthis.yRange = { start: Math.min(startY, endY), end: Math.max(startY, endY) };\r\n\r\n\t\t\t\tif (this.behavior == \"selectX\" || this.behavior == \"selectY\" || this.behavior == \"selectXY\") {\r\n\t\t\t\t\t// void\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthis.selection.hide();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Overriding inherited method, so that nothing happens when `updateSize`\r\n\t * is triggered.\r\n\t *\r\n\t * RadarCursor is quite complicated and needs own sizing logic.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic updateSize(): void { }\r\n\r\n\t/**\r\n\t * Outer radius of the cursor's circular line.\r\n\t * Absolute (px) or relative ([[Percent]]).\r\n\t *\r\n\t * @param value  Outer radius\r\n\t */\r\n\tpublic set radius(value: number | Percent) {\r\n\t\tthis.setPercentProperty(\"radius\", value, false, false, 10, false);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Outer radius\r\n\t */\r\n\tpublic get radius(): number | Percent {\r\n\t\treturn this.getPropertyValue(\"radius\");\r\n\t}\r\n\r\n\t/**\r\n\t * Outer radius of the circular line in pixels.\r\n\t *\r\n\t * @return Outer radius (px)\r\n\t * @readonly\r\n\t */\r\n\tpublic get pixelRadius(): number {\r\n\t\treturn $utils.relativeRadiusToValue(this.radius, this.truePixelRadius);\r\n\t}\r\n\r\n\t/**\r\n\t * [truePixelRadius description]\r\n\t *\r\n\t * @todo Description\r\n\t * @return Outer radius (px)\r\n\t * @readonly\r\n\t */\r\n\tpublic get truePixelRadius(): number {\r\n\t\treturn $utils.relativeToValue(percent(100), $math.min(this.innerWidth / 2, this.innerHeight / 2));\r\n\t}\r\n\r\n\t/**\r\n\t * Inner radius of the cursor's circular line.\r\n\t * Absolute (px) or relative ([[Percent]]).\r\n\t *\r\n\t * @param value  Inner radius\r\n\t */\r\n\tpublic set innerRadius(value: number | Percent) {\r\n\t\tthis.setPercentProperty(\"innerRadius\", value, false, false, 10, false);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Inner radius\r\n\t */\r\n\tpublic get innerRadius(): number | Percent {\r\n\t\treturn this.getPropertyValue(\"innerRadius\");\r\n\t}\r\n\r\n\t/**\r\n\t * Inner radius of the circular line in pixels.\r\n\t *\r\n\t * @return Inner radius (px)\r\n\t * @readonly\r\n\t */\r\n\tpublic get pixelInnerRadius(): number {\r\n\r\n\t\tlet innerRadius = this.innerRadius;\r\n\r\n\t\tif (innerRadius instanceof Percent) {\r\n\t\t\tinnerRadius = percent(100 * innerRadius.value * this.chart.innerRadiusModifyer);\r\n\t\t}\r\n\r\n\t\treturn $utils.relativeRadiusToValue(innerRadius, this.truePixelRadius) || 0;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\r\n\tprotected fixPoint(point: IPoint): IPoint {\r\n\t\t// overriding xy method\r\n\t\treturn point;\r\n\t}\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"RadarCursor\"] = RadarCursor;\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}