{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Pattern } from \"./Pattern\";\n/**\r\n * A pattern that uses an SVG path.\r\n *\r\n * @since 5.2.33\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/patterns/} for more info\r\n */\nvar PathPattern = /** @class */function (_super) {\n  __extends(PathPattern, _super);\n  function PathPattern() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  Object.defineProperty(PathPattern.prototype, \"_beforeChanged\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype._beforeChanged.call(this);\n      if (this.isDirty(\"svgPath\")) {\n        this._clear = true;\n      }\n    }\n  });\n  Object.defineProperty(PathPattern.prototype, \"_draw\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype._draw.call(this);\n      // const checkered = this.get(\"checkered\", false);\n      // const centered = this.get(\"centered\", true);\n      // const gap = this.get(\"gap\", 0);\n      // const rotation = this.get(\"rotation\", 0);\n      // let w = this.get(\"width\", 100);\n      // let h = this.get(\"height\", 100);\n      // let rectW = this.get(\"maxWidth\", 5);\n      // let rectH = this.get(\"maxHeight\", 5);\n      // let cellW = rectW + gap;\n      // let cellH = rectH + gap;\n      // let cols = Math.round(w / cellW);\n      // let rows = Math.round(h / cellH);\n      // cellW = w / cols;\n      // cellH = h / rows;\n      // if (rotation != 0) {\n      // \t// @todo this is probably not right\n      // \tthis._display.x = cellW / 2 * $math.cos(rotation);\n      // \tthis._display.y = -cellH / 2 * $math.sin(rotation);\n      // }\n      // for (let r = rotation == 0 ? 0 : -rows * 2; r < rows * 2; r++) {\n      // \tfor (let c = rotation == 0 ? 0 : -cols * 2; c < cols * 2; c++) {\n      // \t\tif (!checkered || ((r & 1) != 1 && (c & 1) != 1) || ((r & 1) == 1 && (c & 1) == 1)) {\n      // \t\t\tlet x = c * cellW;\n      // \t\t\tlet y = r * cellH;\n      // \t\t\tif (centered) {\n      // \t\t\t\tx += (cellW - rectW) / 2;\n      // \t\t\t\ty += (cellH - rectH) / 2;\n      // \t\t\t}\n      // \t\t\tthis._display.drawRect(x, y, rectW, rectH);\n      // \t\t}\n      // \t}\n      // }\n      // if (checkered) {\n      // \tw = w / 2 - gap * 2;\n      // \th = h / 2 - gap * 2;\n      // }\n      // else {\n      // \tw -= gap;\n      // \th -= gap;\n      // }\n      var svgPath = this.get(\"svgPath\");\n      if (svgPath != null) {\n        this._display.svgPath(svgPath);\n      }\n      var color = this.get(\"color\");\n      var colorOpacity = this.get(\"colorOpacity\");\n      if (color || colorOpacity) {\n        // this._display.lineStyle(strokeWidth, stroke, colorOpacity);\n        // this._display.endStroke();\n        this._display.beginFill(color, colorOpacity);\n        this._display.endFill();\n      }\n    }\n  });\n  Object.defineProperty(PathPattern, \"className\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: \"PathPattern\"\n  });\n  Object.defineProperty(PathPattern, \"classNames\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: Pattern.classNames.concat([PathPattern.className])\n  });\n  return PathPattern;\n}(Pattern);\nexport { PathPattern };","map":{"version":3,"mappings":";AAAA,SAASA,OAAO,QAA2C,WAAW;AAsDtE;;;;;;AAMA;EAAiCC;EAAjC;;EAiFA;;;;;WA1EC;MACCC,iBAAMC,cAAc,WAAE;MAEtB,IAAI,IAAI,CAACC,OAAO,CAAC,SAAS,CAAC,EAAE;QAC5B,IAAI,CAACC,MAAM,GAAG,IAAI;;IAEpB;;;;;;WAEA;MACCH,iBAAMI,KAAK,WAAE;MAEb;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MAGA;MACA;MAEA;MACA;MAEA;MACA;MAEA;MACA;MACA;MACA;MACA;MAEA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MAEA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MAEA,IAAMC,OAAO,GAAG,IAAI,CAACC,GAAG,CAAC,SAAS,CAAC;MACnC,IAAID,OAAO,IAAI,IAAI,EAAE;QACpB,IAAI,CAACE,QAAQ,CAACF,OAAO,CAACA,OAAQ,CAAC;;MAGhC,IAAMG,KAAK,GAAG,IAAI,CAACF,GAAG,CAAC,OAAO,CAAC;MAC/B,IAAMG,YAAY,GAAG,IAAI,CAACH,GAAG,CAAC,cAAc,CAAC;MAC7C,IAAIE,KAAK,IAAIC,YAAY,EAAE;QAC1B;QACA;QACA,IAAI,CAACF,QAAQ,CAACG,SAAS,CAACF,KAAK,EAAEC,YAAY,CAAC;QAC5C,IAAI,CAACF,QAAQ,CAACI,OAAO,EAAE;;IAGzB;;EA5EAC;;;;WAAkC;;EAClCA;;;;WAA0Cd,OAAO,CAACe,UAAU,CAACC,MAAM,CAAC,CAACC,WAAW,CAACC,SAAS,CAAC;;EA4E5F,kBAAC;CAAA,CAjFgClB,OAAO;SAA3BiB,WAAW","names":["Pattern","__extends","_super","_beforeChanged","isDirty","_clear","_draw","svgPath","get","_display","color","colorOpacity","beginFill","endFill","Object","classNames","concat","PathPattern","className"],"sources":["C:\\Users\\Lucian\\Documents\\DEV\\nodejs\\stock-market-api\\dev\\static\\node_modules\\src\\.internal\\core\\render\\patterns\\PathPattern.ts"],"sourcesContent":["import { Pattern, IPatternSettings, IPatternPrivate } from \"./Pattern\";\n\n//import * as $math from \"../../util/Math\";\n\nexport interface IPathPatternSettings extends IPatternSettings {\n\n\t// /**\n\t//  * Gap between Paths, in pixels.\n\t//  *\n\t//  * @default 6\n\t//  */\n\t// gap?: number;\n\n\t// /**\n\t//  * Maximum width of the Path, in pixels.\n\t//  *\n\t//  * @default 5\n\t//  */\n\t// maxWidth?: number;\n\n\t// /**\n\t//  * Maximum height of the Path, in pixels.\n\t//  *\n\t//  * @default 5\n\t//  */\n\t// maxHeight?: number;\n\n\t// /**\n\t//  * If set to `true`, will place every second Path, creating checkered\n\t//  * pattern.\n\t//  *\n\t//  * @default false\n\t//  */\n\t// checkered?: boolean;\n\n\t// /**\n\t//  * Center image.\n\t//  *\n\t//  * @default true\n\t//  */\n\t// centered?: boolean;\n\n\t/**\n\t * Use an SVG path as pattern.\n\t *\n\t * @see {@link https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths} for more information\n\t */\n\tsvgPath?: string;\n\n}\n\nexport interface IPathPatternPrivate extends IPatternPrivate {\n}\n\n/**\n * A pattern that uses an SVG path.\n *\n * @since 5.2.33\n * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/patterns/} for more info\n */\nexport class PathPattern extends Pattern {\n\tdeclare public _settings: IPathPatternSettings;\n\tdeclare public _privateSettings: IPathPatternPrivate;\n\n\tpublic static className: string = \"PathPattern\";\n\tpublic static classNames: Array<string> = Pattern.classNames.concat([PathPattern.className]);\n\n\tpublic _beforeChanged() {\n\t\tsuper._beforeChanged();\n\n\t\tif (this.isDirty(\"svgPath\")) {\n\t\t\tthis._clear = true;\n\t\t}\n\t}\n\n\tprotected _draw() {\n\t\tsuper._draw();\n\n\t\t// const checkered = this.get(\"checkered\", false);\n\t\t// const centered = this.get(\"centered\", true);\n\t\t// const gap = this.get(\"gap\", 0);\n\t\t// const rotation = this.get(\"rotation\", 0);\n\t\t// let w = this.get(\"width\", 100);\n\t\t// let h = this.get(\"height\", 100);\n\t\t// let rectW = this.get(\"maxWidth\", 5);\n\t\t// let rectH = this.get(\"maxHeight\", 5);\n\n\n\t\t// let cellW = rectW + gap;\n\t\t// let cellH = rectH + gap;\n\n\t\t// let cols = Math.round(w / cellW);\n\t\t// let rows = Math.round(h / cellH);\n\n\t\t// cellW = w / cols;\n\t\t// cellH = h / rows;\n\n\t\t// if (rotation != 0) {\n\t\t// \t// @todo this is probably not right\n\t\t// \tthis._display.x = cellW / 2 * $math.cos(rotation);\n\t\t// \tthis._display.y = -cellH / 2 * $math.sin(rotation);\n\t\t// }\n\n\t\t// for (let r = rotation == 0 ? 0 : -rows * 2; r < rows * 2; r++) {\n\t\t// \tfor (let c = rotation == 0 ? 0 : -cols * 2; c < cols * 2; c++) {\n\t\t// \t\tif (!checkered || ((r & 1) != 1 && (c & 1) != 1) || ((r & 1) == 1 && (c & 1) == 1)) {\n\t\t// \t\t\tlet x = c * cellW;\n\t\t// \t\t\tlet y = r * cellH;\n\t\t// \t\t\tif (centered) {\n\t\t// \t\t\t\tx += (cellW - rectW) / 2;\n\t\t// \t\t\t\ty += (cellH - rectH) / 2;\n\t\t// \t\t\t}\n\t\t// \t\t\tthis._display.drawRect(x, y, rectW, rectH);\n\t\t// \t\t}\n\t\t// \t}\n\t\t// }\n\n\t\t// if (checkered) {\n\t\t// \tw = w / 2 - gap * 2;\n\t\t// \th = h / 2 - gap * 2;\n\t\t// }\n\t\t// else {\n\t\t// \tw -= gap;\n\t\t// \th -= gap;\n\t\t// }\n\n\t\tconst svgPath = this.get(\"svgPath\");\n\t\tif (svgPath != null) {\n\t\t\tthis._display.svgPath(svgPath!);\n\t\t}\n\n\t\tconst color = this.get(\"color\");\n\t\tconst colorOpacity = this.get(\"colorOpacity\");\n\t\tif (color || colorOpacity) {\n\t\t\t// this._display.lineStyle(strokeWidth, stroke, colorOpacity);\n\t\t\t// this._display.endStroke();\n\t\t\tthis._display.beginFill(color, colorOpacity);\n\t\t\tthis._display.endFill();\n\t\t}\n\n\t}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}