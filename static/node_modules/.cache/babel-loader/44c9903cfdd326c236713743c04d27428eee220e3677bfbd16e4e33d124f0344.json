{"ast":null,"code":"var _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\nimport { head, last, getClosestItemIndexes, isDefined, isNotDefined, getLogger } from \"../utils\";\nvar log = getLogger(\"evaluator\");\nfunction getNewEnd(fallbackEnd, xAccessor, initialXScale, start) {\n  var lastItem = fallbackEnd.lastItem,\n    lastItemX = fallbackEnd.lastItemX;\n  var lastItemXValue = xAccessor(lastItem);\n  var _initialXScale$range = initialXScale.range(),\n    _initialXScale$range2 = _slicedToArray(_initialXScale$range, 2),\n    rangeStart = _initialXScale$range2[0],\n    rangeEnd = _initialXScale$range2[1];\n  var newEnd = (rangeEnd - rangeStart) / (lastItemX - rangeStart) * (lastItemXValue - start) + start;\n  return newEnd;\n}\nfunction extentsWrapper(useWholeData, clamp, pointsPerPxThreshold, minPointsPerPxThreshold, flipXScale) {\n  function filterData(data, inputDomain, xAccessor, initialXScale) {\n    var _ref = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {},\n      currentPlotData = _ref.currentPlotData,\n      currentDomain = _ref.currentDomain,\n      fallbackStart = _ref.fallbackStart,\n      fallbackEnd = _ref.fallbackEnd;\n    if (useWholeData) {\n      return {\n        plotData: data,\n        domain: inputDomain\n      };\n    }\n    var left = head(inputDomain);\n    var right = last(inputDomain);\n    var clampedDomain = inputDomain;\n    var filteredData = getFilteredResponse(data, left, right, xAccessor);\n    if (filteredData.length === 1 && isDefined(fallbackStart)) {\n      left = fallbackStart;\n      right = getNewEnd(fallbackEnd, xAccessor, initialXScale, left);\n      clampedDomain = [left, right];\n      filteredData = getFilteredResponse(data, left, right, xAccessor);\n    }\n    if (typeof clamp === \"function\") {\n      clampedDomain = clamp(clampedDomain, [xAccessor(head(data)), xAccessor(last(data))]);\n    } else {\n      if (clamp === \"left\" || clamp === \"both\" || clamp === true) {\n        clampedDomain = [Math.max(left, xAccessor(head(data))), clampedDomain[1]];\n      }\n      if (clamp === \"right\" || clamp === \"both\" || clamp === true) {\n        clampedDomain = [clampedDomain[0], Math.min(right, xAccessor(last(data)))];\n      }\n    }\n    if (clampedDomain !== inputDomain) {\n      filteredData = getFilteredResponse(data, clampedDomain[0], clampedDomain[1], xAccessor);\n    }\n    var realInputDomain = clampedDomain;\n    // [xAccessor(head(filteredData)), xAccessor(last(filteredData))];\n\n    var xScale = initialXScale.copy().domain(realInputDomain);\n    var width = Math.floor(xScale(xAccessor(last(filteredData))) - xScale(xAccessor(head(filteredData))));\n\n    // prevent negative width when flipXScale\n    if (flipXScale && width < 0) {\n      width = width * -1;\n    }\n    var plotData = void 0,\n      domain = void 0;\n    var chartWidth = last(xScale.range()) - head(xScale.range());\n    log(\"Trying to show \" + filteredData.length + \" points in \" + width + \"px,\" + (\" I can show up to \" + (showMaxThreshold(width, pointsPerPxThreshold) - 1) + \" points in that width. \") + (\"Also FYI the entire chart width is \" + chartWidth + \"px and pointsPerPxThreshold is \" + pointsPerPxThreshold));\n    if (canShowTheseManyPeriods(width, filteredData.length, pointsPerPxThreshold, minPointsPerPxThreshold)) {\n      plotData = filteredData;\n      domain = realInputDomain;\n      log(\"AND IT WORKED\");\n    } else {\n      if (chartWidth > showMaxThreshold(width, pointsPerPxThreshold) && isDefined(fallbackEnd)) {\n        plotData = filteredData;\n        var newEnd = getNewEnd(fallbackEnd, xAccessor, initialXScale, head(realInputDomain));\n        domain = [head(realInputDomain), newEnd];\n        // plotData = currentPlotData || filteredData.slice(filteredData.length - showMax(width, pointsPerPxThreshold));\n        // domain = currentDomain || [xAccessor(head(plotData)), xAccessor(last(plotData))];\n\n        var newXScale = xScale.copy().domain(domain);\n        var newWidth = Math.floor(newXScale(xAccessor(last(plotData))) - newXScale(xAccessor(head(plotData))));\n        log(\"and ouch, that is too much, so instead showing \" + plotData.length + \" in \" + newWidth + \"px\");\n      } else {\n        plotData = currentPlotData || filteredData.slice(filteredData.length - showMax(width, pointsPerPxThreshold));\n        domain = currentDomain || [xAccessor(head(plotData)), xAccessor(last(plotData))];\n        var _newXScale = xScale.copy().domain(domain);\n        var _newWidth = Math.floor(_newXScale(xAccessor(last(plotData))) - _newXScale(xAccessor(head(plotData))));\n        log(\"and ouch, that is too much, so instead showing \" + plotData.length + \" in \" + _newWidth + \"px\");\n      }\n    }\n    return {\n      plotData: plotData,\n      domain: domain\n    };\n  }\n  return {\n    filterData: filterData\n  };\n}\nfunction canShowTheseManyPeriods(width, arrayLength, maxThreshold, minThreshold) {\n  return arrayLength > showMinThreshold(width, minThreshold) && arrayLength < showMaxThreshold(width, maxThreshold);\n}\nfunction showMinThreshold(width, threshold) {\n  return Math.max(1, Math.ceil(width * threshold));\n}\nfunction showMaxThreshold(width, threshold) {\n  return Math.floor(width * threshold);\n}\nfunction showMax(width, threshold) {\n  return Math.floor(showMaxThreshold(width, threshold) * 0.97);\n}\nfunction getFilteredResponse(data, left, right, xAccessor) {\n  var newLeftIndex = getClosestItemIndexes(data, left, xAccessor).right;\n  var newRightIndex = getClosestItemIndexes(data, right, xAccessor).left;\n  var filteredData = data.slice(newLeftIndex, newRightIndex + 1);\n  // console.log(right, newRightIndex, dataForInterval.length);\n\n  return filteredData;\n}\nexport default function (_ref2) {\n  var xScale = _ref2.xScale,\n    useWholeData = _ref2.useWholeData,\n    clamp = _ref2.clamp,\n    pointsPerPxThreshold = _ref2.pointsPerPxThreshold,\n    minPointsPerPxThreshold = _ref2.minPointsPerPxThreshold,\n    flipXScale = _ref2.flipXScale;\n  return extentsWrapper(useWholeData || isNotDefined(xScale.invert), clamp, pointsPerPxThreshold, minPointsPerPxThreshold, flipXScale);\n}","map":{"version":3,"mappings":"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","names":["head","last","getClosestItemIndexes","isDefined","isNotDefined","getLogger","log","getNewEnd","fallbackEnd","xAccessor","initialXScale","start","lastItem","lastItemX","lastItemXValue","range","_initialXScale$range2","rangeStart","rangeEnd","newEnd","extentsWrapper","useWholeData","clamp","pointsPerPxThreshold","minPointsPerPxThreshold","flipXScale","filterData","data","inputDomain","currentPlotData","currentDomain","fallbackStart","plotData","domain","left","right","clampedDomain","filteredData","getFilteredResponse","length","Math","max","min","realInputDomain","xScale","copy","width","floor","chartWidth","showMaxThreshold","canShowTheseManyPeriods","newXScale","newWidth","slice","showMax","arrayLength","maxThreshold","minThreshold","showMinThreshold","threshold","ceil","newLeftIndex","newRightIndex","invert"],"sources":["C:\\Users\\Lucian\\Documents\\DEV\\nodejs\\stock-market-api\\dev\\static\\node_modules\\src\\lib\\scale\\evaluator.js"],"sourcesContent":["\n\nimport {\n\thead,\n\tlast,\n\tgetClosestItemIndexes,\n\tisDefined,\n\tisNotDefined,\n\tgetLogger,\n} from \"../utils\";\n\nconst log = getLogger(\"evaluator\");\n\nfunction getNewEnd(fallbackEnd, xAccessor, initialXScale, start) {\n\tconst {\n\t\tlastItem, lastItemX\n\t} = fallbackEnd;\n\tconst lastItemXValue = xAccessor(lastItem);\n\tconst [rangeStart, rangeEnd] = initialXScale.range();\n\n\tconst newEnd = (rangeEnd - rangeStart) / (lastItemX - rangeStart) * (lastItemXValue - start) + start;\n\treturn newEnd;\n}\n\nfunction extentsWrapper(useWholeData, clamp, pointsPerPxThreshold, minPointsPerPxThreshold, flipXScale) {\n\tfunction filterData(\n\t\tdata, inputDomain, xAccessor, initialXScale,\n\t\t{ currentPlotData, currentDomain, fallbackStart, fallbackEnd } = {}\n\t) {\n\t\tif (useWholeData) {\n\t\t\treturn { plotData: data, domain: inputDomain };\n\t\t}\n\n\t\tlet left = head(inputDomain);\n\t\tlet right = last(inputDomain);\n\t\tlet clampedDomain = inputDomain;\n\n\t\tlet filteredData = getFilteredResponse(data, left, right, xAccessor);\n\n\t\tif (filteredData.length === 1 && isDefined(fallbackStart)) {\n\t\t\tleft = fallbackStart;\n\t\t\tright = getNewEnd(fallbackEnd, xAccessor, initialXScale, left);\n\n\t\t\tclampedDomain = [\n\t\t\t\tleft,\n\t\t\t\tright,\n\t\t\t];\n\t\t\tfilteredData = getFilteredResponse(data, left, right, xAccessor);\n\t\t}\n\n\t\tif (typeof clamp === \"function\") {\n\t\t\tclampedDomain = clamp(clampedDomain, [xAccessor(head(data)), xAccessor(last(data))]);\n\t\t} else {\n\t\t\tif (clamp === \"left\" || clamp === \"both\" || clamp === true) {\n\t\t\t\tclampedDomain = [\n\t\t\t\t\tMath.max(left, xAccessor(head(data))),\n\t\t\t\t\tclampedDomain[1]\n\t\t\t\t];\n\t\t\t}\n\n\t\t\tif (clamp === \"right\" || clamp === \"both\" || clamp === true) {\n\t\t\t\tclampedDomain = [\n\t\t\t\t\tclampedDomain[0],\n\t\t\t\t\tMath.min(right, xAccessor(last(data)))\n\t\t\t\t];\n\t\t\t}\n\t\t}\n\n\t\tif (clampedDomain !== inputDomain) {\n\t\t\tfilteredData = getFilteredResponse(data, clampedDomain[0], clampedDomain[1], xAccessor);\n\t\t}\n\n\t\tconst realInputDomain = clampedDomain;\n\t\t// [xAccessor(head(filteredData)), xAccessor(last(filteredData))];\n\n\t\tconst xScale = initialXScale.copy().domain(realInputDomain);\n\n\t\tlet width = Math.floor(xScale(xAccessor(last(filteredData)))\n\t\t\t- xScale(xAccessor(head(filteredData))));\n\n\t\t// prevent negative width when flipXScale\n\t\tif (flipXScale && width < 0) {\n\t\t\twidth = width * -1;\n\t\t}\n\n\t\tlet plotData, domain;\n\n\t\tconst chartWidth = last(xScale.range()) - head(xScale.range());\n\n\t\tlog(`Trying to show ${filteredData.length} points in ${width}px,`\n\t\t\t+ ` I can show up to ${showMaxThreshold(width, pointsPerPxThreshold) - 1} points in that width. `\n\t\t\t+ `Also FYI the entire chart width is ${chartWidth}px and pointsPerPxThreshold is ${pointsPerPxThreshold}`);\n\n\t\tif (canShowTheseManyPeriods(width, filteredData.length, pointsPerPxThreshold, minPointsPerPxThreshold)) {\n\t\t\tplotData = filteredData;\n\t\t\tdomain = realInputDomain;\n\t\t\tlog(\"AND IT WORKED\");\n\t\t} else {\n\t\t\tif (chartWidth > showMaxThreshold(width, pointsPerPxThreshold) && isDefined(fallbackEnd)) {\n\t\t\t\tplotData = filteredData;\n\t\t\t\tconst newEnd = getNewEnd(fallbackEnd, xAccessor, initialXScale, head(realInputDomain));\n\t\t\t\tdomain = [\n\t\t\t\t\thead(realInputDomain),\n\t\t\t\t\tnewEnd\n\t\t\t\t];\n\t\t\t\t// plotData = currentPlotData || filteredData.slice(filteredData.length - showMax(width, pointsPerPxThreshold));\n\t\t\t\t// domain = currentDomain || [xAccessor(head(plotData)), xAccessor(last(plotData))];\n\n\t\t\t\tconst newXScale = xScale.copy().domain(domain);\n\t\t\t\tconst newWidth = Math.floor(newXScale(xAccessor(last(plotData)))\n\t\t\t\t\t- newXScale(xAccessor(head(plotData))));\n\n\t\t\t\tlog(`and ouch, that is too much, so instead showing ${plotData.length} in ${newWidth}px`);\n\t\t\t} else {\n\t\t\t\tplotData = currentPlotData || filteredData.slice(filteredData.length - showMax(width, pointsPerPxThreshold));\n\t\t\t\tdomain = currentDomain || [xAccessor(head(plotData)), xAccessor(last(plotData))];\n\n\t\t\t\tconst newXScale = xScale.copy().domain(domain);\n\t\t\t\tconst newWidth = Math.floor(newXScale(xAccessor(last(plotData)))\n\t\t\t\t\t- newXScale(xAccessor(head(plotData))));\n\n\t\t\t\tlog(`and ouch, that is too much, so instead showing ${plotData.length} in ${newWidth}px`);\n\t\t\t}\n\t\t}\n\t\treturn { plotData, domain };\n\t}\n\treturn { filterData };\n}\n\nfunction canShowTheseManyPeriods(width, arrayLength, maxThreshold, minThreshold) {\n\treturn arrayLength > showMinThreshold(width, minThreshold) && arrayLength < showMaxThreshold(width, maxThreshold);\n}\n\nfunction showMinThreshold(width, threshold) {\n\treturn Math.max(1, Math.ceil(width * threshold));\n}\n\nfunction showMaxThreshold(width, threshold) {\n\treturn Math.floor(width * threshold);\n}\n\nfunction showMax(width, threshold) {\n\treturn Math.floor(showMaxThreshold(width, threshold) * 0.97);\n}\n\nfunction getFilteredResponse(data, left, right, xAccessor) {\n\tconst newLeftIndex = getClosestItemIndexes(data, left, xAccessor).right;\n\tconst newRightIndex = getClosestItemIndexes(data, right, xAccessor).left;\n\n\tconst filteredData = data.slice(newLeftIndex, newRightIndex + 1);\n\t// console.log(right, newRightIndex, dataForInterval.length);\n\n\treturn filteredData;\n}\n\nexport default function({\n\txScale, useWholeData, clamp,\n\tpointsPerPxThreshold, minPointsPerPxThreshold,\n\tflipXScale\n}) {\n\treturn extentsWrapper(\n\t\tuseWholeData || isNotDefined(xScale.invert),\n\t\tclamp,\n\t\tpointsPerPxThreshold,\n\t\tminPointsPerPxThreshold,\n\t\tflipXScale\n\t);\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}