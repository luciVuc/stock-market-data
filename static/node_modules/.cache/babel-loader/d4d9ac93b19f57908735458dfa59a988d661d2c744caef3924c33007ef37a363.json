{"ast":null,"code":"export class Candlestick {\n  constructor(_ref) {\n    let {\n      timestamp,\n      open,\n      close,\n      high,\n      low\n    } = _ref;\n    this.timestamp = void 0;\n    this.close = void 0;\n    this.high = void 0;\n    this.low = void 0;\n    this.open = void 0;\n    this.timestamp = parseInt(timestamp.toString());\n    this.open = parseFloat(open.toString());\n    this.close = parseFloat(close.toString());\n    this.high = parseFloat(high.toString());\n    this.low = parseFloat(low.toString());\n  }\n}\nexport class VolumeBar {\n  constructor(_ref2) {\n    let {\n      timestamp,\n      volume\n    } = _ref2;\n    this.timestamp = void 0;\n    this.volume = void 0;\n    this.timestamp = parseInt(timestamp.toString());\n    this.volume = parseFloat(volume.toString());\n  }\n}\n\n// const BULLISH_COLOR = '00FF00';\n// const BEARISH_COLOR = 'FF0000';\n\nexport class CandlestickChart extends HTMLCanvasElement {\n  // Returns an array of attributes that the browser will observe.\n  static observedAttributes() {}\n\n  // It’s called when the component is first initialized.\n  // It must call super() and can set any defaults or perform other pre-rendering processes.\n  constructor(props) {\n    super();\n    this.candlesticks = void 0;\n    this.gridColor = void 0;\n    this.gridTextColor = void 0;\n    this.mouseHoverBackgroundColor = void 0;\n    this.mouseHoverTextColor = void 0;\n    this.greenColor = void 0;\n    this.redHoverColor = void 0;\n    this.candleWidth = void 0;\n    this.marginLeft = void 0;\n    this.marginRight = void 0;\n    this.marginTop = void 0;\n    this.marginBottom = void 0;\n    this.yStart = void 0;\n    this.yEnd = void 0;\n    this.yRange = void 0;\n    this.yPixelRange = void 0;\n    this.xEnd = void 0;\n    this.xGridCells = void 0;\n    this.drawMouseOverlay = void 0;\n    this.mousePosition = void 0;\n    this.xMouseHover = void 0;\n    this.yMouseHover = void 0;\n    this.hoveredCandlestickID = void 0;\n    this.xPixelRange = void 0;\n    this.xStart = void 0;\n    this.xRange = void 0;\n    this.redColor = void 0;\n    this.greenHoverColor = void 0;\n    this.yGridCells = void 0;\n    const context = this.getContext(\"2d\");\n    context.font = \"12px sans-serif\";\n    context.lineWidth = 1;\n    this.attachShadow({\n      mode: \"open\"\n    });\n    this.addEventListener(\"mousemove\", this.mouseMoveHandler.bind(this));\n    this.addEventListener(\"mouseout\", this.mouseOutHandler.bind(this));\n    this.style.backgroundColor = \"#252525\";\n    this.gridColor = \"#444444\";\n    this.gridTextColor = \"#aaaaaa\";\n    this.mouseHoverBackgroundColor = \"#eeeeee\";\n    this.mouseHoverTextColor = \"#000000\";\n    this.greenColor = \"#00cc00\";\n    this.redColor = \"#cc0000\";\n    this.greenHoverColor = \"#00ff00\";\n    this.redHoverColor = \"#ff0000\";\n    this.candleWidth = 5;\n    this.marginLeft = 10;\n    this.marginRight = 100;\n    this.marginTop = 10;\n    this.marginBottom = 30;\n    this.yStart = 0;\n    this.yEnd = 0;\n    this.yRange = 0;\n    this.yPixelRange = this.height - this.marginTop - this.marginBottom;\n    this.xStart = 0;\n    this.xEnd = 0;\n    this.xRange = 0;\n    this.xPixelRange = this.width - this.marginLeft - this.marginRight;\n\n    // these are only approximations, the grid will be divided in a way so the numbers are nice\n    this.xGridCells = 16;\n    this.yGridCells = 16;\n    this.drawMouseOverlay = false;\n    this.mousePosition = {\n      x: 0,\n      y: 0\n    };\n    this.xMouseHover = 0;\n    this.yMouseHover = 0;\n    this.hoveredCandlestickID = 0;\n    this.candlesticks = [];\n  }\n\n  // Called whenever an observed attribute is changed.\n  // Those defined in HTML are passed immediately, but JavaScript can modify them:\n  attributeChangedCallback(propertyName, oldValue, newValue) {\n    // document.querySelector('hello-world').setAttribute('name', 'Everyone');\n    // The method may need to trigger a re-render when this occurs.\n  }\n\n  // This function is called when the Web Component is appended to a Document Object Model.\n  // It should run any required rendering.\n  connectedCallback() {}\n\n  // It’s called when the Web Component is removed from a Document Object Model.\n  // This may be useful if you need to clean up, such as removing stored state or\n  // aborting Ajax requests.\n  disconnectedCallback() {}\n\n  // This function is called when a Web Component is moved from one document to another.\n  // You may find a use for this, although I’ve struggled to think of any cases!\n  adoptedCallback() {}\n  addCandlestick(candlestick) {\n    this.candlesticks.push(candlestick);\n  }\n  mouseMoveHandler(event) {\n    this.mousePosition = this.getMousePos(event);\n    this.mousePosition.x += this.candleWidth / 2;\n    this.drawMouseOverlay = true;\n    if (this.mousePosition.x < this.marginLeft) this.drawMouseOverlay = false;\n    if (this.mousePosition.x > this.width - this.marginRight + this.candleWidth) this.drawMouseOverlay = false;\n    if (this.mousePosition.y > this.height - this.marginBottom) this.drawMouseOverlay = false;\n    if (this.drawMouseOverlay) {\n      this.yMouseHover = this.yToValueCoords(this.mousePosition.y);\n      this.xMouseHover = this.xToValueCoords(this.mousePosition.x);\n      // snap to candlesticks\n      const candlestickDelta = this.candlesticks[1].timestamp - this.candlesticks[0].timestamp;\n      this.hoveredCandlestickID = Math.floor((this.xMouseHover - this.candlesticks[0].timestamp) / candlestickDelta);\n      this.xMouseHover = Math.floor(this.xMouseHover / candlestickDelta) * candlestickDelta;\n      this.mousePosition.x = this.xToPixelCoords(this.xMouseHover);\n      this.draw();\n    } else this.draw();\n  }\n  mouseOutHandler(event) {\n    this.drawMouseOverlay = false;\n    this.draw();\n  }\n  getMousePos(event) {\n    const rect = this.getBoundingClientRect();\n    return {\n      x: event.clientX - rect.left,\n      y: event.clientY - rect.top\n    };\n  }\n  draw() {\n    const context = this.getContext(\"2d\");\n\n    // clear background\n    context.clearRect(0, 0, this.width, this.height);\n    this.calculateYRange();\n    this.calculateXRange();\n    this.drawGrid();\n    this.candleWidth = this.xPixelRange / this.candlesticks.length;\n    this.candleWidth--;\n    if (this.candleWidth % 2 === 0) this.candleWidth--;\n    for (let color, candlestick, i = 0; i < this.candlesticks.length; ++i) {\n      candlestick = this.candlesticks[i];\n      color = candlestick.close > candlestick.open ? this.greenColor : this.redColor;\n      if (i === this.hoveredCandlestickID) {\n        if (color === this.greenColor) color = this.greenHoverColor;else if (color === this.redColor) color = this.redHoverColor;\n      }\n\n      // draw the wick\n      this.drawLine(this.xToPixelCoords(candlestick.timestamp), this.yToPixelCoords(candlestick.low), this.xToPixelCoords(candlestick.timestamp), this.yToPixelCoords(candlestick.high), color);\n\n      // draw the candle\n      this.fillRect(this.xToPixelCoords(candlestick.timestamp) - Math.floor(this.candleWidth / 2), this.yToPixelCoords(candlestick.open), this.candleWidth, this.yToPixelCoords(candlestick.close) - this.yToPixelCoords(candlestick.open), color);\n    }\n\n    // draw mouse hover\n    if (this.drawMouseOverlay && context) {\n      // price line\n      context.setLineDash([5, 5]);\n      this.drawLine(0, this.mousePosition.y, this.width, this.mousePosition.y, this.mouseHoverBackgroundColor);\n      context.setLineDash([]);\n      let str = this.roundPriceValue(this.yMouseHover).toString();\n      let textWidth = context.measureText(str).width;\n      this.fillRect(this.width - 70, this.mousePosition.y - 10, 70, 20, this.mouseHoverBackgroundColor);\n      context.fillStyle = this.mouseHoverTextColor;\n      context.fillText(str, this.width - textWidth - 5, this.mousePosition.y + 5);\n\n      // time line\n      context.setLineDash([5, 5]);\n      this.drawLine(this.mousePosition.x, 0, this.mousePosition.x, this.height, this.mouseHoverBackgroundColor);\n      context.setLineDash([]);\n      str = this.formatDate(new Date(this.xMouseHover)).toString();\n      textWidth = context.measureText(str).width;\n      this.fillRect(this.mousePosition.x - textWidth / 2 - 5, this.height - 20, textWidth + 10, 20, this.mouseHoverBackgroundColor);\n      context.fillStyle = this.mouseHoverTextColor;\n      context.fillText(str, this.mousePosition.x - textWidth / 2, this.height - 5);\n\n      // data\n      let yPos = this.mousePosition.y - 95;\n      if (yPos < 0) {\n        yPos = this.mousePosition.y + 15;\n      }\n      this.fillRect(this.mousePosition.x + 15, yPos, 100, 80, this.mouseHoverBackgroundColor);\n      const color = this.candlesticks[this.hoveredCandlestickID].close > this.candlesticks[this.hoveredCandlestickID].open ? this.greenColor : this.redColor;\n      this.fillRect(this.mousePosition.x + 15, yPos, 10, 80, color);\n      context.lineWidth = 2;\n      this.drawRect(this.mousePosition.x + 15, yPos, 100, 80, color);\n      context.lineWidth = 1;\n      context.fillStyle = this.mouseHoverTextColor;\n      context.fillText(\"O: \" + this.candlesticks[this.hoveredCandlestickID].open, this.mousePosition.x + 30, yPos + 15);\n      context.fillText(\"C: \" + this.candlesticks[this.hoveredCandlestickID].close, this.mousePosition.x + 30, yPos + 35);\n      context.fillText(\"H: \" + this.candlesticks[this.hoveredCandlestickID].high, this.mousePosition.x + 30, yPos + 55);\n      context.fillText(\"L: \" + this.candlesticks[this.hoveredCandlestickID].low, this.mousePosition.x + 30, yPos + 75);\n    }\n  }\n  drawGrid() {\n    const context = this.getContext('2d');\n\n    // roughly divide the yRange into cells\n    const yGridSize = this.yRange / this.yGridCells;\n\n    // try to find a nice number to round to\n    let niceNumber = Math.pow(10, Math.ceil(Math.log10(yGridSize)));\n    if (yGridSize < 0.25 * niceNumber) niceNumber = 0.25 * niceNumber;else if (yGridSize < 0.5 * niceNumber) niceNumber = 0.5 * niceNumber;\n\n    // find next largest nice number above yStart\n    const yStartRoundNumber = Math.ceil(this.yStart / niceNumber) * niceNumber;\n    // find next lowest nice number below yEnd\n    const yEndRoundNumber = Math.floor(this.yEnd / niceNumber) * niceNumber;\n    for (let textWidth, y = yStartRoundNumber; y <= yEndRoundNumber; y += niceNumber) {\n      this.drawLine(0, this.yToPixelCoords(y), this.width, this.yToPixelCoords(y), this.gridColor);\n      textWidth = context.measureText(this.roundPriceValue(y).toString()).width;\n      context.fillStyle = this.gridTextColor;\n      context.fillText(this.roundPriceValue(y).toString(), this.width - textWidth - 5, this.yToPixelCoords(y) - 5);\n    }\n\n    // roughly divide the xRange into cells\n    const xGridSize = this.xRange / this.xGridCells;\n\n    // try to find a nice number to round to\n    niceNumber = Math.pow(10, Math.ceil(Math.log10(xGridSize)));\n    if (xGridSize < 0.25 * niceNumber) {\n      niceNumber = 0.25 * niceNumber;\n    } else if (xGridSize < 0.5 * niceNumber) {\n      niceNumber = 0.5 * niceNumber;\n    }\n\n    // find next largest nice number above yStart\n    const xStartRoundNumber = Math.ceil(this.xStart / niceNumber) * niceNumber;\n    // find next lowest nice number below yEnd\n    const xEndRoundNumber = Math.floor(this.xEnd / niceNumber) * niceNumber;\n\n    // if the total x range is more than 5 days, format the timestamp as date instead of hours\n    let formatAsDate = this.xRange > 60 * 60 * 24 * 1000 * 5;\n    for (let day, month, minutes, date, dateStr, x = xStartRoundNumber; x <= xEndRoundNumber; x += niceNumber) {\n      this.drawLine(this.xToPixelCoords(x), 0, this.xToPixelCoords(x), this.height, this.gridColor);\n      date = new Date(x);\n      dateStr = \"\";\n      if (formatAsDate) {\n        day = date.getDate();\n        // if (day < 10) day = \"0\" + day;\n        month = date.getMonth() + 1;\n        // if (month < 10) month = \"0\" + month;\n        dateStr = `${day < 10 ? '0' + day : day}.${month < 10 ? '0' + month : month}`;\n      } else {\n        minutes = date.getMinutes();\n        if (minutes < 10) {\n          minutes = '0' + minutes;\n        }\n        dateStr = date.getHours() + \":\" + minutes;\n      }\n      context.fillStyle = this.gridTextColor;\n      context.fillText(dateStr, this.xToPixelCoords(x) + 5, this.height - 5);\n    }\n  }\n  calculateYRange() {\n    for (let i = 0; i < this.candlesticks.length; ++i) {\n      if (i === 0) {\n        this.yStart = this.candlesticks[i].low;\n        this.yEnd = this.candlesticks[i].high;\n      } else {\n        if (this.candlesticks[i].low < this.yStart) {\n          this.yStart = this.candlesticks[i].low;\n        }\n        if (this.candlesticks[i].high > this.yEnd) {\n          this.yEnd = this.candlesticks[i].high;\n        }\n      }\n    }\n    this.yRange = this.yEnd - this.yStart;\n  }\n  calculateXRange() {\n    this.xStart = this.candlesticks[0].timestamp;\n    this.xEnd = this.candlesticks[this.candlesticks.length - 1].timestamp;\n    this.xRange = this.xEnd - this.xStart;\n  }\n  yToPixelCoords(y) {\n    return this.height - this.marginBottom - (y - this.yStart) * this.yPixelRange / this.yRange;\n  }\n  xToPixelCoords(x) {\n    return this.marginLeft + (x - this.xStart) * this.xPixelRange / this.xRange;\n  }\n  yToValueCoords(y) {\n    return this.yStart + (this.height - this.marginBottom - y) * this.yRange / this.yPixelRange;\n  }\n  xToValueCoords(x) {\n    return this.xStart + (x - this.marginLeft) * this.xRange / this.xPixelRange;\n  }\n  drawLine(xStart, yStart, xEnd, yEnd, color) {\n    const context = this.getContext('2d');\n    context.beginPath();\n    // to get a crisp 1 pixel wide line, we need to add 0.5 to the coords\n    context.moveTo(xStart + 0.5, yStart + 0.5);\n    context.lineTo(xEnd + 0.5, yEnd + 0.5);\n    context.strokeStyle = color;\n    context.stroke();\n  }\n  fillRect(x, y, width, height, color) {\n    const context = this.getContext('2d');\n    context.beginPath();\n    context.fillStyle = color;\n    context.rect(x, y, width, height);\n    context.fill();\n  }\n  drawRect(x, y, width, height, color) {\n    const context = this.getContext('2d');\n    context.beginPath();\n    context.strokeStyle = color;\n    context.rect(x, y, width, height);\n    context.stroke();\n  }\n  formatDate(date) {\n    const day = date.getDate();\n    const month = date.getMonth() + 1;\n    const hours = date.getHours();\n    const minutes = date.getMinutes();\n    const year = date.getFullYear();\n    return `${day < 10 ? '0' + day : day}/${month < 10 ? '0' + month : month}/${year} - ${hours < 10 ? '0' + hours : hours}:${minutes < 10 ? '0' + minutes : minutes}`;\n  }\n  roundPriceValue(value) {\n    if (value > 1.0) return Math.round(value * 100) / 100;\n    if (value > 0.001) return Math.round(value * 1000) / 1000;\n    if (value > 0.00001) return Math.round(value * 100000) / 100000;\n    if (value > 0.0000001) return Math.round(value * 10000000) / 10000000;else return Math.round(value * 1000000000) / 1000000000;\n  }\n}\nexport default CandlestickChart;\nwindow.customElements.define(\"candlestick-chart\", CandlestickChart);\n\n// ----\n\n// {\n//   this.canvas = document.getElementById(canvasElementID);\n//   this.width = parseInt(this.canvas.width);\n//   this.height = parseInt(this.canvas.height);\n//   this.context = this.canvas.getContext(\"2d\");\n\n// this.canvas.addEventListener( \"mousemove\" , ( e ) => {\n//     this.mouseMove( e );\n// } );\n// this.canvas.addEventListener( \"mouseout\" , ( e ) => {\n//     this.mouseOut( e );\n// } );\n\n// this.canvas.style.backgroundColor = \"#252525\";\n// this.context.font = '12px sans-serif';\n// this.gridColor = \"#444444\";\n// this.gridTextColor = \"#aaaaaa\";\n// this.mouseHoverBackgroundColor = \"#eeeeee\";\n// this.mouseHoverTextColor = \"#000000\";\n// this.greenColor = \"#00cc00\";\n// this.redColor = \"#cc0000\";\n// this.greenHoverColor = \"#00ff00\";\n// this.redHoverColor = \"#ff0000\";\n\n// this.context.lineWidth = 1;\n// this.candleWidth = 5;\n\n// this.marginLeft = 10;\n// this.marginRight = 100;\n// this.marginTop = 10;\n// this.marginBottom = 30;\n\n// this.yStart = 0;\n// this.yEnd = 0;\n// this.yRange = 0;\n// this.yPixelRange = this.height-this.marginTop-this.marginBottom;\n\n// this.xStart = 0;\n// this.xEnd = 0;\n// this.xRange = 0;\n// this.xPixelRange = this.width-this.marginLeft-this.marginRight;\n\n// // these are only approximations, the grid will be divided in a way so the numbers are nice\n// this.xGridCells = 16;\n// this.yGridCells = 16;\n\n// thib_drawMouseOverlay = false;\n// this.mousePosition = { x: 0 , y: 0 };\n// this.xMouseHover = 0;\n// this.yMouseHover = 0;\n// this.hoveredCandlestickID = 0;\n\n// this.candlesticks = [];\n// }\n\n// pingpoliCandlestickChart.prototype.addCandlestick = function( candlestick )\n// {\n//     this.candlesticks.push( candlestick );\n// }\n\n// pingpoliCandlestickChart.prototype.mouseMove = function( e )\n// {\n//     var getMousePos = ( e ) =>\n//     {\n//         var rect = this.canvas.getBoundingClientRect();\n//         return { x: e.clientX-rect.left , y: e.clientY-rect.top };\n//     }\n//     this.mousePosition = getMousePos( e );\n//     this.mousePosition.x += this.candleWidth/2;\n//     this.b_drawMouseOverlay = true;\n//     if ( this.mousePosition.x < this.marginLeft ) this.b_drawMouseOverlay = false;\n//     if ( this.mousePosition.x > this.width-this.marginRight+this.candleWidth ) this.b_drawMouseOverlay = false;\n//     if ( this.mousePosition.y > this.height-this.marginBottom ) this.b_drawMouseOverlay = false;\n//     if ( this.b_drawMouseOverlay )\n//     {\n//         this.yMouseHover = this.yToValueCoords( this.mousePosition.y );\n//         this.xMouseHover = this.xToValueCoords( this.mousePosition.x );\n//         // snap to candlesticks\n//         var candlestickDelta = this.candlesticks[1].timestamp-this.candlesticks[0].timestamp;\n//         this.hoveredCandlestickID = Math.floor((this.xMouseHover-this.candlesticks[0].timestamp)/candlestickDelta);\n//         this.xMouseHover = Math.floor(this.xMouseHover/candlestickDelta)*candlestickDelta;\n//         this.mousePosition.x = this.xToPixelCoords( this.xMouseHover );\n//         this.draw();\n//     }\n//     else this.draw();\n// }\n\n// pingpoliCandlestickChart.prototype.mouseOut = function( e )\n// {\n//     this.b_drawMouseOverlay = false;\n//     this.draw();\n// }\n\n// pingpoliCandlestickChart.prototype.draw = function()\n// {\n// \t// clear background\n// \tthis.context.clearRect( 0 , 0 , this.width , this.height );\n\n//     this.calculateYRange();\n//     this.calculateXRange();\n\n//     this.drawGrid();\n\n//     this.candleWidth = this.xPixelRange/this.candlesticks.length;\n//     this.candleWidth--;\n//     if ( this.candleWidth%2 == 0 ) this.candleWidth--;\n\n//     for ( var i = 0 ; i < this.candlesticks.length ; ++i )\n//     {\n//         var color = ( this.candlesticks[i].close > this.candlesticks[i].open ) ? this.greenColor : this.redColor;\n\n//         if ( i == this.hoveredCandlestickID )\n//         {\n//             if ( color == this.greenColor ) color = this.greenHoverColor;\n//             else if ( color == this.redColor ) color = this.redHoverColor;\n//         }\n\n//         // draw the wick\n//         this.drawLine( this.xToPixelCoords( this.candlesticks[i].timestamp ) , this.yToPixelCoords( this.candlesticks[i].low ) , this.xToPixelCoords( this.candlesticks[i].timestamp ) , this.yToPixelCoords( this.candlesticks[i].high ) , color );\n\n//         // draw the candle\n//         this.fillRect( this.xToPixelCoords( this.candlesticks[i].timestamp )-Math.floor( this.candleWidth/2 ) , this.yToPixelCoords( this.candlesticks[i].open ) , this.candleWidth , this.yToPixelCoords( this.candlesticks[i].close ) - this.yToPixelCoords( this.candlesticks[i].open ) , color );\n//     }\n\n//     // draw mouse hover\n//     if ( this.b_drawMouseOverlay )\n//     {\n//         // price line\n//         this.context.setLineDash( [5,5] );\n//         this.drawLine( 0 , this.mousePosition.y , this.width , this.mousePosition.y , this.mouseHoverBackgroundColor );\n//         this.context.setLineDash( [] );\n//         var str = this.roundPriceValue( this.yMouseHover );\n//         var textWidth = this.context.measureText( str ).width;\n//         this.fillRect( this.width-70 , this.mousePosition.y-10 , 70 , 20 , this.mouseHoverBackgroundColor );\n//         this.context.fillStyle = this.mouseHoverTextColor;\n//         this.context.fillText( str , this.width-textWidth-5 , this.mousePosition.y+5 );\n\n//         // time line\n//         this.context.setLineDash( [5,5] );\n//         this.drawLine( this.mousePosition.x , 0 , this.mousePosition.x , this.height , this.mouseHoverBackgroundColor );\n//         this.context.setLineDash( [] );\n//         str = this.formatDate( new Date( this.xMouseHover ) );\n//         textWidth = this.context.measureText( str ).width;\n//         this.fillRect( this.mousePosition.x-textWidth/2-5 , this.height-20 , textWidth+10 , 20 , this.mouseHoverBackgroundColor );\n//         this.context.fillStyle = this.mouseHoverTextColor;\n//         this.context.fillText( str , this.mousePosition.x-textWidth/2 , this.height-5 );\n\n//         // data\n//         var yPos = this.mousePosition.y-95;\n//         if ( yPos < 0 ) yPos = this.mousePosition.y+15;\n\n//         this.fillRect( this.mousePosition.x+15 , yPos , 100 , 80 , this.mouseHoverBackgroundColor );\n//         var color = ( this.candlesticks[this.hoveredCandlestickID].close > this.candlesticks[this.hoveredCandlestickID].open ) ? this.greenColor : this.redColor;\n//         this.fillRect( this.mousePosition.x+15 , yPos , 10 , 80 , color );\n//         this.context.lineWidth = 2;\n//         this.drawRect( this.mousePosition.x+15 , yPos , 100 , 80 , color );\n//         this.context.lineWidth = 1;\n\n//         this.context.fillStyle = this.mouseHoverTextColor;\n//         this.context.fillText( \"O: \"+this.candlesticks[this.hoveredCandlestickID].open , this.mousePosition.x+30 , yPos+15 );\n//         this.context.fillText( \"C: \"+this.candlesticks[this.hoveredCandlestickID].close , this.mousePosition.x+30 , yPos+35 );\n//         this.context.fillText( \"H: \"+this.candlesticks[this.hoveredCandlestickID].high , this.mousePosition.x+30 , yPos+55 );\n//         this.context.fillText( \"L: \"+this.candlesticks[this.hoveredCandlestickID].low , this.mousePosition.x+30 , yPos+75 );\n//     }\n// }\n\n// pingpoliCandlestickChart.prototype.drawGrid = function () {\n//   // roughly divide the yRange into cells\n//   var yGridSize = this.yRange / this.yGridCells;\n\n//   // try to find a nice number to round to\n//   var niceNumber = Math.pow(10, Math.ceil(Math.log10(yGridSize)));\n//   if (yGridSize < 0.25 * niceNumber) niceNumber = 0.25 * niceNumber;\n//   else if (yGridSize < 0.5 * niceNumber) niceNumber = 0.5 * niceNumber;\n\n//   // find next largest nice number above yStart\n//   var yStartRoundNumber = Math.ceil(this.yStart / niceNumber) * niceNumber;\n//   // find next lowest nice number below yEnd\n//   var yEndRoundNumber = Math.floor(this.yEnd / niceNumber) * niceNumber;\n\n//   for (var y = yStartRoundNumber; y <= yEndRoundNumber; y += niceNumber) {\n//     this.drawLine(\n//       0,\n//       this.yToPixelCoords(y),\n//       this.width,\n//       this.yToPixelCoords(y),\n//       this.gridColor\n//     );\n//     var textWidth = this.context.measureText(this.roundPriceValue(y)).width;\n//     this.context.fillStyle = this.gridTextColor;\n//     this.context.fillText(\n//       this.roundPriceValue(y),\n//       this.width - textWidth - 5,\n//       this.yToPixelCoords(y) - 5\n//     );\n//   }\n\n//   // roughly divide the xRange into cells\n//   var xGridSize = this.xRange / this.xGridCells;\n\n//   // try to find a nice number to round to\n//   niceNumber = Math.pow(10, Math.ceil(Math.log10(xGridSize)));\n//   if (xGridSize < 0.25 * niceNumber) niceNumber = 0.25 * niceNumber;\n//   else if (xGridSize < 0.5 * niceNumber) niceNumber = 0.5 * niceNumber;\n\n//   // find next largest nice number above yStart\n//   var xStartRoundNumber = Math.ceil(this.xStart / niceNumber) * niceNumber;\n//   // find next lowest nice number below yEnd\n//   var xEndRoundNumber = Math.floor(this.xEnd / niceNumber) * niceNumber;\n\n//   // if the total x range is more than 5 days, format the timestamp as date instead of hours\n//   var b_formatAsDate = false;\n//   if (this.xRange > 60 * 60 * 24 * 1000 * 5) b_formatAsDate = true;\n\n//   for (var x = xStartRoundNumber; x <= xEndRoundNumber; x += niceNumber) {\n//     this.drawLine(\n//       this.xToPixelCoords(x),\n//       0,\n//       this.xToPixelCoords(x),\n//       this.height,\n//       this.gridColor\n//     );\n//     var date = new Date(x);\n//     var dateStr = \"\";\n//     if (b_formatAsDate) {\n//       var day = date.getDate();\n//       if (day < 10) day = \"0\" + day;\n//       var month = date.getMonth() + 1;\n//       if (month < 10) month = \"0\" + month;\n//       dateStr = day + \".\" + month;\n//     } else {\n//       var minutes = date.getMinutes();\n//       if (minutes < 10) minutes = \"0\" + minutes;\n//       dateStr = date.getHours() + \":\" + minutes;\n//     }\n//     this.context.fillStyle = this.gridTextColor;\n//     this.context.fillText(dateStr, this.xToPixelCoords(x) + 5, this.height - 5);\n//   }\n// };\n\n// pingpoliCandlestickChart.prototype.calculateYRange = function () {\n//   for (var i = 0; i < this.candlesticks.length; ++i) {\n//     if (i == 0) {\n//       this.yStart = this.candlesticks[i].low;\n//       this.yEnd = this.candlesticks[i].high;\n//     } else {\n//       if (this.candlesticks[i].low < this.yStart) {\n//         this.yStart = this.candlesticks[i].low;\n//       }\n//       if (this.candlesticks[i].high > this.yEnd) {\n//         this.yEnd = this.candlesticks[i].high;\n//       }\n//     }\n//   }\n//   this.yRange = this.yEnd - this.yStart;\n// };\n\n// pingpoliCandlestickChart.prototype.calculateXRange = function () {\n//   this.xStart = this.candlesticks[0].timestamp;\n//   this.xEnd = this.candlesticks[this.candlesticks.length - 1].timestamp;\n//   this.xRange = this.xEnd - this.xStart;\n// };\n\n// pingpoliCandlestickChart.prototype.yToPixelCoords = function (y) {\n//   return (\n//     this.height -\n//     this.marginBottom -\n//     ((y - this.yStart) * this.yPixelRange) / this.yRange\n//   );\n// };\n\n// pingpoliCandlestickChart.prototype.xToPixelCoords = function (x) {\n//   return this.marginLeft + ((x - this.xStart) * this.xPixelRange) / this.xRange;\n// };\n\n// pingpoliCandlestickChart.prototype.yToValueCoords = function (y) {\n//   return (\n//     this.yStart +\n//     ((this.height - this.marginBottom - y) * this.yRange) / this.yPixelRange\n//   );\n// };\n\n// pingpoliCandlestickChart.prototype.xToValueCoords = function (x) {\n//   return this.xStart + ((x - this.marginLeft) * this.xRange) / this.xPixelRange;\n// };\n\n// pingpoliCandlestickChart.prototype.drawLine = function (\n//   xStart,\n//   yStart,\n//   xEnd,\n//   yEnd,\n//   color\n// ) {\n//   this.context.beginPath();\n//   // to get a crisp 1 pixel wide line, we need to add 0.5 to the coords\n//   this.context.moveTo(xStart + 0.5, yStart + 0.5);\n//   this.context.lineTo(xEnd + 0.5, yEnd + 0.5);\n//   this.context.strokeStyle = color;\n//   this.context.stroke();\n// };\n\n// pingpoliCandlestickChart.prototype.fillRect = function (\n//   x,\n//   y,\n//   width,\n//   height,\n//   color\n// ) {\n//   this.context.beginPath();\n//   this.context.fillStyle = color;\n//   this.context.rect(x, y, width, height);\n//   this.context.fill();\n// };\n\n// pingpoliCandlestickChart.prototype.drawRect = function (\n//   x,\n//   y,\n//   width,\n//   height,\n//   color\n// ) {\n//   this.context.beginPath();\n//   this.context.strokeStyle = color;\n//   this.context.rect(x, y, width, height);\n//   this.context.stroke();\n// };\n\n// pingpoliCandlestickChart.prototype.formatDate = function (date) {\n//   var day = date.getDate();\n//   if (day < 10) day = \"0\" + day;\n//   var month = date.getMonth() + 1;\n//   if (month < 10) month = \"0\" + month;\n//   var hours = date.getHours();\n//   if (hours < 10) hours = \"0\" + hours;\n//   var minutes = date.getMinutes();\n//   if (minutes < 10) minutes = \"0\" + minutes;\n//   return (\n//     day + \".\" + month + \".\" + date.getFullYear() + \" - \" + hours + \":\" + minutes\n//   );\n// };\n\n// pingpoliCandlestickChart.prototype.roundPriceValue = function (value) {\n//   if (value > 1.0) return Math.round(value * 100) / 100;\n//   if (value > 0.001) return Math.round(value * 1000) / 1000;\n//   if (value > 0.00001) return Math.round(value * 100000) / 100000;\n//   if (value > 0.0000001) return Math.round(value * 10000000) / 10000000;\n//   else return Math.round(value * 1000000000) / 1000000000;\n// };","map":{"version":3,"names":["Candlestick","constructor","timestamp","open","close","high","low","parseInt","toString","parseFloat","VolumeBar","volume","CandlestickChart","HTMLCanvasElement","observedAttributes","props","candlesticks","gridColor","gridTextColor","mouseHoverBackgroundColor","mouseHoverTextColor","greenColor","redHoverColor","candleWidth","marginLeft","marginRight","marginTop","marginBottom","yStart","yEnd","yRange","yPixelRange","xEnd","xGridCells","drawMouseOverlay","mousePosition","xMouseHover","yMouseHover","hoveredCandlestickID","xPixelRange","xStart","xRange","redColor","greenHoverColor","yGridCells","context","getContext","font","lineWidth","attachShadow","mode","addEventListener","mouseMoveHandler","bind","mouseOutHandler","style","backgroundColor","height","width","x","y","attributeChangedCallback","propertyName","oldValue","newValue","connectedCallback","disconnectedCallback","adoptedCallback","addCandlestick","candlestick","push","event","getMousePos","yToValueCoords","xToValueCoords","candlestickDelta","Math","floor","xToPixelCoords","draw","rect","getBoundingClientRect","clientX","left","clientY","top","clearRect","calculateYRange","calculateXRange","drawGrid","length","color","i","drawLine","yToPixelCoords","fillRect","setLineDash","str","roundPriceValue","textWidth","measureText","fillStyle","fillText","formatDate","Date","yPos","drawRect","yGridSize","niceNumber","pow","ceil","log10","yStartRoundNumber","yEndRoundNumber","xGridSize","xStartRoundNumber","xEndRoundNumber","formatAsDate","day","month","minutes","date","dateStr","getDate","getMonth","getMinutes","getHours","beginPath","moveTo","lineTo","strokeStyle","stroke","fill","hours","year","getFullYear","value","round","window","customElements","define"],"sources":["C:/Users/Lucian/Documents/DEV/nodejs/stock-market-api/dev/static/src/components/CandleStickChart.tsx"],"sourcesContent":["export class Candlestick {\r\n  timestamp: number;\r\n  close: number;\r\n  high: number;\r\n  low: number;\r\n  open: number;\r\n\r\n  constructor({ timestamp, open, close, high, low }: TCandleStick) {\r\n    this.timestamp = parseInt(timestamp.toString());\r\n    this.open = parseFloat(open.toString());\r\n    this.close = parseFloat(close.toString());\r\n    this.high = parseFloat(high.toString());\r\n    this.low = parseFloat(low.toString());\r\n  }\r\n}\r\n\r\nexport class VolumeBar {\r\n  timestamp: number;\r\n  volume: number;\r\n\r\n  constructor({ timestamp, volume }: TVolume) {\r\n    this.timestamp = parseInt(timestamp.toString());\r\n    this.volume = parseFloat(volume.toString());\r\n  }\r\n}\r\n\r\n\r\n// const BULLISH_COLOR = '00FF00';\r\n// const BEARISH_COLOR = 'FF0000';\r\n\r\nexport class CandlestickChart extends HTMLCanvasElement {\r\n  private candlesticks: Candlestick[];\r\n  gridColor: string;\r\n  gridTextColor: string;\r\n  mouseHoverBackgroundColor: string;\r\n  mouseHoverTextColor: string;\r\n  greenColor: string;\r\n  redHoverColor: string;\r\n  candleWidth: number;\r\n  marginLeft: number;\r\n  marginRight: number;\r\n  marginTop: number;\r\n  marginBottom: number;\r\n  yStart: number;\r\n  yEnd: number;\r\n  yRange: number;\r\n  yPixelRange: number;\r\n  xEnd: number;\r\n  xGridCells: number;\r\n  drawMouseOverlay: boolean;\r\n  mousePosition: { x: number; y: number; };\r\n  xMouseHover: number;\r\n  yMouseHover: number;\r\n  hoveredCandlestickID: number;\r\n  xPixelRange: number;\r\n  xStart: number;\r\n  xRange: number;\r\n  redColor: string;\r\n  greenHoverColor: string;\r\n  yGridCells: number;\r\n\r\n  // Returns an array of attributes that the browser will observe.\r\n  static observedAttributes() {}\r\n\r\n  // It’s called when the component is first initialized.\r\n  // It must call super() and can set any defaults or perform other pre-rendering processes.\r\n  constructor(props: Record<string, any>) {\r\n    super();\r\n\r\n    const context = this.getContext(\"2d\") as CanvasRenderingContext2D;\r\n\r\n    context.font = \"12px sans-serif\";\r\n    context.lineWidth = 1;\r\n\r\n    this.attachShadow({ mode: \"open\" });\r\n\r\n    this.addEventListener(\"mousemove\", this.mouseMoveHandler.bind(this));\r\n    this.addEventListener(\"mouseout\", this.mouseOutHandler.bind(this));\r\n\r\n    this.style.backgroundColor = \"#252525\";\r\n\r\n    this.gridColor = \"#444444\";\r\n    this.gridTextColor = \"#aaaaaa\";\r\n    this.mouseHoverBackgroundColor = \"#eeeeee\";\r\n    this.mouseHoverTextColor = \"#000000\";\r\n    this.greenColor = \"#00cc00\";\r\n    this.redColor = \"#cc0000\";\r\n    this.greenHoverColor = \"#00ff00\";\r\n    this.redHoverColor = \"#ff0000\";\r\n\r\n    this.candleWidth = 5;\r\n\r\n    this.marginLeft = 10;\r\n    this.marginRight = 100;\r\n    this.marginTop = 10;\r\n    this.marginBottom = 30;\r\n\r\n    this.yStart = 0;\r\n    this.yEnd = 0;\r\n    this.yRange = 0;\r\n    this.yPixelRange = this.height-this.marginTop-this.marginBottom;\r\n\r\n    this.xStart = 0;\r\n    this.xEnd = 0;\r\n    this.xRange = 0;\r\n    this.xPixelRange = this.width-this.marginLeft-this.marginRight;\r\n\r\n    // these are only approximations, the grid will be divided in a way so the numbers are nice\r\n    this.xGridCells = 16;\r\n    this.yGridCells = 16;\r\n\r\n    this.drawMouseOverlay = false;\r\n    this.mousePosition = { x: 0 , y: 0 };\r\n    this.xMouseHover = 0;\r\n    this.yMouseHover = 0;\r\n    this.hoveredCandlestickID = 0;\r\n\r\n    this.candlesticks = [];\r\n  }\r\n\r\n  // Called whenever an observed attribute is changed.\r\n  // Those defined in HTML are passed immediately, but JavaScript can modify them:\r\n  attributeChangedCallback(propertyName: string, oldValue: any, newValue: any) {\r\n    // document.querySelector('hello-world').setAttribute('name', 'Everyone');\r\n    // The method may need to trigger a re-render when this occurs.\r\n  }\r\n\r\n  // This function is called when the Web Component is appended to a Document Object Model.\r\n  // It should run any required rendering.\r\n  connectedCallback() {}\r\n\r\n  // It’s called when the Web Component is removed from a Document Object Model.\r\n  // This may be useful if you need to clean up, such as removing stored state or\r\n  // aborting Ajax requests.\r\n  disconnectedCallback() {}\r\n\r\n  // This function is called when a Web Component is moved from one document to another.\r\n  // You may find a use for this, although I’ve struggled to think of any cases!\r\n  adoptedCallback() {}\r\n\r\n  addCandlestick(candlestick: Candlestick) {\r\n    this.candlesticks.push(candlestick);\r\n  }\r\n\r\n  mouseMoveHandler(event: MouseEvent) {\r\n    this.mousePosition = this.getMousePos(event);\r\n    this.mousePosition.x += this.candleWidth / 2;\r\n    this.drawMouseOverlay = true;\r\n    if (this.mousePosition.x < this.marginLeft) this.drawMouseOverlay = false;\r\n    if (this.mousePosition.x > this.width - this.marginRight + this.candleWidth)\r\n      this.drawMouseOverlay = false;\r\n    if (this.mousePosition.y > this.height - this.marginBottom)\r\n      this.drawMouseOverlay = false;\r\n    if (this.drawMouseOverlay) {\r\n      this.yMouseHover = this.yToValueCoords(this.mousePosition.y);\r\n      this.xMouseHover = this.xToValueCoords(this.mousePosition.x);\r\n      // snap to candlesticks\r\n      const candlestickDelta = this.candlesticks[1].timestamp - this.candlesticks[0].timestamp;\r\n      this.hoveredCandlestickID = Math.floor( (this.xMouseHover - this.candlesticks[0].timestamp) / candlestickDelta);\r\n      this.xMouseHover = Math.floor(this.xMouseHover / candlestickDelta) * candlestickDelta;\r\n      this.mousePosition.x = this.xToPixelCoords(this.xMouseHover);\r\n      this.draw();\r\n    } else this.draw();\r\n  }\r\n\r\n  mouseOutHandler(event: MouseEvent) {\r\n    this.drawMouseOverlay = false;\r\n    this.draw();\r\n  }\r\n\r\n  getMousePos(event: MouseEvent) {\r\n    const rect = this.getBoundingClientRect();\r\n    return { x: event.clientX - rect.left, y: event.clientY - rect.top };\r\n  }\r\n\r\n  draw() {\r\n    const context = this.getContext(\"2d\") as CanvasRenderingContext2D;\r\n\r\n    // clear background\r\n    context.clearRect(0, 0, this.width, this.height);\r\n    this.calculateYRange();\r\n    this.calculateXRange();\r\n\r\n    this.drawGrid();\r\n\r\n    this.candleWidth = this.xPixelRange / this.candlesticks.length;\r\n    this.candleWidth--;\r\n    if (this.candleWidth % 2 === 0) this.candleWidth--;\r\n\r\n    for (let color, candlestick, i = 0; i < this.candlesticks.length; ++i) {\r\n      candlestick = this.candlesticks[i];\r\n      color = candlestick.close > candlestick.open ? this.greenColor : this.redColor;\r\n\r\n      if (i === this.hoveredCandlestickID) {\r\n        if (color === this.greenColor) color = this.greenHoverColor;\r\n        else if (color === this.redColor) color = this.redHoverColor;\r\n      }\r\n\r\n      // draw the wick\r\n      this.drawLine(\r\n        this.xToPixelCoords(candlestick.timestamp),\r\n        this.yToPixelCoords(candlestick.low),\r\n        this.xToPixelCoords(candlestick.timestamp),\r\n        this.yToPixelCoords(candlestick.high),\r\n        color\r\n      );\r\n\r\n      // draw the candle\r\n      this.fillRect(\r\n        this.xToPixelCoords(candlestick.timestamp) - Math.floor(this.candleWidth / 2),\r\n        this.yToPixelCoords(candlestick.open),\r\n        this.candleWidth,\r\n        this.yToPixelCoords(candlestick.close) - this.yToPixelCoords(candlestick.open),\r\n        color\r\n      );\r\n    }\r\n\r\n    // draw mouse hover\r\n    if (this.drawMouseOverlay && context) {\r\n      // price line\r\n      context.setLineDash([5, 5]);\r\n      this.drawLine(0, this.mousePosition.y, this.width, this.mousePosition.y, this.mouseHoverBackgroundColor);\r\n      context.setLineDash([]);\r\n      let str = this.roundPriceValue(this.yMouseHover).toString();\r\n      let textWidth = context.measureText(str).width;\r\n      this.fillRect(this.width - 70, this.mousePosition.y - 10, 70, 20, this.mouseHoverBackgroundColor);\r\n      context.fillStyle = this.mouseHoverTextColor;\r\n      context.fillText(str, this.width - textWidth - 5, this.mousePosition.y + 5);\r\n\r\n      // time line\r\n      context.setLineDash([5, 5]);\r\n      this.drawLine(this.mousePosition.x, 0, this.mousePosition.x, this.height, this.mouseHoverBackgroundColor);\r\n      context.setLineDash([]);\r\n      str = this.formatDate(new Date(this.xMouseHover)).toString();\r\n      textWidth = context.measureText(str).width;\r\n      this.fillRect(this.mousePosition.x - textWidth / 2 - 5, this.height - 20, textWidth + 10, 20, this.mouseHoverBackgroundColor);\r\n      context.fillStyle = this.mouseHoverTextColor;\r\n      context.fillText(str, this.mousePosition.x - textWidth / 2, this.height - 5);\r\n\r\n      // data\r\n      let yPos = this.mousePosition.y - 95;\r\n      if (yPos < 0) {\r\n        yPos = this.mousePosition.y + 15;\r\n      }\r\n\r\n      this.fillRect(this.mousePosition.x + 15, yPos, 100, 80, this.mouseHoverBackgroundColor);\r\n      const color =\r\n        this.candlesticks[this.hoveredCandlestickID].close >\r\n        this.candlesticks[this.hoveredCandlestickID].open ? this.greenColor : this.redColor;\r\n      this.fillRect(this.mousePosition.x + 15, yPos, 10, 80, color);\r\n      context.lineWidth = 2;\r\n      this.drawRect(this.mousePosition.x + 15, yPos, 100, 80, color);\r\n      context.lineWidth = 1;\r\n\r\n      context.fillStyle = this.mouseHoverTextColor;\r\n      context.fillText(\r\n        \"O: \" + this.candlesticks[this.hoveredCandlestickID].open,\r\n        this.mousePosition.x + 30,\r\n        yPos + 15\r\n      );\r\n      context.fillText(\r\n        \"C: \" + this.candlesticks[this.hoveredCandlestickID].close,\r\n        this.mousePosition.x + 30,\r\n        yPos + 35\r\n      );\r\n      context.fillText(\r\n        \"H: \" + this.candlesticks[this.hoveredCandlestickID].high,\r\n        this.mousePosition.x + 30,\r\n        yPos + 55\r\n      );\r\n      context.fillText(\r\n        \"L: \" + this.candlesticks[this.hoveredCandlestickID].low,\r\n        this.mousePosition.x + 30,\r\n        yPos + 75\r\n      );\r\n    }\r\n  }\r\n\r\n  drawGrid() {\r\n    const context = this.getContext('2d') as CanvasRenderingContext2D ;\r\n\r\n    // roughly divide the yRange into cells\r\n    const yGridSize = this.yRange / this.yGridCells;\r\n  \r\n    // try to find a nice number to round to\r\n    let niceNumber = Math.pow(10, Math.ceil(Math.log10(yGridSize)));\r\n    if (yGridSize < 0.25 * niceNumber) niceNumber = 0.25 * niceNumber;\r\n    else if (yGridSize < 0.5 * niceNumber) niceNumber = 0.5 * niceNumber;\r\n  \r\n    // find next largest nice number above yStart\r\n    const yStartRoundNumber = Math.ceil(this.yStart / niceNumber) * niceNumber;\r\n    // find next lowest nice number below yEnd\r\n    const yEndRoundNumber = Math.floor(this.yEnd / niceNumber) * niceNumber;\r\n  \r\n    for (let textWidth, y = yStartRoundNumber; y <= yEndRoundNumber; y += niceNumber) {\r\n      this.drawLine(0, this.yToPixelCoords(y), this.width, this.yToPixelCoords(y), this.gridColor);\r\n      textWidth = context.measureText(this.roundPriceValue(y).toString()).width;\r\n      context.fillStyle = this.gridTextColor;\r\n      context.fillText(this.roundPriceValue(y).toString(), this.width - textWidth - 5, this.yToPixelCoords(y) - 5);\r\n    }\r\n  \r\n    // roughly divide the xRange into cells\r\n    const xGridSize = this.xRange / this.xGridCells;\r\n  \r\n    // try to find a nice number to round to\r\n    niceNumber = Math.pow(10, Math.ceil(Math.log10(xGridSize)));\r\n    if (xGridSize < 0.25 * niceNumber) {\r\n      niceNumber = 0.25 * niceNumber;\r\n    } else if (xGridSize < 0.5 * niceNumber) {\r\n      niceNumber = 0.5 * niceNumber;\r\n    }\r\n\r\n    // find next largest nice number above yStart\r\n    const xStartRoundNumber = Math.ceil(this.xStart / niceNumber) * niceNumber;\r\n    // find next lowest nice number below yEnd\r\n    const xEndRoundNumber = Math.floor(this.xEnd / niceNumber) * niceNumber;\r\n  \r\n    // if the total x range is more than 5 days, format the timestamp as date instead of hours\r\n    let formatAsDate = (this.xRange > 60 * 60 * 24 * 1000 * 5);\r\n  \r\n    for (let day, month, minutes, date, dateStr, x = xStartRoundNumber; x <= xEndRoundNumber; x += niceNumber) {\r\n      this.drawLine(this.xToPixelCoords(x), 0, this.xToPixelCoords(x), this.height, this.gridColor);\r\n      date = new Date(x);\r\n      dateStr = \"\";\r\n      if (formatAsDate) {\r\n        day = date.getDate();\r\n        // if (day < 10) day = \"0\" + day;\r\n        month = date.getMonth() + 1;\r\n        // if (month < 10) month = \"0\" + month;\r\n        dateStr = `${(day < 10) ? '0' + day : day}.${(month < 10) ? '0' + month : month}`;\r\n      } else {\r\n        minutes = date.getMinutes();\r\n        if (minutes < 10) {\r\n          minutes = '0' + minutes;\r\n        }\r\n        dateStr = date.getHours() + \":\" + minutes;\r\n      }\r\n      context.fillStyle = this.gridTextColor;\r\n      context.fillText(dateStr, this.xToPixelCoords(x) + 5, this.height - 5);\r\n    }\r\n  };\r\n  \r\n  calculateYRange() {\r\n    for (let i = 0; i < this.candlesticks.length; ++i) {\r\n      if (i === 0) {\r\n        this.yStart = this.candlesticks[i].low;\r\n        this.yEnd = this.candlesticks[i].high;\r\n      } else {\r\n        if (this.candlesticks[i].low < this.yStart) {\r\n          this.yStart = this.candlesticks[i].low;\r\n        }\r\n        if (this.candlesticks[i].high > this.yEnd) {\r\n          this.yEnd = this.candlesticks[i].high;\r\n        }\r\n      }\r\n    }\r\n    this.yRange = this.yEnd - this.yStart;\r\n  };\r\n  \r\n  calculateXRange() {\r\n    this.xStart = this.candlesticks[0].timestamp;\r\n    this.xEnd = this.candlesticks[this.candlesticks.length - 1].timestamp;\r\n    this.xRange = this.xEnd - this.xStart;\r\n  };\r\n  \r\n  yToPixelCoords(y: number) {\r\n    return (this.height - this.marginBottom - ((y - this.yStart) * this.yPixelRange) / this.yRange);\r\n  };\r\n  \r\n  xToPixelCoords(x: number) {\r\n    return this.marginLeft + ((x - this.xStart) * this.xPixelRange) / this.xRange;\r\n  };\r\n  \r\n  yToValueCoords(y: number) {\r\n    return (this.yStart + ((this.height - this.marginBottom - y) * this.yRange) / this.yPixelRange);\r\n  };\r\n  \r\n  xToValueCoords(x: number) {\r\n    return this.xStart + ((x - this.marginLeft) * this.xRange) / this.xPixelRange;\r\n  };\r\n  \r\n  drawLine( xStart: number, yStart: number, xEnd: number, yEnd: number, color: string | CanvasGradient | CanvasPattern) {\r\n    const context = this.getContext('2d') as CanvasRenderingContext2D ;\r\n    context.beginPath();\r\n    // to get a crisp 1 pixel wide line, we need to add 0.5 to the coords\r\n    context.moveTo(xStart + 0.5, yStart + 0.5);\r\n    context.lineTo(xEnd + 0.5, yEnd + 0.5);\r\n    context.strokeStyle = color;\r\n    context.stroke();\r\n  };\r\n  \r\n  fillRect(x: number, y: number, width: number, height: number, color: string | CanvasGradient | CanvasPattern) {\r\n    const context = this.getContext('2d') as CanvasRenderingContext2D ;\r\n    context.beginPath();\r\n    context.fillStyle = color;\r\n    context.rect(x, y, width, height);\r\n    context.fill();\r\n  };\r\n  \r\n  drawRect(x: number, y: number, width: number, height: number, color: string | CanvasGradient | CanvasPattern) {\r\n    const context = this.getContext('2d') as CanvasRenderingContext2D ;\r\n    context.beginPath();\r\n    context.strokeStyle = color;\r\n    context.rect(x, y, width, height);\r\n    context.stroke();\r\n  };\r\n  \r\n  formatDate(date: Date) {\r\n    const day = date.getDate();\r\n    const month = date.getMonth() + 1;\r\n    const hours = date.getHours();\r\n    const minutes = date.getMinutes();\r\n    const year = date.getFullYear();\r\n\r\n    return `${(day < 10) ? '0' + day : day}/${(month < 10) ? '0' + month : month}/${year} - ${(hours < 10) ? '0' + hours : hours}:${(minutes < 10) ? '0' + minutes : minutes}`;\r\n  };\r\n  \r\n  roundPriceValue(value: number) {\r\n    if (value > 1.0) return Math.round(value * 100) / 100;\r\n    if (value > 0.001) return Math.round(value * 1000) / 1000;\r\n    if (value > 0.00001) return Math.round(value * 100000) / 100000;\r\n    if (value > 0.0000001) return Math.round(value * 10000000) / 10000000;\r\n    else return Math.round(value * 1000000000) / 1000000000;\r\n  };\r\n  \r\n\r\n}\r\nexport default CandlestickChart;\r\nwindow.customElements.define(\"candlestick-chart\", CandlestickChart);\r\n\r\n// ----\r\n\r\n// {\r\n//   this.canvas = document.getElementById(canvasElementID);\r\n//   this.width = parseInt(this.canvas.width);\r\n//   this.height = parseInt(this.canvas.height);\r\n//   this.context = this.canvas.getContext(\"2d\");\r\n\r\n  // this.canvas.addEventListener( \"mousemove\" , ( e ) => {\r\n  //     this.mouseMove( e );\r\n  // } );\r\n  // this.canvas.addEventListener( \"mouseout\" , ( e ) => {\r\n  //     this.mouseOut( e );\r\n  // } );\r\n\r\n  // this.canvas.style.backgroundColor = \"#252525\";\r\n  // this.context.font = '12px sans-serif';\r\n  // this.gridColor = \"#444444\";\r\n  // this.gridTextColor = \"#aaaaaa\";\r\n  // this.mouseHoverBackgroundColor = \"#eeeeee\";\r\n  // this.mouseHoverTextColor = \"#000000\";\r\n  // this.greenColor = \"#00cc00\";\r\n  // this.redColor = \"#cc0000\";\r\n  // this.greenHoverColor = \"#00ff00\";\r\n  // this.redHoverColor = \"#ff0000\";\r\n\r\n  // this.context.lineWidth = 1;\r\n  // this.candleWidth = 5;\r\n\r\n  // this.marginLeft = 10;\r\n  // this.marginRight = 100;\r\n  // this.marginTop = 10;\r\n  // this.marginBottom = 30;\r\n\r\n  // this.yStart = 0;\r\n  // this.yEnd = 0;\r\n  // this.yRange = 0;\r\n  // this.yPixelRange = this.height-this.marginTop-this.marginBottom;\r\n\r\n  // this.xStart = 0;\r\n  // this.xEnd = 0;\r\n  // this.xRange = 0;\r\n  // this.xPixelRange = this.width-this.marginLeft-this.marginRight;\r\n\r\n  // // these are only approximations, the grid will be divided in a way so the numbers are nice\r\n  // this.xGridCells = 16;\r\n  // this.yGridCells = 16;\r\n\r\n  // thib_drawMouseOverlay = false;\r\n  // this.mousePosition = { x: 0 , y: 0 };\r\n  // this.xMouseHover = 0;\r\n  // this.yMouseHover = 0;\r\n  // this.hoveredCandlestickID = 0;\r\n\r\n  // this.candlesticks = [];\r\n// }\r\n\r\n// pingpoliCandlestickChart.prototype.addCandlestick = function( candlestick )\r\n// {\r\n//     this.candlesticks.push( candlestick );\r\n// }\r\n\r\n// pingpoliCandlestickChart.prototype.mouseMove = function( e )\r\n// {\r\n//     var getMousePos = ( e ) =>\r\n//     {\r\n//         var rect = this.canvas.getBoundingClientRect();\r\n//         return { x: e.clientX-rect.left , y: e.clientY-rect.top };\r\n//     }\r\n//     this.mousePosition = getMousePos( e );\r\n//     this.mousePosition.x += this.candleWidth/2;\r\n//     this.b_drawMouseOverlay = true;\r\n//     if ( this.mousePosition.x < this.marginLeft ) this.b_drawMouseOverlay = false;\r\n//     if ( this.mousePosition.x > this.width-this.marginRight+this.candleWidth ) this.b_drawMouseOverlay = false;\r\n//     if ( this.mousePosition.y > this.height-this.marginBottom ) this.b_drawMouseOverlay = false;\r\n//     if ( this.b_drawMouseOverlay )\r\n//     {\r\n//         this.yMouseHover = this.yToValueCoords( this.mousePosition.y );\r\n//         this.xMouseHover = this.xToValueCoords( this.mousePosition.x );\r\n//         // snap to candlesticks\r\n//         var candlestickDelta = this.candlesticks[1].timestamp-this.candlesticks[0].timestamp;\r\n//         this.hoveredCandlestickID = Math.floor((this.xMouseHover-this.candlesticks[0].timestamp)/candlestickDelta);\r\n//         this.xMouseHover = Math.floor(this.xMouseHover/candlestickDelta)*candlestickDelta;\r\n//         this.mousePosition.x = this.xToPixelCoords( this.xMouseHover );\r\n//         this.draw();\r\n//     }\r\n//     else this.draw();\r\n// }\r\n\r\n// pingpoliCandlestickChart.prototype.mouseOut = function( e )\r\n// {\r\n//     this.b_drawMouseOverlay = false;\r\n//     this.draw();\r\n// }\r\n\r\n// pingpoliCandlestickChart.prototype.draw = function()\r\n// {\r\n// \t// clear background\r\n// \tthis.context.clearRect( 0 , 0 , this.width , this.height );\r\n\r\n//     this.calculateYRange();\r\n//     this.calculateXRange();\r\n\r\n//     this.drawGrid();\r\n\r\n//     this.candleWidth = this.xPixelRange/this.candlesticks.length;\r\n//     this.candleWidth--;\r\n//     if ( this.candleWidth%2 == 0 ) this.candleWidth--;\r\n\r\n//     for ( var i = 0 ; i < this.candlesticks.length ; ++i )\r\n//     {\r\n//         var color = ( this.candlesticks[i].close > this.candlesticks[i].open ) ? this.greenColor : this.redColor;\r\n\r\n//         if ( i == this.hoveredCandlestickID )\r\n//         {\r\n//             if ( color == this.greenColor ) color = this.greenHoverColor;\r\n//             else if ( color == this.redColor ) color = this.redHoverColor;\r\n//         }\r\n\r\n//         // draw the wick\r\n//         this.drawLine( this.xToPixelCoords( this.candlesticks[i].timestamp ) , this.yToPixelCoords( this.candlesticks[i].low ) , this.xToPixelCoords( this.candlesticks[i].timestamp ) , this.yToPixelCoords( this.candlesticks[i].high ) , color );\r\n\r\n//         // draw the candle\r\n//         this.fillRect( this.xToPixelCoords( this.candlesticks[i].timestamp )-Math.floor( this.candleWidth/2 ) , this.yToPixelCoords( this.candlesticks[i].open ) , this.candleWidth , this.yToPixelCoords( this.candlesticks[i].close ) - this.yToPixelCoords( this.candlesticks[i].open ) , color );\r\n//     }\r\n\r\n//     // draw mouse hover\r\n//     if ( this.b_drawMouseOverlay )\r\n//     {\r\n//         // price line\r\n//         this.context.setLineDash( [5,5] );\r\n//         this.drawLine( 0 , this.mousePosition.y , this.width , this.mousePosition.y , this.mouseHoverBackgroundColor );\r\n//         this.context.setLineDash( [] );\r\n//         var str = this.roundPriceValue( this.yMouseHover );\r\n//         var textWidth = this.context.measureText( str ).width;\r\n//         this.fillRect( this.width-70 , this.mousePosition.y-10 , 70 , 20 , this.mouseHoverBackgroundColor );\r\n//         this.context.fillStyle = this.mouseHoverTextColor;\r\n//         this.context.fillText( str , this.width-textWidth-5 , this.mousePosition.y+5 );\r\n\r\n//         // time line\r\n//         this.context.setLineDash( [5,5] );\r\n//         this.drawLine( this.mousePosition.x , 0 , this.mousePosition.x , this.height , this.mouseHoverBackgroundColor );\r\n//         this.context.setLineDash( [] );\r\n//         str = this.formatDate( new Date( this.xMouseHover ) );\r\n//         textWidth = this.context.measureText( str ).width;\r\n//         this.fillRect( this.mousePosition.x-textWidth/2-5 , this.height-20 , textWidth+10 , 20 , this.mouseHoverBackgroundColor );\r\n//         this.context.fillStyle = this.mouseHoverTextColor;\r\n//         this.context.fillText( str , this.mousePosition.x-textWidth/2 , this.height-5 );\r\n\r\n//         // data\r\n//         var yPos = this.mousePosition.y-95;\r\n//         if ( yPos < 0 ) yPos = this.mousePosition.y+15;\r\n\r\n//         this.fillRect( this.mousePosition.x+15 , yPos , 100 , 80 , this.mouseHoverBackgroundColor );\r\n//         var color = ( this.candlesticks[this.hoveredCandlestickID].close > this.candlesticks[this.hoveredCandlestickID].open ) ? this.greenColor : this.redColor;\r\n//         this.fillRect( this.mousePosition.x+15 , yPos , 10 , 80 , color );\r\n//         this.context.lineWidth = 2;\r\n//         this.drawRect( this.mousePosition.x+15 , yPos , 100 , 80 , color );\r\n//         this.context.lineWidth = 1;\r\n\r\n//         this.context.fillStyle = this.mouseHoverTextColor;\r\n//         this.context.fillText( \"O: \"+this.candlesticks[this.hoveredCandlestickID].open , this.mousePosition.x+30 , yPos+15 );\r\n//         this.context.fillText( \"C: \"+this.candlesticks[this.hoveredCandlestickID].close , this.mousePosition.x+30 , yPos+35 );\r\n//         this.context.fillText( \"H: \"+this.candlesticks[this.hoveredCandlestickID].high , this.mousePosition.x+30 , yPos+55 );\r\n//         this.context.fillText( \"L: \"+this.candlesticks[this.hoveredCandlestickID].low , this.mousePosition.x+30 , yPos+75 );\r\n//     }\r\n// }\r\n\r\n// pingpoliCandlestickChart.prototype.drawGrid = function () {\r\n//   // roughly divide the yRange into cells\r\n//   var yGridSize = this.yRange / this.yGridCells;\r\n\r\n//   // try to find a nice number to round to\r\n//   var niceNumber = Math.pow(10, Math.ceil(Math.log10(yGridSize)));\r\n//   if (yGridSize < 0.25 * niceNumber) niceNumber = 0.25 * niceNumber;\r\n//   else if (yGridSize < 0.5 * niceNumber) niceNumber = 0.5 * niceNumber;\r\n\r\n//   // find next largest nice number above yStart\r\n//   var yStartRoundNumber = Math.ceil(this.yStart / niceNumber) * niceNumber;\r\n//   // find next lowest nice number below yEnd\r\n//   var yEndRoundNumber = Math.floor(this.yEnd / niceNumber) * niceNumber;\r\n\r\n//   for (var y = yStartRoundNumber; y <= yEndRoundNumber; y += niceNumber) {\r\n//     this.drawLine(\r\n//       0,\r\n//       this.yToPixelCoords(y),\r\n//       this.width,\r\n//       this.yToPixelCoords(y),\r\n//       this.gridColor\r\n//     );\r\n//     var textWidth = this.context.measureText(this.roundPriceValue(y)).width;\r\n//     this.context.fillStyle = this.gridTextColor;\r\n//     this.context.fillText(\r\n//       this.roundPriceValue(y),\r\n//       this.width - textWidth - 5,\r\n//       this.yToPixelCoords(y) - 5\r\n//     );\r\n//   }\r\n\r\n//   // roughly divide the xRange into cells\r\n//   var xGridSize = this.xRange / this.xGridCells;\r\n\r\n//   // try to find a nice number to round to\r\n//   niceNumber = Math.pow(10, Math.ceil(Math.log10(xGridSize)));\r\n//   if (xGridSize < 0.25 * niceNumber) niceNumber = 0.25 * niceNumber;\r\n//   else if (xGridSize < 0.5 * niceNumber) niceNumber = 0.5 * niceNumber;\r\n\r\n//   // find next largest nice number above yStart\r\n//   var xStartRoundNumber = Math.ceil(this.xStart / niceNumber) * niceNumber;\r\n//   // find next lowest nice number below yEnd\r\n//   var xEndRoundNumber = Math.floor(this.xEnd / niceNumber) * niceNumber;\r\n\r\n//   // if the total x range is more than 5 days, format the timestamp as date instead of hours\r\n//   var b_formatAsDate = false;\r\n//   if (this.xRange > 60 * 60 * 24 * 1000 * 5) b_formatAsDate = true;\r\n\r\n//   for (var x = xStartRoundNumber; x <= xEndRoundNumber; x += niceNumber) {\r\n//     this.drawLine(\r\n//       this.xToPixelCoords(x),\r\n//       0,\r\n//       this.xToPixelCoords(x),\r\n//       this.height,\r\n//       this.gridColor\r\n//     );\r\n//     var date = new Date(x);\r\n//     var dateStr = \"\";\r\n//     if (b_formatAsDate) {\r\n//       var day = date.getDate();\r\n//       if (day < 10) day = \"0\" + day;\r\n//       var month = date.getMonth() + 1;\r\n//       if (month < 10) month = \"0\" + month;\r\n//       dateStr = day + \".\" + month;\r\n//     } else {\r\n//       var minutes = date.getMinutes();\r\n//       if (minutes < 10) minutes = \"0\" + minutes;\r\n//       dateStr = date.getHours() + \":\" + minutes;\r\n//     }\r\n//     this.context.fillStyle = this.gridTextColor;\r\n//     this.context.fillText(dateStr, this.xToPixelCoords(x) + 5, this.height - 5);\r\n//   }\r\n// };\r\n\r\n// pingpoliCandlestickChart.prototype.calculateYRange = function () {\r\n//   for (var i = 0; i < this.candlesticks.length; ++i) {\r\n//     if (i == 0) {\r\n//       this.yStart = this.candlesticks[i].low;\r\n//       this.yEnd = this.candlesticks[i].high;\r\n//     } else {\r\n//       if (this.candlesticks[i].low < this.yStart) {\r\n//         this.yStart = this.candlesticks[i].low;\r\n//       }\r\n//       if (this.candlesticks[i].high > this.yEnd) {\r\n//         this.yEnd = this.candlesticks[i].high;\r\n//       }\r\n//     }\r\n//   }\r\n//   this.yRange = this.yEnd - this.yStart;\r\n// };\r\n\r\n// pingpoliCandlestickChart.prototype.calculateXRange = function () {\r\n//   this.xStart = this.candlesticks[0].timestamp;\r\n//   this.xEnd = this.candlesticks[this.candlesticks.length - 1].timestamp;\r\n//   this.xRange = this.xEnd - this.xStart;\r\n// };\r\n\r\n// pingpoliCandlestickChart.prototype.yToPixelCoords = function (y) {\r\n//   return (\r\n//     this.height -\r\n//     this.marginBottom -\r\n//     ((y - this.yStart) * this.yPixelRange) / this.yRange\r\n//   );\r\n// };\r\n\r\n// pingpoliCandlestickChart.prototype.xToPixelCoords = function (x) {\r\n//   return this.marginLeft + ((x - this.xStart) * this.xPixelRange) / this.xRange;\r\n// };\r\n\r\n// pingpoliCandlestickChart.prototype.yToValueCoords = function (y) {\r\n//   return (\r\n//     this.yStart +\r\n//     ((this.height - this.marginBottom - y) * this.yRange) / this.yPixelRange\r\n//   );\r\n// };\r\n\r\n// pingpoliCandlestickChart.prototype.xToValueCoords = function (x) {\r\n//   return this.xStart + ((x - this.marginLeft) * this.xRange) / this.xPixelRange;\r\n// };\r\n\r\n// pingpoliCandlestickChart.prototype.drawLine = function (\r\n//   xStart,\r\n//   yStart,\r\n//   xEnd,\r\n//   yEnd,\r\n//   color\r\n// ) {\r\n//   this.context.beginPath();\r\n//   // to get a crisp 1 pixel wide line, we need to add 0.5 to the coords\r\n//   this.context.moveTo(xStart + 0.5, yStart + 0.5);\r\n//   this.context.lineTo(xEnd + 0.5, yEnd + 0.5);\r\n//   this.context.strokeStyle = color;\r\n//   this.context.stroke();\r\n// };\r\n\r\n// pingpoliCandlestickChart.prototype.fillRect = function (\r\n//   x,\r\n//   y,\r\n//   width,\r\n//   height,\r\n//   color\r\n// ) {\r\n//   this.context.beginPath();\r\n//   this.context.fillStyle = color;\r\n//   this.context.rect(x, y, width, height);\r\n//   this.context.fill();\r\n// };\r\n\r\n// pingpoliCandlestickChart.prototype.drawRect = function (\r\n//   x,\r\n//   y,\r\n//   width,\r\n//   height,\r\n//   color\r\n// ) {\r\n//   this.context.beginPath();\r\n//   this.context.strokeStyle = color;\r\n//   this.context.rect(x, y, width, height);\r\n//   this.context.stroke();\r\n// };\r\n\r\n// pingpoliCandlestickChart.prototype.formatDate = function (date) {\r\n//   var day = date.getDate();\r\n//   if (day < 10) day = \"0\" + day;\r\n//   var month = date.getMonth() + 1;\r\n//   if (month < 10) month = \"0\" + month;\r\n//   var hours = date.getHours();\r\n//   if (hours < 10) hours = \"0\" + hours;\r\n//   var minutes = date.getMinutes();\r\n//   if (minutes < 10) minutes = \"0\" + minutes;\r\n//   return (\r\n//     day + \".\" + month + \".\" + date.getFullYear() + \" - \" + hours + \":\" + minutes\r\n//   );\r\n// };\r\n\r\n// pingpoliCandlestickChart.prototype.roundPriceValue = function (value) {\r\n//   if (value > 1.0) return Math.round(value * 100) / 100;\r\n//   if (value > 0.001) return Math.round(value * 1000) / 1000;\r\n//   if (value > 0.00001) return Math.round(value * 100000) / 100000;\r\n//   if (value > 0.0000001) return Math.round(value * 10000000) / 10000000;\r\n//   else return Math.round(value * 1000000000) / 1000000000;\r\n// };\r\n"],"mappings":"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,CAAC6D,KAAK,CAACD,KAAK,GAAG,QAAQ,CAAC,GAAG,QAAQ,CAAC,KACjE,OAAO5D,IAAI,CAAC6D,KAAK,CAACD,KAAK,GAAG,UAAU,CAAC,GAAG,UAAU;EACzD;AAGF;AACA,eAAe5H,gBAAgB;AAC/B8H,MAAM,CAACC,cAAc,CAACC,MAAM,CAAC,mBAAmB,EAAEhI,gBAAgB,CAAC;;AAEnE;;AAEA;AACA;AACA;AACA;AACA;;AAEE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}