{"ast":null,"code":"/**\r\n * DateAxis module\r\n */\nimport { __assign, __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\nimport { ValueAxis, ValueAxisDataItem } from \"./ValueAxis\";\nimport { List } from \"../../core/utils/List\";\nimport { Dictionary } from \"../../core/utils/Dictionary\";\nimport { DateAxisBreak } from \"./DateAxisBreak\";\nimport { registry } from \"../../core/Registry\";\nimport * as $time from \"../../core/utils/Time\";\nimport * as $type from \"../../core/utils/Type\";\nimport * as $iter from \"../../core/utils/Iterator\";\nimport * as $math from \"../../core/utils/Math\";\nimport * as $array from \"../../core/utils/Array\";\nimport * as $object from \"../../core/utils/Object\";\nimport * as $utils from \"../../core/utils/Utils\";\nimport { OrderedListTemplate } from \"../../core/utils/SortedList\";\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * Defines data item for [[DateAxis]].\r\n *\r\n * @see {@link DataItem}\r\n */\nvar DateAxisDataItem = /** @class */function (_super) {\n  __extends(DateAxisDataItem, _super);\n  /**\r\n   * Constructor\r\n   */\n  function DateAxisDataItem() {\n    var _this = _super.call(this) || this;\n    _this.className = \"DateAxisDataItem\";\n    _this.applyTheme();\n    _this.values.date = {};\n    _this.values.endDate = {};\n    return _this;\n  }\n  Object.defineProperty(DateAxisDataItem.prototype, \"date\", {\n    /**\r\n     * @return Date\r\n     */\n    get: function () {\n      return this.dates[\"date\"];\n    },\n    /**\r\n     * Date position of the data item.\r\n     *\r\n     * @param date  Date\r\n     */\n    set: function (date) {\n      this.setDate(\"date\", date);\n      this.value = date.getTime();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxisDataItem.prototype, \"endDate\", {\n    /**\r\n     * @return End date\r\n     */\n    get: function () {\n      return this.dates[\"endDate\"];\n    },\n    /**\r\n     * End date for data item.\r\n     *\r\n     * @param date End date\r\n     */\n    set: function (date) {\n      this.setDate(\"endDate\", date);\n      this.endValue = date.getTime();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return DateAxisDataItem;\n}(ValueAxisDataItem);\nexport { DateAxisDataItem };\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * Used to create a date/time-based axis for the chart.\r\n *\r\n * ```TypeScript\r\n * // Create the axis\r\n * let xAxis = chart.xAxes.push(new am4charts.DateAxis());\r\n *\r\n * // Set settings\r\n * xAxis.title.text = \"Time\";\r\n * ```\r\n * ```JavaScript\r\n * // Create the axis\r\n * var valueAxis = chart.xAxes.push(new am4charts.DateAxis());\r\n *\r\n * // Set settings\r\n * valueAxis.title.text = \"Time\";\r\n * ```\r\n * ```JSON\r\n * \"xAxes\": [{\r\n *   \"type\": \"DateAxis\",\r\n *   \"title\": {\r\n *     \"text\": \"Time\"\r\n *   }\r\n * }]\r\n * ```\r\n *\r\n * @see {@link IDateAxisEvents} for a list of available Events\r\n * @see {@link IDateAxisAdapters} for a list of available Adapters\r\n * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/date-axis/} got `DateAxis` documention\r\n * @important\r\n */\nvar DateAxis = /** @class */function (_super) {\n  __extends(DateAxis, _super);\n  /**\r\n   * Constructor\r\n   */\n  function DateAxis() {\n    var _this =\n    // Init\n    _super.call(this) || this;\n    _this._gapBreaks = false;\n    /**\r\n     * A list of date/time intervals for Date axis.\r\n     *\r\n     * This define various granularities available for the axis. For example\r\n     * if you have an axis spanning an hour, and space for 6 grid lines / labels\r\n     * the axis will choose the granularity of 10 minutes, displaying a label\r\n     * every 10 minutes.\r\n     *\r\n     * Default intervals:\r\n     *\r\n     * ```JSON\r\n     * [\r\n     *  { timeUnit: \"millisecond\", count: 1 },\r\n     *  { timeUnit: \"millisecond\", count: 5 },\r\n     *  { timeUnit: \"millisecond\", count: 10 },\r\n     *  { timeUnit: \"millisecond\", count: 50 },\r\n     *  { timeUnit: \"millisecond\", count: 100 },\r\n     *  { timeUnit: \"millisecond\", count: 500 },\r\n     *  { timeUnit: \"second\", count: 1 },\r\n     *  { timeUnit: \"second\", count: 5 },\r\n     *  { timeUnit: \"second\", count: 10 },\r\n     *  { timeUnit: \"second\", count: 30 },\r\n     *  { timeUnit: \"minute\", count: 1 },\r\n     *  { timeUnit: \"minute\", count: 5 },\r\n     *  { timeUnit: \"minute\", count: 10 },\r\n     *  { timeUnit: \"minute\", count: 30 },\r\n     *  { timeUnit: \"hour\", count: 1 },\r\n     *  { timeUnit: \"hour\", count: 3 },\r\n     *  { timeUnit: \"hour\", count: 6 },\r\n     *  { timeUnit: \"hour\", count: 12 },\r\n     *  { timeUnit: \"day\", count: 1 },\r\n     *  { timeUnit: \"day\", count: 2 },\r\n     *  { timeUnit: \"day\", count: 3 },\r\n     *  { timeUnit: \"day\", count: 4 },\r\n     *  { timeUnit: \"day\", count: 5 },\r\n     *  { timeUnit: \"week\", count: 1 },\r\n     *  { timeUnit: \"month\", count: 1 },\r\n     *  { timeUnit: \"month\", count: 2 },\r\n     *  { timeUnit: \"month\", count: 3 },\r\n     *  { timeUnit: \"month\", count: 6 },\r\n     *  { timeUnit: \"year\", count: 1 },\r\n     *  { timeUnit: \"year\", count: 2 },\r\n     *  { timeUnit: \"year\", count: 5 },\r\n     *  { timeUnit: \"year\", count: 10 },\r\n     *  { timeUnit: \"year\", count: 50 },\r\n     *  { timeUnit: \"year\", count: 100 }\r\n     * ]\r\n     * ```\r\n     */\n    _this.gridIntervals = new List();\n    /**\r\n     * If data aggregation is enabled by setting Axis' `groupData = true`, the\r\n     * chart will try to aggregate data items into grouped data items.\r\n     *\r\n     * If there are more data items in selected period than `groupCount`, it will\r\n     * group data items into bigger period.\r\n     *\r\n     * For example seconds might be grouped into 10-second aggregate data items.\r\n     *\r\n     * This setting indicates what group intervals can the chart group to.\r\n     *\r\n     * Default intervals:\r\n     *\r\n     * ```JSON\r\n     * [\r\n     *   { timeUnit: \"millisecond\", count: 1},\r\n     *   { timeUnit: \"millisecond\", count: 10 },\r\n     *   { timeUnit: \"millisecond\", count: 100 },\r\n     *   { timeUnit: \"second\", count: 1 },\r\n     *   { timeUnit: \"second\", count: 10 },\r\n     *   { timeUnit: \"minute\", count: 1 },\r\n     *   { timeUnit: \"minute\", count: 10 },\r\n     *   { timeUnit: \"hour\", count: 1 },\r\n     *   { timeUnit: \"day\", count: 1 },\r\n     *   { timeUnit: \"week\", count: 1 },\r\n     *   { timeUnit: \"month\", count: 1 },\r\n     *   { timeUnit: \"year\", count: 1 }\r\n     * ]\r\n     * ```\r\n     * `groupData = true` does not work in combination with `skipEmptyPeriods = true`.\r\n     *\r\n     * @since 4.7.0\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/date-axis/#Dynamic_data_item_grouping} for more information about dynamic data item grouping.\r\n     */\n    _this.groupIntervals = new List();\n    /**\r\n     * A collection of date formats to use when formatting different time units\r\n     * on Date/time axis.\r\n     *\r\n     * Actual defaults will depend on the language locale set for the chart.\r\n     *\r\n     * To override format for a specific time unit, say days, you need to set\r\n     * the appropriate key to a format string. E.g.:\r\n     *\r\n     * ```TypeScript\r\n     * axis.dateFormats.setKey(\"day\", \"MMMM d, yyyy\");\r\n     * ```\r\n     * ```JavaScript\r\n     * axis.dateFormats.setKey(\"day\", \"MMMM d, yyyy\");\r\n     * ```\r\n     * ```JSON\r\n     * \"xAxes\": [{\r\n     *   \"type\": \"DateAxis\",\r\n     *   \"dateFormats\": {\r\n     *     \"day\": \"MMMM d, yyyy\"\r\n     *   }\r\n     * }]\r\n     * ```\r\n     *\r\n     * @see {@link DateFormatter}\r\n     */\n    _this.dateFormats = new Dictionary();\n    /**\r\n     * These formats are applied to labels that are first in a larger unit.\r\n     *\r\n     * For example, if we have a DateAxis with days on it, the first day of month\r\n     * indicates a break in month - a start of the bigger period.\r\n     *\r\n     * For those labels, `periodChangeDateFormats` are applied instead of\r\n     * `dateFormats`.\r\n     *\r\n     * This allows us implement convenient structures, like instead of:\r\n     *\r\n     * `Jan 1 - Jan 2 - Jan 3 - ...`\r\n     *\r\n     * We can have:\r\n     *\r\n     * `Jan - 1 - 2 - 3 - ...`\r\n     *\r\n     * This can be disabled by setting `markUnitChange = false`.\r\n     */\n    _this.periodChangeDateFormats = new Dictionary();\n    /**\r\n     * Actual interval (granularity) derived from the actual data.\r\n     */\n    _this._baseIntervalReal = {\n      timeUnit: \"day\",\n      count: 1\n    };\n    /**\r\n     */\n    _this._prevSeriesTime = {};\n    /**\r\n     * [_minDifference description]\r\n     *\r\n     * @todo Description\r\n     */\n    _this._minDifference = {};\n    /**\r\n     * @ignore\r\n     */\n    _this._firstWeekDay = 1;\n    /**\r\n     * A collection of start timestamps to use as axis' min timestamp for\r\n     * particular data item item periods.\r\n     *\r\n     * @since 4.7.0\r\n     * @readonly\r\n     */\n    _this.groupMin = {};\n    /**\r\n     * A collection of start timestamps to use as axis' max timestamp for\r\n     * particular data item item periods.\r\n     *\r\n     * @since 4.7.0\r\n     * @readonly\r\n     */\n    _this.groupMax = {};\n    _this.className = \"DateAxis\";\n    _this.setPropertyValue(\"markUnitChange\", true);\n    _this.snapTooltip = true;\n    _this.tooltipPosition = \"pointer\";\n    _this.setPropertyValue(\"groupData\", false);\n    _this.groupCount = 200;\n    _this.events.on(\"parentset\", _this.getDFFormatter, _this, false);\n    // Translatable defaults are applied in `applyInternalDefaults()`\n    // ...\n    // Define default intervals\n    _this.gridIntervals.pushAll([{\n      timeUnit: \"millisecond\",\n      count: 1\n    }, {\n      timeUnit: \"millisecond\",\n      count: 5\n    }, {\n      timeUnit: \"millisecond\",\n      count: 10\n    }, {\n      timeUnit: \"millisecond\",\n      count: 50\n    }, {\n      timeUnit: \"millisecond\",\n      count: 100\n    }, {\n      timeUnit: \"millisecond\",\n      count: 500\n    }, {\n      timeUnit: \"second\",\n      count: 1\n    }, {\n      timeUnit: \"second\",\n      count: 5\n    }, {\n      timeUnit: \"second\",\n      count: 10\n    }, {\n      timeUnit: \"second\",\n      count: 30\n    }, {\n      timeUnit: \"minute\",\n      count: 1\n    }, {\n      timeUnit: \"minute\",\n      count: 5\n    }, {\n      timeUnit: \"minute\",\n      count: 10\n    }, {\n      timeUnit: \"minute\",\n      count: 15\n    }, {\n      timeUnit: \"minute\",\n      count: 30\n    }, {\n      timeUnit: \"hour\",\n      count: 1\n    }, {\n      timeUnit: \"hour\",\n      count: 3\n    }, {\n      timeUnit: \"hour\",\n      count: 6\n    }, {\n      timeUnit: \"hour\",\n      count: 12\n    }, {\n      timeUnit: \"day\",\n      count: 1\n    }, {\n      timeUnit: \"day\",\n      count: 2\n    }, {\n      timeUnit: \"day\",\n      count: 3\n    }, {\n      timeUnit: \"day\",\n      count: 4\n    }, {\n      timeUnit: \"day\",\n      count: 5\n    }, {\n      timeUnit: \"week\",\n      count: 1\n    }, {\n      timeUnit: \"month\",\n      count: 1\n    }, {\n      timeUnit: \"month\",\n      count: 2\n    }, {\n      timeUnit: \"month\",\n      count: 3\n    }, {\n      timeUnit: \"month\",\n      count: 6\n    }, {\n      timeUnit: \"year\",\n      count: 1\n    }, {\n      timeUnit: \"year\",\n      count: 2\n    }, {\n      timeUnit: \"year\",\n      count: 5\n    }, {\n      timeUnit: \"year\",\n      count: 10\n    }, {\n      timeUnit: \"year\",\n      count: 50\n    }, {\n      timeUnit: \"year\",\n      count: 100\n    }, {\n      timeUnit: \"year\",\n      count: 200\n    }, {\n      timeUnit: \"year\",\n      count: 500\n    }, {\n      timeUnit: \"year\",\n      count: 1000\n    }, {\n      timeUnit: \"year\",\n      count: 2000\n    }, {\n      timeUnit: \"year\",\n      count: 5000\n    }, {\n      timeUnit: \"year\",\n      count: 10000\n    }, {\n      timeUnit: \"year\",\n      count: 100000\n    }]);\n    _this.groupIntervals.pushAll([{\n      timeUnit: \"millisecond\",\n      count: 1\n    }, {\n      timeUnit: \"millisecond\",\n      count: 10\n    }, {\n      timeUnit: \"millisecond\",\n      count: 100\n    }, {\n      timeUnit: \"second\",\n      count: 1\n    }, {\n      timeUnit: \"second\",\n      count: 10\n    }, {\n      timeUnit: \"minute\",\n      count: 1\n    }, {\n      timeUnit: \"minute\",\n      count: 10\n    }, {\n      timeUnit: \"hour\",\n      count: 1\n    }, {\n      timeUnit: \"day\",\n      count: 1\n    }, {\n      timeUnit: \"week\",\n      count: 1\n    }, {\n      timeUnit: \"month\",\n      count: 1\n    }, {\n      timeUnit: \"year\",\n      count: 1\n    }]);\n    // Set field name\n    _this.axisFieldName = \"date\";\n    // Apply theme\n    _this.applyTheme();\n    return _this;\n  }\n  /**\r\n   * A function which applies fills to axis cells.\r\n   *\r\n   * Default function fills every second fill. You can set this to a function\r\n   * that follows some other logic.\r\n   *\r\n   * Function should accept a [[DateAxisDataItem]] and modify its `axisFill`\r\n   * property accordingly.\r\n   */\n  DateAxis.prototype.fillRule = function (dataItem) {\n    var value = dataItem.value;\n    var axis = dataItem.component;\n    var gridInterval = axis._gridInterval;\n    var gridDuration = $time.getDuration(gridInterval.timeUnit, gridInterval.count);\n    if (Math.round((value - axis.min) / gridDuration) / 2 == Math.round(Math.round((value - axis.min) / gridDuration) / 2)) {\n      dataItem.axisFill.__disabled = true;\n    } else {\n      dataItem.axisFill.__disabled = false;\n    }\n  };\n  /**\r\n   * Sets defaults that instantiate some objects that rely on parent, so they\r\n   * cannot be set in constructor.\r\n   */\n  DateAxis.prototype.applyInternalDefaults = function () {\n    _super.prototype.applyInternalDefaults.call(this);\n    // Set default date formats\n    if (!this.dateFormats.hasKey(\"millisecond\")) {\n      this.dateFormats.setKey(\"millisecond\", this.language.translate(\"_date_millisecond\"));\n    }\n    if (!this.dateFormats.hasKey(\"second\")) {\n      this.dateFormats.setKey(\"second\", this.language.translate(\"_date_second\"));\n    }\n    if (!this.dateFormats.hasKey(\"minute\")) {\n      this.dateFormats.setKey(\"minute\", this.language.translate(\"_date_minute\"));\n    }\n    if (!this.dateFormats.hasKey(\"hour\")) {\n      this.dateFormats.setKey(\"hour\", this.language.translate(\"_date_hour\"));\n    }\n    if (!this.dateFormats.hasKey(\"day\")) {\n      this.dateFormats.setKey(\"day\", this.language.translate(\"_date_day\"));\n    }\n    if (!this.dateFormats.hasKey(\"week\")) {\n      this.dateFormats.setKey(\"week\", this.language.translate(\"_date_day\")); // not a mistake\n    }\n\n    if (!this.dateFormats.hasKey(\"month\")) {\n      this.dateFormats.setKey(\"month\", this.language.translate(\"_date_month\"));\n    }\n    if (!this.dateFormats.hasKey(\"year\")) {\n      this.dateFormats.setKey(\"year\", this.language.translate(\"_date_year\"));\n    }\n    if (!this.periodChangeDateFormats.hasKey(\"millisecond\")) {\n      this.periodChangeDateFormats.setKey(\"millisecond\", this.language.translate(\"_date_millisecond\"));\n    }\n    if (!this.periodChangeDateFormats.hasKey(\"second\")) {\n      this.periodChangeDateFormats.setKey(\"second\", this.language.translate(\"_date_second\"));\n    }\n    if (!this.periodChangeDateFormats.hasKey(\"minute\")) {\n      this.periodChangeDateFormats.setKey(\"minute\", this.language.translate(\"_date_minute\"));\n    }\n    if (!this.periodChangeDateFormats.hasKey(\"hour\")) {\n      this.periodChangeDateFormats.setKey(\"hour\", this.language.translate(\"_date_day\"));\n    }\n    if (!this.periodChangeDateFormats.hasKey(\"day\")) {\n      this.periodChangeDateFormats.setKey(\"day\", this.language.translate(\"_date_day\"));\n    }\n    if (!this.periodChangeDateFormats.hasKey(\"week\")) {\n      this.periodChangeDateFormats.setKey(\"week\", this.language.translate(\"_date_day\"));\n    }\n    if (!this.periodChangeDateFormats.hasKey(\"month\")) {\n      this.periodChangeDateFormats.setKey(\"month\", this.language.translate(\"_date_month\") + \" \" + this.language.translate(\"_date_year\"));\n    }\n  };\n  /**\r\n   * Returns a new/empty [[DataItem]] of the type appropriate for this object.\r\n   *\r\n   * @see {@link DataItem}\r\n   * @return Data Item\r\n   */\n  DateAxis.prototype.createDataItem = function () {\n    return new DateAxisDataItem();\n  };\n  /**\r\n   * Returns a new/empty [[AxisBreak]] of the appropriate type.\r\n   *\r\n   * @return Axis break\r\n   */\n  DateAxis.prototype.createAxisBreak = function () {\n    return new DateAxisBreak();\n  };\n  /**\r\n   * Validates Axis' data items.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  DateAxis.prototype.validateDataItems = function () {\n    // allows to keep selection of the same size\n    var start = this.start;\n    var end = this.end;\n    var baseDuration = this.baseDuration;\n    var periodCount = (this.max - this.min) / baseDuration;\n    this._firstWeekDay = this.getFirstWeekDay();\n    this.getDFFormatter();\n    _super.prototype.validateDataItems.call(this);\n    var mainBaseDuration = $time.getDuration(this.mainBaseInterval.timeUnit, this.mainBaseInterval.count);\n    this.maxZoomFactor = Math.max(1, (this.max - this.min) / mainBaseDuration);\n    this._deltaMinMax = this.baseDuration / 2;\n    // allows to keep selection of the same size\n    var newPeriodCount = (this.max - this.min) / baseDuration;\n    start = start + (end - start) * (1 - periodCount / newPeriodCount);\n    this.zoom({\n      start: start,\n      end: end\n    }, false, true); // added instantlyto solve zoomout problem when we have axes gaps. @todo: check how this affects maxZoomFactor\n  };\n  /**\r\n   * Handles process after zoom.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Does nothing?\r\n   */\n  DateAxis.prototype.handleSelectionExtremesChange = function () {};\n  /**\r\n   * Calculates all positions, related to axis as per current zoom.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  DateAxis.prototype.calculateZoom = function () {\n    var _this = this;\n    _super.prototype.calculateZoom.call(this);\n    var difference = this.adjustDifference(this._minZoomed, this._maxZoomed);\n    var dataSetChanged = false;\n    // if data has to be grouped, choose interval and set dataset\n    if (this.groupData && $type.hasValue(difference)) {\n      var mainBaseInterval = this.mainBaseInterval;\n      var modifiedDifference = difference + (this.startLocation + (1 - this.endLocation)) * this.baseDuration;\n      var groupInterval = void 0;\n      if (this.groupInterval) {\n        groupInterval = __assign({}, this.groupInterval);\n      } else {\n        groupInterval = this.chooseInterval(0, modifiedDifference, this.groupCount, this.groupIntervals);\n        if ($time.getDuration(groupInterval.timeUnit, groupInterval.count) < $time.getDuration(mainBaseInterval.timeUnit, mainBaseInterval.count)) {\n          groupInterval = __assign({}, mainBaseInterval);\n        }\n      }\n      this._groupInterval = groupInterval;\n      var newId = groupInterval.timeUnit + groupInterval.count;\n      if (this._currentDataSetId != newId) {\n        this._currentDataSetId = newId;\n        this.dispatch(\"groupperiodchanged\");\n      }\n      this.series.each(function (series) {\n        if (series.baseAxis == _this) {\n          if (series.setDataSet(_this._currentDataSetId)) {\n            dataSetChanged = true;\n          }\n        }\n      });\n    }\n    var gridInterval = this.chooseInterval(0, difference, this._gridCount);\n    if ($time.getDuration(gridInterval.timeUnit, gridInterval.count) < this.baseDuration) {\n      gridInterval = __assign({}, this.baseInterval);\n    }\n    this._gridInterval = gridInterval;\n    this._nextGridUnit = $time.getNextUnit(gridInterval.timeUnit);\n    // the following is needed to avoid grid flickering while scrolling\n    this._intervalDuration = $time.getDuration(gridInterval.timeUnit, gridInterval.count);\n    this._gridDate = $time.round(new Date(this.minZoomed - $time.getDuration(gridInterval.timeUnit, gridInterval.count)), gridInterval.timeUnit, gridInterval.count, this._firstWeekDay, this._df.utc, new Date(this.min), this._df.timezoneMinutes, this._df.timezone);\n    // tell series start/end\n    $iter.each(this.series.iterator(), function (series) {\n      if (series.baseAxis == _this) {\n        var field_1 = series.getAxisField(_this);\n        var minZoomed = $time.round(new Date(_this._minZoomed + _this.baseDuration * 0.05), _this.baseInterval.timeUnit, _this.baseInterval.count, _this._firstWeekDay, _this._df.utc, undefined, _this._df.timezoneMinutes, _this._df.timezone).getTime();\n        var minZoomedStr = minZoomed.toString();\n        var startDataItem = series.dataItemsByAxis.getKey(_this.uid).getKey(minZoomedStr + series.currentDataSetId);\n        var startIndex = 0;\n        if (_this.start != 0) {\n          if (startDataItem) {\n            startDataItem = _this.findFirst(startDataItem, minZoomed, field_1);\n            startIndex = startDataItem.index;\n          } else {\n            startIndex = series.dataItems.findClosestIndex(_this._minZoomed, function (x) {\n              return x[field_1];\n            }, \"left\");\n          }\n        }\n        // 1 millisecond is removed so that if only first item is selected, it would not count in the second.\n        var baseInterval = _this.baseInterval;\n        var maxZoomed = $time.add($time.round(new Date(_this._maxZoomed), baseInterval.timeUnit, baseInterval.count, _this._firstWeekDay, _this._df.utc, undefined, _this._df.timezoneMinutes, _this._df.timezone), baseInterval.timeUnit, baseInterval.count, _this._df.utc).getTime();\n        var maxZoomedStr = maxZoomed.toString();\n        var endDataItem = series.dataItemsByAxis.getKey(_this.uid).getKey(maxZoomedStr + series.currentDataSetId);\n        var endIndex = series.dataItems.length;\n        if (_this.end != 1) {\n          if (endDataItem) {\n            endIndex = endDataItem.index;\n          } else {\n            maxZoomed -= 1;\n            endIndex = series.dataItems.findClosestIndex(maxZoomed, function (x) {\n              return x[field_1];\n            }, \"right\");\n            // not good - if end is in the gap, indexes go like 5,4,3,4,2,1\n            //if (endIndex < series.dataItems.length) {\n            endIndex++;\n            //}\n          }\n        }\n\n        if (series.max(_this) < minZoomed) {\n          series.startIndex = series.dataItems.length;\n          series.endIndex = series.dataItems.length;\n          series.outOfRange = true;\n        } else if (series.min(_this) > maxZoomed) {\n          series.startIndex = 0;\n          series.endIndex = 0;\n          series.outOfRange = true;\n        } else {\n          series.outOfRange = false;\n          series.startIndex = startIndex;\n          series.endIndex = endIndex;\n        }\n        //\tconsole.log(series.name, startIndex, endIndex);\n        if (!dataSetChanged && series.dataRangeInvalid) {\n          series.validateDataRange();\n        }\n      }\n    });\n  };\n  DateAxis.prototype.findFirst = function (dataItem, time, key) {\n    var index = dataItem.index;\n    if (index > 0) {\n      var series = dataItem.component;\n      var previousDataItem = series.dataItems.getIndex(index - 1);\n      var previousDate = previousDataItem[key];\n      if (!previousDate || previousDate.getTime() < time) {\n        return dataItem;\n      } else {\n        return this.findFirst(previousDataItem, time, key);\n      }\n    } else {\n      return dataItem;\n    }\n  };\n  /**\r\n   * (Re)validates data.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  DateAxis.prototype.validateData = function () {\n    _super.prototype.validateData.call(this);\n    if (!$type.isNumber(this.baseInterval.count)) {\n      this.baseInterval.count = 1;\n    }\n  };\n  Object.defineProperty(DateAxis.prototype, \"minDifference\", {\n    /**\r\n     * @ignore\r\n     */\n    get: function () {\n      var _this = this;\n      var minDifference = Number.MAX_VALUE;\n      this.series.each(function (series) {\n        if (minDifference > _this._minDifference[series.uid]) {\n          minDifference = _this._minDifference[series.uid];\n        }\n      });\n      if (minDifference == Number.MAX_VALUE || minDifference == 0) {\n        minDifference = $time.getDuration(\"day\");\n      }\n      return minDifference;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * [dataChangeUpdate description]\r\n   *\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   */\n  DateAxis.prototype.seriesDataChangeUpdate = function (series) {\n    this._minDifference[series.uid] = Number.MAX_VALUE;\n  };\n  /**\r\n   * [postProcessSeriesDataItems description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   */\n  DateAxis.prototype.postProcessSeriesDataItems = function (series) {\n    var _this = this;\n    this._firstWeekDay = this.getFirstWeekDay();\n    if (series) {\n      this.seriesGroupUpdate(series);\n    } else {\n      this.series.each(function (series) {\n        _this.seriesGroupUpdate(series);\n      });\n    }\n    this.addEmptyUnitsBreaks();\n  };\n  DateAxis.prototype.seriesGroupUpdate = function (series) {\n    var _this = this;\n    if (JSON.stringify(series._baseInterval[this.uid]) != JSON.stringify(this.mainBaseInterval)) {\n      series._baseInterval[this.uid] = this.mainBaseInterval;\n      series.mainDataSet.each(function (dataItem) {\n        _this.postProcessSeriesDataItem(dataItem);\n      });\n      if (this.groupData) {\n        this.groupSeriesData(series);\n      }\n    }\n  };\n  /**\r\n   * Calculates series group data.\r\n   *\r\n   * @param  series  Series\r\n   * @ignore\r\n   */\n  DateAxis.prototype.groupSeriesData = function (series) {\n    var _this = this;\n    if (series.baseAxis == this && series.dataItems.length > 0 && !series.dataGrouped) {\n      series.bulletsContainer.removeChildren();\n      // make array of intervals which will be used;\n      var intervals_1 = [];\n      var mainBaseInterval = this.mainBaseInterval;\n      var mainIntervalDuration_1 = $time.getDuration(mainBaseInterval.timeUnit, mainBaseInterval.count);\n      this.groupIntervals.each(function (interval) {\n        var intervalDuration = $time.getDuration(interval.timeUnit, interval.count);\n        if (intervalDuration > mainIntervalDuration_1 && intervalDuration < _this.max - _this.min || _this.groupInterval) {\n          intervals_1.push(interval);\n        }\n      });\n      if (series._dataSets) {\n        series._dataSets.each(function (key, dataItems) {\n          dataItems.each(function (dataItem) {\n            dataItem.dispose();\n          });\n          dataItems.clear();\n        });\n        series._dataSets.clear();\n      }\n      series.dataGrouped = true;\n      $array.each(intervals_1, function (interval) {\n        //let mainBaseInterval = this._mainBaseInterval;\n        var key = \"date\" + _this.axisLetter;\n        // create data set\n        var dataSetId = interval.timeUnit + interval.count;\n        // todo: check where this clone goes\n        var dataSet = new OrderedListTemplate(series.mainDataSet.template.clone());\n        series.dataSets.setKey(dataSetId, dataSet);\n        var dataItems = series.mainDataSet;\n        var previousTime = Number.NEGATIVE_INFINITY;\n        var i = 0;\n        var newDataItem;\n        var dataFields = [];\n        $object.each(series.dataFields, function (dfkey, df) {\n          var dfk = dfkey;\n          if (dfk != key && dfk.indexOf(\"Show\") == -1) {\n            dataFields.push(dfk);\n          }\n        });\n        var roundedDate;\n        dataItems.each(function (dataItem) {\n          var date = dataItem.getDate(key);\n          if (date) {\n            var time = date.getTime();\n            roundedDate = $time.round(new Date(time), interval.timeUnit, interval.count, _this._df.firstDayOfWeek, _this._df.utc, undefined, _this._df.timezoneMinutes, _this._df.timezone);\n            var currentTime = roundedDate.getTime();\n            // changed period\t\t\t\t\t\t\t\t\n            if (previousTime < currentTime) {\n              if (newDataItem && series._adapterO) {\n                $array.each(dataFields, function (vkey) {\n                  newDataItem.values[vkey].value = series._adapterO.apply(\"groupDataItem\", {\n                    dataItem: newDataItem,\n                    interval: interval,\n                    dataField: vkey,\n                    date: roundedDate,\n                    value: newDataItem.values[vkey].value\n                  }).value;\n                  newDataItem.values[vkey].workingValue = newDataItem.values[vkey].value;\n                });\n              }\n              newDataItem = dataSet.create();\n              newDataItem.dataContext = {};\n              newDataItem.setWorkingLocation(\"dateX\", series.dataItems.template.locations.dateX, 0);\n              newDataItem.setWorkingLocation(\"openDateX\", series.dataItems.template.locations.openDateX, 0);\n              newDataItem.setWorkingLocation(\"dateY\", series.dataItems.template.locations.dateY, 0);\n              newDataItem.setWorkingLocation(\"openDateY\", series.dataItems.template.locations.openDateY, 0);\n              newDataItem.component = series;\n              // other Dates?\n              newDataItem.setDate(key, roundedDate);\n              newDataItem._index = i;\n              i++;\n              $array.each(dataFields, function (vkey) {\n                //let groupFieldName = vkey + \"Group\";\n                var dvalues = dataItem.values[vkey];\n                if (dvalues) {\n                  var value = dvalues.value;\n                  if (series._adapterO) {\n                    value = series._adapterO.apply(\"groupValue\", {\n                      dataItem: dataItem,\n                      interval: interval,\n                      dataField: vkey,\n                      date: roundedDate,\n                      value: value\n                    }).value;\n                  }\n                  var values = newDataItem.values[vkey];\n                  if ($type.isNumber(value)) {\n                    values.value = value;\n                    values.workingValue = value;\n                    values.open = value;\n                    values.close = value;\n                    values.low = value;\n                    values.high = value;\n                    values.sum = value;\n                    values.average = value;\n                    values.count = 1;\n                  } else {\n                    values.count = 0;\n                  }\n                }\n              });\n              _this.postProcessSeriesDataItem(newDataItem, interval);\n              $object.each(series.propertyFields, function (key, fieldValue) {\n                var f = key;\n                var value = dataItem.properties[key];\n                if ($type.hasValue(value)) {\n                  newDataItem.hasProperties = true;\n                  newDataItem.setProperty(f, value);\n                }\n              });\n              newDataItem.groupDataItems = [dataItem];\n              previousTime = currentTime;\n            } else {\n              if (newDataItem) {\n                $array.each(dataFields, function (vkey) {\n                  var groupFieldName = series.groupFields[vkey];\n                  var dvalues = dataItem.values[vkey];\n                  if (dvalues) {\n                    var value = dvalues.value;\n                    if (series._adapterO) {\n                      value = series._adapterO.apply(\"groupValue\", {\n                        dataItem: dataItem,\n                        interval: interval,\n                        dataField: vkey,\n                        date: roundedDate,\n                        value: value\n                      }).value;\n                    }\n                    if ($type.isNumber(value)) {\n                      var values = newDataItem.values[vkey];\n                      if (!$type.isNumber(values.open)) {\n                        values.open = value;\n                      }\n                      values.close = value;\n                      if (values.low > value || !$type.isNumber(values.low)) {\n                        values.low = value;\n                      }\n                      if (values.high < value || !$type.isNumber(values.high)) {\n                        values.high = value;\n                      }\n                      if ($type.isNumber(values.sum)) {\n                        values.sum += value;\n                      } else {\n                        values.sum = value;\n                      }\n                      values.count++;\n                      values.average = values.sum / values.count;\n                      if ($type.isNumber(values[groupFieldName])) {\n                        values.value = values[groupFieldName];\n                        values.workingValue = values.value;\n                      }\n                    }\n                  }\n                });\n                $utils.copyProperties(dataItem.properties, newDataItem.properties);\n                $object.each(series.propertyFields, function (key, fieldValue) {\n                  var f = key;\n                  var value = dataItem.properties[key];\n                  if ($type.hasValue(value)) {\n                    newDataItem.hasProperties = true;\n                    newDataItem.setProperty(f, value);\n                  }\n                });\n                newDataItem.groupDataItems.push(dataItem);\n              }\n            }\n          }\n          if (newDataItem) {\n            $utils.copyProperties(dataItem.dataContext, newDataItem.dataContext);\n          }\n        });\n        if (newDataItem && series._adapterO) {\n          $array.each(dataFields, function (vkey) {\n            newDataItem.values[vkey].value = series._adapterO.apply(\"groupDataItem\", {\n              dataItem: newDataItem,\n              interval: interval,\n              dataField: vkey,\n              date: roundedDate,\n              value: newDataItem.values[vkey].value\n            }).value;\n            newDataItem.values[vkey].workingValue = newDataItem.values[vkey].value;\n          });\n        }\n      });\n      this.calculateZoom();\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n  DateAxis.prototype.getDFFormatter = function () {\n    this._df = this.dateFormatter;\n  };\n  /**\r\n   * [postProcessSeriesDataItem description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param dataItem Data item\r\n   */\n  DateAxis.prototype.postProcessSeriesDataItem = function (dataItem, interval) {\n    var _this = this;\n    // we need to do this for all series data items not only added recently, as baseInterval might change\n    var intervalID = \"\";\n    if (interval) {\n      intervalID = interval.timeUnit + interval.count;\n    } else {\n      interval = this.mainBaseInterval;\n    }\n    var series = dataItem.component;\n    var dataItemsByAxis = series.dataItemsByAxis.getKey(this.uid);\n    $object.each(dataItem.dates, function (key) {\n      var date = dataItem.getDate(key);\n      var time = date.getTime();\n      var startDate = $time.round(new Date(time), interval.timeUnit, interval.count, _this._firstWeekDay, _this._df.utc, undefined, _this._df.timezoneMinutes, _this._df.timezone);\n      var startTime = startDate.getTime();\n      var endDate = $time.add(new Date(startTime), interval.timeUnit, interval.count, _this._df.utc);\n      dataItem.setCalculatedValue(key, startTime, \"open\");\n      dataItem.setCalculatedValue(key, endDate.getTime(), \"close\");\n      dataItemsByAxis.setKey(startTime + intervalID, dataItem);\n    });\n  };\n  /**\r\n   * Collapses empty stretches of date/time scale by creating [[AxisBreak]]\r\n   * elements for them.\r\n   *\r\n   * Can be used to automatically remove strethes without data, like weekends.\r\n   *\r\n   * No, need to call this manually. It will automatically be done if\r\n   * `skipEmptyPeriods = true`.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  DateAxis.prototype.addEmptyUnitsBreaks = function () {\n    var _this = this;\n    if (this.skipEmptyPeriods && $type.isNumber(this.min) && $type.isNumber(this.max)) {\n      var timeUnit = this.baseInterval.timeUnit;\n      var count = this.baseInterval.count;\n      if (this._axisBreaks) {\n        this._axisBreaks.clear(); // TODO: what about breaks added by user?\n      }\n\n      var date = $time.round(new Date(this.min), timeUnit, count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\n      var axisBreak = void 0;\n      var _loop_1 = function () {\n        $time.add(date, timeUnit, count, this_1._df.utc);\n        var startTime = date.getTime();\n        var startTimeStr = startTime.toString();\n        var hasData = $iter.contains(this_1.series.iterator(), function (series) {\n          return !!series.dataItemsByAxis.getKey(_this.uid).getKey(startTimeStr + series.currentDataSetId);\n        });\n        // open break if not yet opened\n        if (!hasData) {\n          if (!axisBreak) {\n            axisBreak = this_1.axisBreaks.create();\n            axisBreak.startDate = new Date(startTime);\n            this_1._gapBreaks = true;\n          }\n        } else {\n          // close if already opened\n          if (axisBreak) {\n            // close at end time minus one millisecond\n            axisBreak.endDate = new Date(startTime - 1);\n            axisBreak = undefined;\n          }\n        }\n      };\n      var this_1 = this;\n      while (date.getTime() < this.max - this.baseDuration) {\n        _loop_1();\n      }\n    }\n  };\n  /**\r\n   * Updates positioning of Axis breaks after something changes.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  DateAxis.prototype.fixAxisBreaks = function () {\n    var _this = this;\n    _super.prototype.fixAxisBreaks.call(this);\n    var axisBreaks = this._axisBreaks;\n    if (axisBreaks) {\n      if (axisBreaks.length > 0) {\n        // process breaks\n        axisBreaks.each(function (axisBreak) {\n          var breakGridCount = Math.ceil(_this._gridCount * (Math.min(_this.end, axisBreak.endPosition) - Math.max(_this.start, axisBreak.startPosition)) / (_this.end - _this.start));\n          axisBreak.gridInterval = _this.chooseInterval(0, axisBreak.adjustedEndValue - axisBreak.adjustedStartValue, breakGridCount);\n          var gridDate = $time.round(new Date(axisBreak.adjustedStartValue), axisBreak.gridInterval.timeUnit, axisBreak.gridInterval.count, _this._firstWeekDay, _this._df.utc, undefined, _this._df.timezoneMinutes, _this._df.timezone);\n          if (gridDate.getTime() > axisBreak.startDate.getTime()) {\n            $time.add(gridDate, axisBreak.gridInterval.timeUnit, axisBreak.gridInterval.count, _this._df.utc);\n          }\n          axisBreak.gridDate = gridDate;\n        });\n      }\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n  DateAxis.prototype.getFirstWeekDay = function () {\n    if (this._df) {\n      return this._df.firstDayOfWeek;\n    }\n    return 1;\n  };\n  /**\r\n   * [getGridDate description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param date           [description]\r\n   * @param intervalCount  [description]\r\n   * @return [description]\r\n   */\n  DateAxis.prototype.getGridDate = function (date, intervalCount) {\n    var timeUnit = this._gridInterval.timeUnit;\n    var realIntervalCount = this._gridInterval.count;\n    // round date\n    $time.round(date, timeUnit, 1, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\n    var prevTimestamp = date.getTime();\n    var newDate = $time.copy(date);\n    // modify date by adding intervalcount\n    var timestamp = $time.add(newDate, timeUnit, intervalCount, this._df.utc).getTime();\n    // if it's axis break, get first rounded date which is not in a break\n    var axisBreak = this.isInBreak(timestamp);\n    if (axisBreak && axisBreak.endDate) {\n      newDate = new Date(axisBreak.endDate.getTime());\n      $time.round(newDate, timeUnit, realIntervalCount, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\n      if (newDate.getTime() < axisBreak.endDate.getTime()) {\n        $time.add(newDate, timeUnit, realIntervalCount, this._df.utc);\n      }\n      timestamp = newDate.getTime();\n    }\n    // get duration between grid lines with break duration removed\n    var durationBreaksRemoved = this.adjustDifference(prevTimestamp, timestamp);\n    // calculate how many time units fit to this duration\n    var countBreaksRemoved = Math.round(durationBreaksRemoved / $time.getDuration(timeUnit));\n    // if less units fit, add one and repeat\n    if (countBreaksRemoved < realIntervalCount) {\n      return this.getGridDate(date, intervalCount + realIntervalCount);\n    }\n    return newDate;\n  };\n  /**\r\n   * [getBreaklessDate description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param axisBreak  [description]\r\n   * @param timeUnit   [description]\r\n   * @param count      [description]\r\n   * @return [description]\r\n   */\n  DateAxis.prototype.getBreaklessDate = function (axisBreak, timeUnit, count) {\n    var date = new Date(axisBreak.endValue);\n    $time.round(date, timeUnit, count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\n    $time.add(date, timeUnit, count, this._df.utc);\n    var timestamp = date.getTime();\n    axisBreak = this.isInBreak(timestamp);\n    if (axisBreak) {\n      return this.getBreaklessDate(axisBreak, timeUnit, count);\n    }\n    return date;\n  };\n  /**\r\n   * (Re)validates all Axis elements.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   */\n  DateAxis.prototype.validateAxisElements = function () {\n    var _this = this;\n    if ($type.isNumber(this.max) && $type.isNumber(this.min)) {\n      this.calculateZoom();\n      // first regular items\n      var timestamp = this._gridDate.getTime();\n      var timeUnit = this._gridInterval.timeUnit;\n      var intervalCount = this._gridInterval.count;\n      var prevGridDate = $time.copy(this._gridDate);\n      var dataItemsIterator_1 = this._dataItemsIterator;\n      this.resetIterators();\n      var _loop_2 = function () {\n        var date = this_2.getGridDate($time.copy(prevGridDate), intervalCount);\n        timestamp = date.getTime();\n        var endDate = $time.copy(date); // you might think it's easier to add intervalduration to timestamp, however it won't work for months or years which are not of the same length\n        endDate = $time.add(endDate, timeUnit, intervalCount, this_2._df.utc);\n        var format = this_2.dateFormats.getKey(timeUnit);\n        if (this_2.markUnitChange && prevGridDate) {\n          if ($time.checkChange(date, prevGridDate, this_2._nextGridUnit, this_2._df.utc)) {\n            if (timeUnit !== \"year\") {\n              format = this_2.periodChangeDateFormats.getKey(timeUnit);\n            }\n          }\n        }\n        var text = this_2._df.format(date, format);\n        var dataItem = dataItemsIterator_1.find(function (x) {\n          return x.text === text;\n        });\n        if (dataItem.__disabled) {\n          dataItem.__disabled = false;\n        }\n        this_2.appendDataItem(dataItem);\n        dataItem.axisBreak = undefined;\n        dataItem.date = date;\n        dataItem.endDate = endDate;\n        dataItem.text = text;\n        this_2.validateDataElement(dataItem);\n        prevGridDate = date;\n      };\n      var this_2 = this;\n      while (timestamp <= this._maxZoomed) {\n        _loop_2();\n      }\n      // breaks later\n      var renderer_1 = this.renderer;\n      if (this._axisBreaks) {\n        $iter.each(this._axisBreaks.iterator(), function (axisBreak) {\n          if (axisBreak.breakSize > 0) {\n            var timeUnit_1 = axisBreak.gridInterval.timeUnit;\n            var intervalCount_1 = axisBreak.gridInterval.count;\n            // only add grid if gap is bigger then minGridDistance\n            if ($math.getDistance(axisBreak.startPoint, axisBreak.endPoint) > renderer_1.minGridDistance * 4) {\n              var timestamp_1 = axisBreak.gridDate.getTime();\n              var prevGridDate_1;\n              var count = 0;\n              var _loop_3 = function () {\n                var date = $time.copy(axisBreak.gridDate);\n                timestamp_1 = $time.add(date, timeUnit_1, intervalCount_1 * count, _this._df.utc).getTime();\n                count++;\n                if (timestamp_1 > axisBreak.adjustedStartValue && timestamp_1 < axisBreak.adjustedEndValue) {\n                  var endDate = $time.copy(date); // you might think it's easier to add intervalduration to timestamp, however it won't work for months or years which are not of the same length\n                  endDate = $time.add(endDate, timeUnit_1, intervalCount_1, _this._df.utc);\n                  var format = _this.dateFormats.getKey(timeUnit_1);\n                  if (_this.markUnitChange && prevGridDate_1) {\n                    if ($time.checkChange(date, prevGridDate_1, _this._nextGridUnit, _this._df.utc)) {\n                      if (timeUnit_1 !== \"year\") {\n                        format = _this.periodChangeDateFormats.getKey(timeUnit_1);\n                      }\n                    }\n                  }\n                  var text_1 = _this._df.format(date, format);\n                  var dataItem = dataItemsIterator_1.find(function (x) {\n                    return x.text === text_1;\n                  });\n                  if (dataItem.__disabled) {\n                    dataItem.__disabled = false;\n                  }\n                  //this.processDataItem(dataItem);\n                  _this.appendDataItem(dataItem);\n                  dataItem.axisBreak = axisBreak;\n                  axisBreak.dataItems.moveValue(dataItem);\n                  dataItem.date = date;\n                  dataItem.endDate = endDate;\n                  dataItem.text = text_1;\n                  prevGridDate_1 = date;\n                  _this.validateDataElement(dataItem);\n                }\n              };\n              while (timestamp_1 <= axisBreak.adjustedMax) {\n                _loop_3();\n              }\n            }\n          }\n        });\n      }\n    }\n  };\n  /**\r\n   * Validates Axis data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param dataItem Data item\r\n   */\n  DateAxis.prototype.validateDataElement = function (dataItem) {\n    dataItem.itemIndex = this._axisItemCount;\n    this._axisItemCount++;\n    if ($type.isNumber(this.max) && $type.isNumber(this.min)) {\n      var renderer = this.renderer;\n      var timestamp = dataItem.value;\n      var endTimestamp = dataItem.endValue;\n      if (!$type.isNumber(endTimestamp)) {\n        endTimestamp = timestamp;\n      }\n      var position = this.valueToPosition(timestamp);\n      var endPosition = this.valueToPosition(endTimestamp);\n      var fillEndPosition = endPosition;\n      if (!dataItem.isRange && this._gridInterval.count > this.baseInterval.count) {\n        endPosition = position + (endPosition - position) / (this._gridInterval.count / this.baseInterval.count);\n      }\n      dataItem.position = position;\n      var tick = dataItem.tick;\n      if (tick && !tick.disabled) {\n        renderer.updateTickElement(tick, position, endPosition);\n      }\n      var grid = dataItem.grid;\n      if (grid && !grid.disabled) {\n        renderer.updateGridElement(grid, position, endPosition);\n      }\n      var fill = dataItem.axisFill;\n      if (fill && !fill.disabled) {\n        renderer.updateFillElement(fill, position, fillEndPosition);\n        if (!dataItem.isRange) {\n          this.fillRule(dataItem);\n        }\n      }\n      var mask = dataItem.mask;\n      if (mask) {\n        renderer.updateFillElement(mask, position, endPosition);\n      }\n      if (dataItem.bullet) {\n        renderer.updateBullet(dataItem.bullet, position, endPosition);\n      }\n      var label = dataItem.label;\n      if (label && !label.disabled) {\n        var location_1 = label.location;\n        if (location_1 == 0) {\n          if (this._gridInterval.count == 1 && this._gridInterval.timeUnit != \"week\" && !dataItem.isRange) {\n            location_1 = 0.5;\n          } else {\n            location_1 = 0;\n          }\n        }\n        renderer.updateLabelElement(label, position, endPosition, location_1);\n      }\n    }\n  };\n  Object.defineProperty(DateAxis.prototype, \"baseDuration\", {\n    /**\r\n     * A duration in milliseconds of the `baseInterval`.\r\n     *\r\n     * @return Duration (ms)\r\n     */\n    get: function () {\n      return $time.getDuration(this.baseInterval.timeUnit, this.baseInterval.count);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Adjusts min/max values.\r\n   *\r\n   * @ignore Exclude from docs.\r\n   * @todo Description (review)\r\n   * @param min  Min timestamp\r\n   * @param max  Max timestamp\r\n   * @return Adjusted min/max step\r\n   */\n  DateAxis.prototype.adjustMinMax = function (min, max) {\n    return {\n      min: min,\n      max: max,\n      step: this.baseDuration\n    };\n  };\n  /**\r\n   * Adjusts the minimum timestamp as per cell start location.\r\n   *\r\n   * @param value  Value\r\n   * @return Adjusted value\r\n   */\n  DateAxis.prototype.fixMin = function (value) {\n    // like this because months are not equal\n    var interval = this.baseInterval;\n    var startTime = $time.round(new Date(value), interval.timeUnit, interval.count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone).getTime();\n    var endTime = $time.add(new Date(startTime), interval.timeUnit, interval.count, this._df.utc).getTime();\n    return startTime + (endTime - startTime) * this.startLocation;\n  };\n  /**\r\n   * Adjusts the maximum timestamp as per cell start location.\r\n   *\r\n   * @param value  Value\r\n   * @return Adjusted value\r\n   */\n  DateAxis.prototype.fixMax = function (value) {\n    // like this because months are not equal\n    var interval = this.baseInterval;\n    var startTime = $time.round(new Date(value), interval.timeUnit, interval.count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone).getTime();\n    var endTime = $time.add(new Date(startTime), interval.timeUnit, interval.count, this._df.utc).getTime();\n    return startTime + (endTime - startTime) * this.endLocation;\n  };\n  /**\r\n   * [chooseInterval description]\r\n   *\r\n   * @ignore Exclude from docs.\r\n   * @todo Description\r\n   * @param index      [description]\r\n   * @param duration   [description]\r\n   * @param gridCount  [description]\r\n   * @return [description]\r\n   */\n  DateAxis.prototype.chooseInterval = function (index, duration, gridCount, intervals) {\n    if (!intervals) {\n      intervals = this.gridIntervals;\n    }\n    var gridInterval = intervals.getIndex(index);\n    var intervalDuration = $time.getDuration(gridInterval.timeUnit, gridInterval.count);\n    var lastIndex = intervals.length - 1;\n    if (index >= lastIndex) {\n      return __assign({}, intervals.getIndex(lastIndex));\n    }\n    var count = Math.ceil(duration / intervalDuration);\n    if (duration < intervalDuration && index > 0) {\n      return __assign({}, intervals.getIndex(index - 1));\n    }\n    if (count <= gridCount) {\n      return __assign({}, intervals.getIndex(index));\n    } else {\n      if (index + 1 < intervals.length) {\n        return this.chooseInterval(index + 1, duration, gridCount, intervals);\n      } else {\n        return __assign({}, intervals.getIndex(index));\n      }\n    }\n  };\n  /**\r\n   * Formats the value according to axis' own [[DateFormatter]].\r\n   *\r\n   * @param value  Source value\r\n   * @return Formatted value\r\n   */\n  DateAxis.prototype.formatLabel = function (value) {\n    return this._df.format(value);\n  };\n  /**\r\n   * Converts a Date to an asbolute pixel position within Axis.\r\n   *\r\n   * @param date  Date\r\n   * @return Position (px)\r\n   */\n  DateAxis.prototype.dateToPosition = function (date) {\n    return this.valueToPosition(date.getTime());\n  };\n  /**\r\n   * Converts a numeric timestamp or a `Date` to a relative position on axis.\r\n   *\r\n   * @param date  Date or a timestamp\r\n   * @return Relative position\r\n   */\n  DateAxis.prototype.anyToPosition = function (date) {\n    if (date instanceof Date) {\n      return this.dateToPosition(date);\n    } else {\n      return this.valueToPosition(date);\n    }\n  };\n  /**\r\n   * Converts date to orientation point (x, y, angle) on axis\r\n   *\r\n   * @param date Date\r\n   * @return IOrientationPoint\r\n   */\n  DateAxis.prototype.dateToPoint = function (date) {\n    var position = this.dateToPosition(date);\n    var point = this.renderer.positionToPoint(position);\n    var angle = this.renderer.positionToAngle(position);\n    return {\n      x: point.x,\n      y: point.y,\n      angle: angle\n    };\n  };\n  /**\r\n   * Converts a numeric value to orientation (x, y, angle) point on axis\r\n   *\r\n   * @param value  Value\r\n   * @return Orientation point\r\n   */\n  DateAxis.prototype.anyToPoint = function (date) {\n    if (date instanceof Date) {\n      return this.dateToPoint(date);\n    } else {\n      return this.valueToPoint(date);\n    }\n  };\n  /**\r\n   * Converts pixel position within Axis to a corresponding Date.\r\n   *\r\n   * @param position  Position (px)\r\n   * @return Date\r\n   */\n  DateAxis.prototype.positionToDate = function (position) {\n    return new Date(this.positionToValue(position));\n  };\n  /**\r\n   * Returns the relative position on axis for series' data item's value.\r\n   *\r\n   * @since 4.5.14\r\n   * @param  dataItem  Data item\r\n   * @param  key       Data field to get value from\r\n   * @param  location  Location (0-1)\r\n   * @return           Relative position\r\n   */\n  DateAxis.prototype.getPositionX = function (dataItem, key, location, stackKey, range) {\n    var value = this.getTimeByLocation(dataItem, key, location);\n    //let stack: number = dataItem.getValue(\"valueX\", \"stack\");\n    if (!$type.isNumber(value)) {\n      value = this.baseValue;\n    }\n    var position = this.valueToPosition(value);\n    if (range) {\n      position = $math.fitToRange(position, range.start, range.end);\n    }\n    return position;\n  };\n  /**\r\n   * Returns relative position on axis for series' data item's value.\r\n   *\r\n   * @since 4.5.14\r\n   * @param  dataItem  Data item\r\n   * @param  key       Data field to get value from\r\n   * @param  location  Location (0-1)\r\n   * @return           Relative position\r\n   */\n  DateAxis.prototype.getPositionY = function (dataItem, key, location, stackKey, range) {\n    var value = this.getTimeByLocation(dataItem, key, location);\n    var stack = dataItem.getValue(\"valueX\", \"stack\");\n    if (!$type.isNumber(value)) {\n      value = this.baseValue;\n    }\n    var position = this.valueToPosition(value + stack);\n    if (range) {\n      position = $math.fitToRange(position, range.start, range.end);\n    }\n    return position;\n  };\n  /**\r\n   * Returns an angle for series data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param dataItem  Data item\r\n   * @param key       Data field to get value from\r\n   * @param location  Location (0-1)\r\n   * @param stackKey  Stack ID\r\n   * @param range Range to fit in\r\n   * @return Angle\r\n   */\n  DateAxis.prototype.getAngle = function (dataItem, key, location, stackKey, range) {\n    var value = this.getTimeByLocation(dataItem, key, location);\n    var stack = dataItem.getValue(stackKey, \"stack\");\n    if (!$type.isNumber(value)) {\n      value = this.baseValue;\n    }\n    var position = this.valueToPosition(value + stack);\n    if (range) {\n      position = $math.fitToRange(position, range.start, range.end);\n    }\n    return this.positionToAngle(position);\n  };\n  /**\r\n   * [getTimeByLocation description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param dataItem  [description]\r\n   * @param key       [description]\r\n   * @param location  [description]\r\n   * @return [description]\r\n   */\n  DateAxis.prototype.getTimeByLocation = function (dataItem, key, location) {\n    if (!$type.hasValue(key)) {\n      return;\n    }\n    if (!$type.isNumber(location)) {\n      location = dataItem.workingLocations[key];\n      if (!$type.isNumber(location)) {\n        location = 0;\n      }\n    }\n    var startTime = dataItem.values[key][\"open\"];\n    var endTime = dataItem.values[key][\"close\"];\n    var workingValue = dataItem.values[key].workingValue;\n    var value = dataItem.values[key].value;\n    var difference = value - workingValue;\n    startTime -= difference;\n    endTime -= difference;\n    if ($type.isNumber(startTime) && $type.isNumber(endTime)) {\n      return startTime + (endTime - startTime) * location;\n    }\n  };\n  /**\r\n   * Processes a related series' data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param dataItem  Data item\r\n   */\n  DateAxis.prototype.processSeriesDataItem = function (dataItem, axisLetter) {\n    var series = dataItem.component;\n    var time;\n    var date = dataItem[\"date\" + axisLetter];\n    if ($type.isNumber(this.timezoneOffset)) {\n      date.setTime(date.getTime() + (date.getTimezoneOffset() - this.timezoneOffset) * 60000);\n      dataItem.setValue(\"date\" + axisLetter, date.getTime(), 0);\n    } else if ($type.hasValue(this.timezone)) {\n      date = $time.setTimezone(date, this.timezone);\n      dataItem.setValue(\"date\" + axisLetter, date.getTime(), 0);\n      dataItem[\"date\" + axisLetter] = date;\n    }\n    if (date) {\n      time = date.getTime();\n    } else {\n      return;\n    }\n    var openDate = dataItem[\"openDate\" + axisLetter];\n    var prevSeriesTime = this._prevSeriesTime[series.uid];\n    var openTime;\n    if (openDate) {\n      openTime = openDate.getTime();\n    }\n    if ($type.isNumber(openTime)) {\n      var difference = Math.abs(time - openTime);\n      if (this._minDifference[series.uid] > difference) {\n        this._minDifference[series.uid] = difference;\n      }\n    }\n    var differece = time - prevSeriesTime;\n    if (differece > 0) {\n      if (this._minDifference[series.uid] > differece) {\n        this._minDifference[series.uid] = differece;\n      }\n    }\n    this._prevSeriesTime[series.uid] = time;\n    if (series._baseInterval[this.uid]) {\n      this.postProcessSeriesDataItem(dataItem);\n    }\n  };\n  /**\r\n   * [updateAxisBySeries description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   */\n  DateAxis.prototype.updateAxisBySeries = function () {\n    _super.prototype.updateAxisBySeries.call(this);\n    var baseInterval = this.chooseInterval(0, this.minDifference, 1);\n    // handle short months\n    if (this.minDifference >= $time.getDuration(\"day\", 27) && baseInterval.timeUnit == \"week\") {\n      baseInterval.timeUnit = \"month\";\n      baseInterval.count = 1;\n    }\n    if (baseInterval.timeUnit == \"month\") {\n      if (this.minDifference >= $time.getDuration(\"day\", 29 * 2) && baseInterval.count == 1) {\n        baseInterval.count = 2;\n      }\n      if (this.minDifference >= $time.getDuration(\"day\", 29 * 3) && baseInterval.count == 2) {\n        baseInterval.count = 3;\n      }\n      if (this.minDifference >= $time.getDuration(\"day\", 29 * 6) && baseInterval.count == 5) {\n        baseInterval.count = 6;\n      }\n    }\n    // handle daylight saving\n    if (this.minDifference >= $time.getDuration(\"hour\", 23) && baseInterval.timeUnit == \"hour\") {\n      baseInterval.timeUnit = \"day\";\n      baseInterval.count = 1;\n    }\n    if (this.minDifference >= $time.getDuration(\"week\", 1) - $time.getDuration(\"hour\", 1) && baseInterval.timeUnit == \"day\") {\n      baseInterval.timeUnit = \"week\";\n      baseInterval.count = 1;\n    }\n    if (this.minDifference >= $time.getDuration(\"year\", 1) - $time.getDuration(\"day\", 1.01) && baseInterval.timeUnit == \"month\") {\n      baseInterval.timeUnit = \"year\";\n      baseInterval.count = 1;\n    }\n    this._baseIntervalReal = baseInterval;\n    this._mainBaseInterval = baseInterval;\n    // no need to invalidate\n  };\n\n  Object.defineProperty(DateAxis.prototype, \"baseInterval\", {\n    /**\r\n     * @return Base interval\r\n     */\n    get: function () {\n      if (this._groupInterval) {\n        return this._groupInterval;\n      } else if (this._baseInterval) {\n        return this._baseInterval;\n      } else {\n        return this._baseIntervalReal;\n      }\n    },\n    /**\r\n     * A base interval (granularity) of data.\r\n     *\r\n     * Used to indicate what are the base units of your data.\r\n     *\r\n     * For example, if you have a data set that has a data point every 5 minutes,\r\n     * you may want to set this to `{ timeUnit: \"minute\", count: 5 }`.\r\n     *\r\n     * If not set, the Axis will try to determine the setting by its own, looking\r\n     * at actual data.\r\n     *\r\n     * For best results, try to follow these values for `count`:\r\n     *\r\n     * When unit is \"month\", use 12 / count = round number\r\n     * When unit is \"hour\", use 24 / count = round number\r\n     * When unit is \"second\" and \"minute\", use 60 / count = round number\r\n     *\r\n     * @param timeInterval base interval\r\n     */\n    set: function (timeInterval) {\n      if (JSON.stringify(this._baseInterval) != JSON.stringify(timeInterval)) {\n        this._baseInterval = timeInterval;\n        this._mainBaseInterval = timeInterval;\n        if (!$type.isNumber(timeInterval.count)) {\n          timeInterval.count = 1;\n        }\n        this.invalidate();\n        this.postProcessSeriesDataItems();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"mainBaseInterval\", {\n    /**\r\n     * Indicates granularity of the data of source (unaggregated) data.\r\n     *\r\n     * @since 4.7.0\r\n     * @return Granularity of the main data set\r\n     */\n    get: function () {\n      if (this._baseInterval) {\n        return this._baseInterval;\n      } else if (this._mainBaseInterval) {\n        return this._mainBaseInterval;\n      } else {\n        return this._baseIntervalReal;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"skipEmptyPeriods\", {\n    /**\r\n     * @return Remove empty stretches of time?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"skipEmptyPeriods\");\n    },\n    /**\r\n     * If enabled, axis will automatically collapse empty (without data points)\r\n     * periods of time, i.e. weekends.\r\n     *\r\n     * An \"empty\" period is considered a stretch of time in the length of current\r\n     * `baseInterval` without a single data point in it.\r\n     *\r\n     * For each such empty period, axis will automatically create an\r\n     * [[AxisBreak]]. By default they will be invisible. You can still configure\r\n     * them by accessing `axis.breaks.template`.\r\n     *\r\n     * [More info about breaks](https://www.amcharts.com/docs/v4/concepts/axes/#Breaks).\r\n     *\r\n     * Important notes:\r\n     * * If you set this property to `true`, you can not add your custom axis breaks to this axis anymore.\r\n     * * Using this feature affects performance. Use only if you need it.\r\n     * * Setting this to `true` will reset appearance of breaks. If you want to modify appearance, do it *after* you set `skipEmptyPeriods`.\r\n     * * Some axis label overlapping might happen.\r\n     * * This setting is not compatible with `groupData = true`.\r\n     *\r\n     * @default false\r\n     * @param value  Remove empty stretches of time?\r\n     */\n    set: function (value) {\n      if (value) {\n        var breakTemplate = this.axisBreaks.template;\n        breakTemplate.startLine.disabled = true;\n        breakTemplate.endLine.disabled = true;\n        breakTemplate.fillShape.disabled = true;\n        breakTemplate.breakSize = 0;\n      } else {\n        if (this._gapBreaks) {\n          this.axisBreaks.clear();\n          this._gapBreaks = false;\n        }\n      }\n      if (this.setPropertyValue(\"skipEmptyPeriods\", value)) {\n        this.invalidate();\n        this.postProcessSeriesDataItems();\n        this.invalidateSeries();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"tooltipDateFormat\", {\n    /**\r\n     * @return Date format\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"tooltipDateFormat\");\n    },\n    /**\r\n     * A special date format to apply axis tooltips.\r\n     *\r\n     * Will use same format as for labels, if not set.\r\n     *\r\n     * @param value  Date format\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"tooltipDateFormat\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"markUnitChange\", {\n    /**\r\n     * @return Use different format for period beginning?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"markUnitChange\");\n    },\n    /**\r\n     * Use `periodChangeDateFormats` to apply different formats to the first\r\n     * label in bigger time unit.\r\n     *\r\n     * @default true\r\n     * @param value  Use different format for period beginning?\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"markUnitChange\", value)) {\n        this.invalidateData();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Returns text to show in a tooltip, based on specific relative position\r\n   * within axis.\r\n   *\r\n   * The label will be formatted as per [[DateFormatter]] set for the whole\r\n   * chart, or explicitly for this Axis.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param position  Position\r\n   * @return Label (formatted date)\r\n   */\n  DateAxis.prototype.getTooltipText = function (position) {\n    var text;\n    var date = this.positionToDate(position);\n    date = $time.round(date, this.baseInterval.timeUnit, this.baseInterval.count, this._firstWeekDay, this._df.utc, new Date(this.min), this._df.timezoneMinutes, this._df.timezone);\n    this.tooltipDate = date;\n    if ($type.hasValue(this.tooltipDateFormat)) {\n      text = this._df.format(date, this.tooltipDateFormat, [\"day\", \"month\", \"week\", \"year\"].indexOf(this.baseInterval.timeUnit) == -1);\n    } else {\n      var dateFormat = this.dateFormats.getKey(this.baseInterval.timeUnit);\n      if (dateFormat) {\n        text = this._df.format(date, dateFormat);\n      } else {\n        text = this.getPositionLabel(position);\n      }\n    }\n    if (!this._adapterO) {\n      return text;\n    } else {\n      return this._adapterO.apply(\"getTooltipText\", text);\n    }\n  };\n  /**\r\n   * Takes an absolute position within axis and adjust it to a specific position within base interval. (cell)\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param position Source position\r\n   * @param location  Location in the cell\r\n   * @return Adjusted position\r\n   */\n  DateAxis.prototype.roundPosition = function (position, location, axisLocation) {\n    var baseInterval = this.baseInterval;\n    var timeUnit = baseInterval.timeUnit;\n    var count = baseInterval.count;\n    var date = this.positionToDate(position);\n    $time.round(date, timeUnit, count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\n    if (location > 0) {\n      $time.add(date, timeUnit, location * count, this._df.utc);\n    }\n    if (axisLocation > 0 && axisLocation < 1) {\n      date.setTime(date.getTime() + this.baseDuration * axisLocation);\n    }\n    if (this.isInBreak(date.getTime())) {\n      while (date.getTime() < this.max) {\n        $time.add(date, timeUnit, count, this._df.utc);\n        if (!this.isInBreak(date.getTime())) {\n          break;\n        }\n      }\n    }\n    return this.dateToPosition(date);\n  };\n  /**\r\n   * Returns an relative position of the start of the cell (period), that specific position value falls into.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param position  Relative position\r\n   * @return Cell start relative position\r\n   */\n  DateAxis.prototype.getCellStartPosition = function (position) {\n    return this.roundPosition(position, 0);\n  };\n  /**\r\n   * Returns an relative position of the end of the cell (period), that specific position value falls into.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param position  Relative position\r\n   * @return Cell end relative position\r\n   */\n  DateAxis.prototype.getCellEndPosition = function (position) {\n    return this.roundPosition(position, 1);\n    //return this.dateToPosition($time.add(this.positionToDate(this.roundPosition(position, 1)), this.baseInterval.timeUnit, this.baseInterval.count));\n  };\n  /**\r\n   * Returns a Series data item that corresponds to the specific pixel position\r\n   * of the Axis.\r\n   *\r\n   * If `findNearest` (third parameter) is set to `true`, the method will try\r\n   * to locate nearest available data item if none is found directly under\r\n   * `position`.\r\n   *\r\n   * @param series       Series\r\n   * @param position     Position (px)\r\n   * @param findNearest  Should axis try to find nearest tooltip if there is no data item at exact position\r\n   * @return Data item\r\n   */\n  DateAxis.prototype.getSeriesDataItem = function (series, position, findNearest) {\n    var value = this.positionToValue(position);\n    var location = 0.5;\n    if (this.axisLetter == \"Y\") {\n      location = series.dataItems.template.locations.dateY;\n    } else {\n      location = series.dataItems.template.locations.dateX;\n    }\n    var deltaValue = value - location * this.baseDuration;\n    var date = $time.round(new Date(value), this.baseInterval.timeUnit, this.baseInterval.count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\n    var nextDate = $time.round(new Date(value + this.baseDuration), this.baseInterval.timeUnit, this.baseInterval.count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\n    if (nextDate.getTime() > date.getTime()) {\n      if (Math.abs(nextDate.getTime() - deltaValue) < Math.abs(deltaValue - date.getTime())) {\n        date = nextDate;\n      }\n    }\n    var dataItemsByAxis = series.dataItemsByAxis.getKey(this.uid);\n    var dataItem = dataItemsByAxis.getKey(date.getTime() + series.currentDataSetId);\n    // todo:  alternatively we can find closiest here\n    if (!dataItem && findNearest) {\n      var key_1;\n      if (this.axisLetter == \"Y\") {\n        key_1 = \"dateY\";\n      } else {\n        key_1 = \"dateX\";\n      }\n      dataItem = series.dataItems.getIndex(series.dataItems.findClosestIndex(date.getTime(), function (x) {\n        if (x[key_1]) {\n          return x[key_1].getTime();\n        } else {\n          return -Infinity;\n        }\n      }, \"any\"));\n    }\n    return dataItem;\n  };\n  /**\r\n   * Returns a formatted date based on position in axis scale.\r\n   *\r\n   * Please note that `position` represents position within axis which may be\r\n   * zoomed and not correspond to Cursor's `position`.\r\n   *\r\n   * To convert Cursor's `position` to Axis' `position` use `toAxisPosition()` method.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v4/tutorials/tracking-cursors-position-via-api/#Tracking_Cursor_s_position} For more information about cursor tracking.\r\n   * @param position  Relative position on axis (0-1)\r\n   * @return Position label\r\n   */\n  DateAxis.prototype.getPositionLabel = function (position) {\n    // @todo Better format recognition\n    var date = this.positionToDate(position);\n    return this._df.format(date, this.getCurrentLabelFormat());\n  };\n  /**\r\n   * Returns label date format based on currently used time units\r\n   *\r\n   * @return Format\r\n   */\n  DateAxis.prototype.getCurrentLabelFormat = function () {\n    return this.dateFormats.getKey(this._gridInterval ? this._gridInterval.timeUnit : \"day\");\n  };\n  /**\r\n   * Initializes an Axis renderer.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  DateAxis.prototype.initRenderer = function () {\n    _super.prototype.initRenderer.call(this);\n    var renderer = this.renderer;\n    if (renderer) {\n      // Set defaults\n      renderer.ticks.template.location = 0;\n      renderer.grid.template.location = 0;\n      renderer.labels.template.location = 0;\n      renderer.baseGrid.disabled = true;\n    }\n  };\n  Object.defineProperty(DateAxis.prototype, \"basePoint\", {\n    /**\r\n     * Coordinates of the actual axis start.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @return Base point\r\n     */\n    get: function () {\n      return {\n        x: 0,\n        y: 0\n      };\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * @ignore\r\n   */\n  DateAxis.prototype.animateMinMax = function (min, max) {\n    var _this = this;\n    var animation = this.animate([{\n      property: \"_minAdjusted\",\n      from: this._minAdjusted,\n      to: min\n    }, {\n      property: \"_maxAdjusted\",\n      from: this._maxAdjusted,\n      to: max\n    }], this.rangeChangeDuration, this.rangeChangeEasing);\n    animation.events.on(\"animationprogress\", function () {\n      _this.dispatch(\"extremeschanged\");\n    });\n    return animation;\n  };\n  /**\r\n   * Invalidates axis data items when series extremes change\r\n   */\n  DateAxis.prototype.handleExtremesChange = function () {\n    _super.prototype.handleExtremesChange.call(this);\n    if (this.groupData) {\n      var id = this.baseInterval.timeUnit + this.baseInterval.count;\n      this.groupMin[id] = this._finalMin;\n      this.groupMax[id] = this._finalMax;\n    }\n  };\n  /**\r\n   * Zooms axis to specific Dates.\r\n   *\r\n   * @param startDate       Start date\r\n   * @param endValue        End date\r\n   * @param skipRangeEvent  Do not invoke events\r\n   * @param instantly       Do not play zoom animations\r\n   */\n  DateAxis.prototype.zoomToDates = function (startDate, endDate, skipRangeEvent, instantly, adjust) {\n    startDate = this._df.parse(startDate);\n    endDate = this._df.parse(endDate);\n    this.zoomToValues(startDate.getTime(), endDate.getTime(), skipRangeEvent, instantly, adjust);\n  };\n  /**\r\n   * Zooms axis to specific values.\r\n   *\r\n   * @param startValue      Start value\r\n   * @param endValue        End value\r\n   * @param skipRangeEvent  Do not invoke events\r\n   * @param instantly       Do not play zoom animations\r\n   */\n  DateAxis.prototype.zoomToValues = function (startValue, endValue, skipRangeEvent, instantly, adjust) {\n    var _this = this;\n    if (!this.groupData) {\n      //let start: number = (startValue - this.min) / (this.max - this.min);\n      //let end: number = (endValue - this.min) / (this.max - this.min);\n      var start = this.valueToPosition(startValue);\n      var end = this.valueToPosition(endValue);\n      this.zoom({\n        start: start,\n        end: end\n      }, skipRangeEvent, instantly);\n    } else {\n      var difference = this.adjustDifference(startValue, endValue);\n      var isEnd = false;\n      if (endValue == this.max) {\n        isEnd = true;\n      }\n      var isStart = false;\n      if (startValue == this.min) {\n        isStart = true;\n      }\n      if ($type.hasValue(difference)) {\n        var mainBaseInterval = this.mainBaseInterval;\n        var groupInterval_1 = this.chooseInterval(0, difference, this.groupCount, this.groupIntervals);\n        if (groupInterval_1.timeUnit == mainBaseInterval.timeUnit && groupInterval_1.count < mainBaseInterval.count || $time.getDuration(groupInterval_1.timeUnit, 1) < $time.getDuration(mainBaseInterval.timeUnit, 1)) {\n          groupInterval_1 = __assign({}, mainBaseInterval);\n        }\n        var id = groupInterval_1.timeUnit + groupInterval_1.count;\n        var min_1 = this.groupMin[id];\n        var max_1 = this.groupMax[id];\n        if (!$type.isNumber(min_1) || !$type.isNumber(max_1)) {\n          min_1 = Number.POSITIVE_INFINITY;\n          max_1 = Number.NEGATIVE_INFINITY;\n          this.series.each(function (series) {\n            var seriesMin = series.min(_this);\n            var seriesMax = series.max(_this);\n            if (series._dataSets) {\n              var ds = series._dataSets.getKey(groupInterval_1.timeUnit + groupInterval_1.count);\n              if (ds) {\n                var mindi = ds.getIndex(0);\n                var maxdi = ds.getIndex(ds.length - 1);\n                if (mindi) {\n                  if (series.xAxis == _this) {\n                    seriesMin = mindi.dateX.getTime();\n                  } else if (series.yAxis == _this) {\n                    seriesMin = mindi.dateY.getTime();\n                  }\n                }\n                if (maxdi) {\n                  if (series.xAxis == _this) {\n                    seriesMax = maxdi.dateX.getTime();\n                  } else if (series.yAxis == _this) {\n                    seriesMax = maxdi.dateY.getTime();\n                  }\n                }\n              }\n            }\n            seriesMax = $time.round($time.add(new Date(seriesMax), groupInterval_1.timeUnit, 1, _this._df.utc), groupInterval_1.timeUnit, 1, _this._df.firstDayOfWeek, _this._df.utc, undefined, _this._df.timezoneMinutes, _this._df.timezone).getTime();\n            if (seriesMin < min_1) {\n              min_1 = seriesMin;\n            }\n            if (seriesMax > max_1) {\n              max_1 = seriesMax;\n            }\n          });\n          this.groupMin[id] = min_1;\n          this.groupMax[id] = max_1;\n        }\n        startValue = $math.fitToRange(startValue, min_1, max_1);\n        endValue = $math.fitToRange(endValue, min_1, max_1);\n        if (adjust) {\n          if (isEnd) {\n            startValue = endValue - difference;\n            startValue = $math.fitToRange(startValue, min_1, max_1);\n          }\n          if (isStart) {\n            endValue = startValue + difference;\n            endValue = $math.fitToRange(endValue, min_1, max_1);\n          }\n        }\n        var start = (startValue - min_1) / (max_1 - min_1);\n        var end = (endValue - min_1) / (max_1 - min_1);\n        this.zoom({\n          start: start,\n          end: end\n        }, skipRangeEvent, instantly);\n      }\n    }\n  };\n  /**\r\n   * Adds `baseInterval` to \"as is\" fields.\r\n   *\r\n   * @param field  Field name\r\n   * @return Assign as is?\r\n   */\n  DateAxis.prototype.asIs = function (field) {\n    return field == \"baseInterval\" || _super.prototype.asIs.call(this, field);\n  };\n  /**\r\n   * Copies all properties and related data from a different instance of Axis.\r\n   *\r\n   * @param source Source Axis\r\n   */\n  DateAxis.prototype.copyFrom = function (source) {\n    var _this = this;\n    _super.prototype.copyFrom.call(this, source);\n    this.dateFormats = source.dateFormats;\n    this.periodChangeDateFormats = source.periodChangeDateFormats;\n    this.groupIntervals.clear();\n    source.groupIntervals.each(function (interval) {\n      _this.groupIntervals.push(__assign({}, interval));\n    });\n    this.gridIntervals.clear();\n    source.gridIntervals.each(function (interval) {\n      _this.gridIntervals.push(__assign({}, interval));\n    });\n    if (source._baseInterval) {\n      this.baseInterval = source._baseInterval;\n    }\n  };\n  /**\r\n   * Shows Axis tooltip at specific relative position within Axis. (0-1)\r\n   *\r\n   * @param position Position (0-1)\r\n   * @param local or global position\r\n   */\n  DateAxis.prototype.showTooltipAtPosition = function (position, local) {\n    var _this = this;\n    if (!local) {\n      position = this.toAxisPosition(position);\n    }\n    if (this.snapTooltip) {\n      // rounding is not good, pen/aac4e7f66f019d36b2447f050c600c13 (no last tootltip shown)\n      var actualDate = this.positionToDate(position); //$time.round(this.positionToDate(position), this.baseInterval.timeUnit, 1, this.getFirstWeekDay(), this.dateFormatter.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\n      var actualTime_1 = actualDate.getTime();\n      var closestDate_1;\n      this.series.each(function (series) {\n        if (series.baseAxis == _this) {\n          var dataItem = _this.getSeriesDataItem(series, position, true);\n          if (dataItem) {\n            var date = void 0;\n            if (series.xAxis == _this) {\n              date = dataItem.dateX;\n            }\n            if (series.yAxis == _this) {\n              date = dataItem.dateY;\n            }\n            if (!closestDate_1) {\n              closestDate_1 = date;\n            } else {\n              if (Math.abs(closestDate_1.getTime() - actualTime_1) > Math.abs(date.getTime() - actualTime_1)) {\n                closestDate_1 = date;\n              }\n            }\n          }\n        }\n      });\n      if (closestDate_1) {\n        var closestTime_1 = closestDate_1.getTime();\n        closestDate_1 = $time.round(new Date(closestTime_1), this.baseInterval.timeUnit, this.baseInterval.count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\n        closestTime_1 = closestDate_1.getTime();\n        var tooltipLocation = this.renderer.tooltipLocation;\n        if (tooltipLocation == 0) {\n          tooltipLocation = 0.0001;\n        }\n        closestDate_1 = new Date(closestDate_1.getTime() + this.baseDuration * tooltipLocation);\n        position = this.dateToPosition(closestDate_1);\n        if (this.chart.cursor && this.chart.cursor.snapToSeries) {\n          //void\n        } else {\n          this.series.each(function (series) {\n            var dataItem = series.dataItemsByAxis.getKey(_this.uid).getKey(closestTime_1 + series.currentDataSetId);\n            var point = series.showTooltipAtDataItem(dataItem);\n            if (point) {\n              _this.chart._seriesPoints.push({\n                series: series,\n                point: point\n              });\n            } else {\n              // check, otherwise column tooltip will be hidden\n              if (series.tooltipText || series.tooltipHTML) {\n                series.hideTooltip();\n              }\n            }\n          });\n        }\n        //this.chart.sortSeriesTooltips(seriesPoints);\n      }\n    }\n\n    _super.prototype.showTooltipAtPosition.call(this, position, true);\n  };\n  Object.defineProperty(DateAxis.prototype, \"snapTooltip\", {\n    /**\r\n     * @return Should snap?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"snapTooltip\");\n    },\n    /**\r\n     * Should the nearest tooltip be shown if no data item is found on the\r\n     * current cursor position.\r\n     *\r\n     * @default true\r\n     * @param value  Should snap?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"snapTooltip\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"groupData\", {\n    /**\r\n     * @return Group data points?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"groupData\");\n    },\n    /**\r\n     * Indicates if data should be aggregated to composide data items if there\r\n     * are more data items in selected range than `groupCount`.\r\n     *\r\n     * Grouping will occur automatically, based on current selection range, and\r\n     * will change dynamically when user zooms in/out the chart.\r\n     *\r\n     * NOTE: This works only if [[DateAxis]] is base axis of an [[XYSeries]].\r\n     *\r\n     * The related [[XYSeries]] also needs to be set up to take advantage of, by\r\n     * setting its [`groupFields`](https://www.amcharts.com/docs/v4/reference/xyseries/#groupFields_property).\r\n     *\r\n     * The group intervals to aggregate data to is defined by `groupIntervals`\r\n     * property.\r\n     *\r\n     * ```TypeScript\r\n     * let dateAxis = chart.xAxes.push(new am4charts.DateAxis());\r\n     * dateAxis.groupData = true;\r\n     *\r\n     * let valueAxis = chart.xAxes.push(new am4charts.valueAxis());\r\n     *\r\n     * let series = chart.series.push(new am4charts.LineSeries());\r\n     * series.dataFields.dateX = \"date\";\r\n     * series.dataFields.valueY = \"value\";\r\n     * series.groupFields.valueY = \"average\";\r\n     * ```\r\n     * ```JavaScript\r\n     * var dateAxis = chart.xAxes.push(new am4charts.DateAxis());\r\n     * dateAxis.groupData = true;\r\n     *\r\n     * var valueAxis = chart.xAxes.push(new am4charts.valueAxis());\r\n     *\r\n     * var series = chart.series.push(new am4charts.LineSeries());\r\n     * series.dataFields.dateX = \"date\";\r\n     * series.dataFields.valueY = \"value\";\r\n     * series.groupFields.valueY = \"average\";\r\n     * ```\r\n     * ```JSON\r\n     * {\r\n     *   // ...\r\n     *   \"xAxes\": [{\r\n     *     \"type\": \"DateAxis\",\r\n     *     \"groupData\": true\r\n     *   }],\r\n     *   \"yAxes\": [{\r\n     *     \"type\": \"ValueAxis\"\r\n     *   }],\r\n     *   \"series\": [{\r\n     *     \"type\": \"LineSeries\",\r\n     *     \"dataFields\": {\r\n     *       \"dateX\": \"date\",\r\n     *       \"valueY\": \"value\"\r\n     *     },\r\n     *     \"groupFields\": {\r\n     *       \"valueY\": \"average\"\r\n     *     }\r\n     *   }]\r\n     * }\r\n     * ```\r\n     *\r\n     * @default false\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/date-axis/#Dynamic_data_item_grouping} for more information about dynamic data item grouping.\r\n     * @since 4.7.0\r\n     * @param  value  Group data points?\r\n     */\n    set: function (value) {\n      var _this = this;\n      if (this.setPropertyValue(\"groupData\", value)) {\n        this.series.each(function (series) {\n          series.setDataSet(\"\");\n          if (value && !series.dataGrouped && series.inited) {\n            series._baseInterval[_this.uid] = _this.mainBaseInterval;\n            _this.groupSeriesData(series);\n          }\n        });\n        this._currentDataSetId = \"\";\n        this._groupInterval = undefined;\n        this.invalidate();\n        this.invalidateSeries();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"groupInterval\", {\n    /**\r\n     * @return Interval\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"groupInterval\");\n    },\n    /**\r\n     * Disables automatic selection of data grouping intervals and always uses\r\n     * `groupInterval` if set. Works only if `groupData = true`.\r\n     *\r\n     * @since 4.9.24\r\n     * @param  value  Interval\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"groupInterval\", value)) {\n        this.invalidate();\n        this.invalidateSeries();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"groupCount\", {\n    /**\r\n     * @return Number of data items\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"groupCount\");\n    },\n    /**\r\n     * Indicates threshold of data items in selected range at which to start\r\n     * aggregating data items if `groupData = true`.\r\n     *\r\n     * @default 200\r\n     * @since 4.7.0\r\n     * @param  value  Number of data items\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"groupCount\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"timezoneOffset\", {\n    /**\r\n     * @todo Timezone offset in minutes\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"timezoneOffset\");\n    },\n    /**\r\n     * If set will recalculate all timestamps in data by applying specific offset\r\n     * in minutes.\r\n     *\r\n     * IMPORTANT: do not set `timezoneOffset` on both `DateAxis` and `dateFormatter`. It\r\n     * will skew your results by applying offset twice.\r\n     *\r\n     * @since 4.8.5\r\n     * @param  value Time zone offset in minutes\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"timezoneOffset\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"timezone\", {\n    /**\r\n     * @return Timezone\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"timezone\");\n    },\n    /**\r\n     * If set will recalculate all timestamps in data to specific named timezone,\r\n     * e.g. `\"America/Vancouver\"`, `\"Australia/Sydney\"`, `\"UTC\"`, etc.\r\n     *\r\n     * IMPORTANT: it is no longer recommended to use this setting. Please\r\n     * set`timezone` on `dateFormatter`.\r\n     *\r\n     * @deprecated\r\n     * @since 4.10.1\r\n     * @param  value Time zone\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"timezone\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"gridInterval\", {\n    /**\r\n     * Current grid interval.\r\n     *\r\n     * @return Grid interval\r\n     */\n    get: function () {\n      return this._gridInterval;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * @ignore\r\n   */\n  DateAxis.prototype.makeGap = function (dataItem, previous) {\n    var series = dataItem.component;\n    if (dataItem && previous) {\n      if (!series.connect && $type.isNumber(series.autoGapCount)) {\n        if (series.baseAxis == this) {\n          var date = dataItem.dates[\"date\" + this.axisLetter];\n          var prevDate = previous.dates[\"date\" + this.axisLetter];\n          if (date && prevDate) {\n            var time = date.getTime();\n            var prevTime = prevDate.getTime();\n            if (time - prevTime > series.autoGapCount * this.baseDuration) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n    return false;\n  };\n  Object.defineProperty(DateAxis.prototype, \"baseValue\", {\n    /**\r\n     * @return base value\r\n     */\n    get: function () {\n      return this.min;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return DateAxis;\n}(ValueAxis);\nexport { DateAxis };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\nregistry.registeredClasses[\"DateAxis\"] = DateAxis;\nregistry.registeredClasses[\"DateAxisDataItem\"] = DateAxisDataItem;","map":{"version":3,"mappings":"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","names":["ValueAxis","ValueAxisDataItem","List","Dictionary","DateAxisBreak","registry","$time","$type","$iter","$math","$array","$object","$utils","OrderedListTemplate","__extends","_super","_this","className","applyTheme","values","date","endDate","Object","DateAxisDataItem","dates","setDate","value","getTime","endValue","timeUnit","count","setPropertyValue","snapTooltip","tooltipPosition","groupCount","events","on","getDFFormatter","gridIntervals","pushAll","groupIntervals","axisFieldName","DateAxis","dataItem","axis","component","gridInterval","_gridInterval","gridDuration","getDuration","Math","round","min","axisFill","__disabled","applyInternalDefaults","dateFormats","hasKey","setKey","language","translate","periodChangeDateFormats","start","end","baseDuration","periodCount","max","_firstWeekDay","getFirstWeekDay","validateDataItems","mainBaseDuration","mainBaseInterval","maxZoomFactor","_deltaMinMax","newPeriodCount","zoom","calculateZoom","difference","adjustDifference","_minZoomed","_maxZoomed","dataSetChanged","groupData","hasValue","modifiedDifference","startLocation","endLocation","groupInterval","chooseInterval","_groupInterval","newId","_currentDataSetId","dispatch","series","each","baseAxis","setDataSet","_gridCount","baseInterval","_nextGridUnit","getNextUnit","_intervalDuration","_gridDate","Date","minZoomed","_df","utc","timezoneMinutes","timezone","iterator","field_1","getAxisField","undefined","minZoomedStr","toString","startDataItem","dataItemsByAxis","getKey","uid","currentDataSetId","startIndex","findFirst","index","dataItems","findClosestIndex","x","maxZoomed","add","maxZoomedStr","endDataItem","endIndex","length","outOfRange","dataRangeInvalid","validateDataRange","time","key","previousDataItem","getIndex","previousDate","validateData","isNumber","minDifference","Number","MAX_VALUE","_minDifference","seriesGroupUpdate","addEmptyUnitsBreaks","JSON","stringify","_baseInterval","mainDataSet","postProcessSeriesDataItem","groupSeriesData","dataGrouped","bulletsContainer","removeChildren","intervals_1","mainIntervalDuration_1","interval","intervalDuration","push","_dataSets","dispose","clear","axisLetter","dataSetId","dataSet","template","clone","dataSets","previousTime","NEGATIVE_INFINITY","i","newDataItem","dataFields","dfkey","df","dfk","indexOf","roundedDate","getDate","firstDayOfWeek","currentTime","_adapterO","vkey","apply","dataField","workingValue","create","dataContext","setWorkingLocation","locations","dateX","openDateX","dateY","openDateY","_index","dvalues","open","close","low","high","sum","average","propertyFields","fieldValue","f","properties","hasProperties","setProperty","groupDataItems","groupFieldName","groupFields","copyProperties","dateFormatter","intervalID","startDate","startTime","setCalculatedValue","skipEmptyPeriods","_axisBreaks","axisBreak","this_1","startTimeStr","hasData","contains","axisBreaks","_gapBreaks","fixAxisBreaks","breakGridCount","ceil","endPosition","startPosition","adjustedEndValue","adjustedStartValue","gridDate","intervalCount","realIntervalCount","prevTimestamp","newDate","copy","timestamp","isInBreak","durationBreaksRemoved","countBreaksRemoved","getGridDate","getBreaklessDate","prevGridDate","dataItemsIterator_1","_dataItemsIterator","resetIterators","this_2","format","markUnitChange","checkChange","text","find","appendDataItem","validateDataElement","renderer_1","renderer","breakSize","timeUnit_1","intervalCount_1","getDistance","startPoint","endPoint","minGridDistance","timestamp_1","prevGridDate_1","text_1","moveValue","adjustedMax","itemIndex","_axisItemCount","endTimestamp","position","valueToPosition","fillEndPosition","isRange","tick","disabled","updateTickElement","grid","updateGridElement","fill","updateFillElement","fillRule","mask","bullet","updateBullet","label","location_1","location","updateLabelElement","step","endTime","duration","gridCount","intervals","lastIndex","dateToPosition","point","positionToPoint","angle","positionToAngle","y","dateToPoint","valueToPoint","positionToValue","stackKey","range","getTimeByLocation","baseValue","fitToRange","stack","getValue","workingLocations","timezoneOffset","setTime","getTimezoneOffset","setValue","setTimezone","openDate","prevSeriesTime","_prevSeriesTime","openTime","abs","differece","updateAxisBySeries","_baseIntervalReal","_mainBaseInterval","timeInterval","invalidate","postProcessSeriesDataItems","getPropertyValue","breakTemplate","startLine","endLine","fillShape","invalidateSeries","invalidateData","positionToDate","tooltipDate","tooltipDateFormat","dateFormat","getPositionLabel","axisLocation","roundPosition","findNearest","deltaValue","nextDate","key_1","Infinity","getCurrentLabelFormat","initRenderer","ticks","labels","baseGrid","animation","animate","property","from","_minAdjusted","to","_maxAdjusted","rangeChangeDuration","rangeChangeEasing","handleExtremesChange","id","groupMin","_finalMin","groupMax","_finalMax","skipRangeEvent","instantly","adjust","parse","zoomToValues","startValue","isEnd","isStart","groupInterval_1","min_1","max_1","POSITIVE_INFINITY","seriesMin","seriesMax","ds","mindi","maxdi","xAxis","yAxis","field","asIs","source","copyFrom","local","toAxisPosition","actualDate","actualTime_1","closestDate_1","getSeriesDataItem","closestTime_1","tooltipLocation","chart","cursor","snapToSeries","showTooltipAtDataItem","_seriesPoints","tooltipText","tooltipHTML","hideTooltip","showTooltipAtPosition","inited","previous","connect","autoGapCount","prevDate","prevTime","registeredClasses"],"sources":["C:\\Users\\Lucian\\Documents\\DEV\\nodejs\\stock-market-api\\dev\\static\\node_modules\\src\\.internal\\charts\\axes\\DateAxis.ts"],"sourcesContent":["/**\r\n * DateAxis module\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { ValueAxis, ValueAxisDataItem, IValueAxisProperties, IValueAxisDataFields, IValueAxisAdapters, IValueAxisEvents } from \"./ValueAxis\";\r\nimport { AxisItemLocation } from \"./Axis\";\r\nimport { AxisRenderer } from \"./AxisRenderer\";\r\nimport { AxisTick } from \"./AxisTick\";\r\nimport { AxisLabel } from \"./AxisLabel\";\r\nimport { AxisFill } from \"./AxisFill\";\r\nimport { List } from \"../../core/utils/List\";\r\nimport { Dictionary } from \"../../core/utils/Dictionary\";\r\nimport { IPoint, IOrientationPoint } from \"../../core/defs/IPoint\";\r\nimport { Grid } from \"./Grid\";\r\nimport { XYSeries, XYSeriesDataItem } from \"../series/XYSeries\";\r\nimport { LineSeriesDataItem } from \"../series/LineSeries\";\r\nimport { TimeUnit } from \"../../core/defs/TimeUnit\";\r\nimport { ITimeInterval } from \"../../core/defs/ITimeInterval\";\r\nimport { IMinMaxStep } from \"./ValueAxis\";\r\nimport { DateAxisBreak } from \"./DateAxisBreak\";\r\nimport { registry } from \"../../core/Registry\";\r\nimport * as $time from \"../../core/utils/Time\";\r\nimport * as $type from \"../../core/utils/Type\";\r\nimport * as $iter from \"../../core/utils/Iterator\";\r\nimport * as $math from \"../../core/utils/Math\";\r\nimport * as $array from \"../../core/utils/Array\";\r\nimport * as $object from \"../../core/utils/Object\";\r\nimport * as $utils from \"../../core/utils/Utils\";\r\nimport { IRange } from \"../../core/defs/IRange\";\r\nimport { DateFormatter } from \"../../core/formatters/DateFormatter\";\r\nimport { OrderedListTemplate } from \"../../core/utils/SortedList\";\r\nimport { Animation } from \"../../core/utils/Animation\";\r\n\r\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines data item for [[DateAxis]].\r\n *\r\n * @see {@link DataItem}\r\n */\r\nexport class DateAxisDataItem extends ValueAxisDataItem {\r\n\r\n\t/**\r\n\t * Defines a type of [[Component]] this data item is used for.\r\n\t */\r\n\tpublic _component!: DateAxis;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"DateAxisDataItem\";\r\n\t\tthis.applyTheme();\r\n\r\n\t\tthis.values.date = {};\r\n\t\tthis.values.endDate = {};\r\n\t}\r\n\r\n\t/**\r\n\t * Date position of the data item.\r\n\t *\r\n\t * @param date  Date\r\n\t */\r\n\tpublic set date(date: Date) {\r\n\t\tthis.setDate(\"date\", date);\r\n\t\tthis.value = date.getTime();\r\n\t}\r\n\r\n\t/**\r\n\t * @return Date\r\n\t */\r\n\tpublic get date(): Date {\r\n\t\treturn this.dates[\"date\"];\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * End date for data item.\r\n\t *\r\n\t * @param date End date\r\n\t */\r\n\tpublic set endDate(date: Date) {\r\n\t\tthis.setDate(\"endDate\", date);\r\n\t\tthis.endValue = date.getTime();\r\n\t}\r\n\r\n\t/**\r\n\t * @return End date\r\n\t */\r\n\tpublic get endDate(): Date {\r\n\t\treturn this.dates[\"endDate\"];\r\n\t}\r\n\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines data fields for [[DateAxis]].\r\n */\r\nexport interface IDateAxisDataFields extends IValueAxisDataFields {\r\n\r\n\t/**\r\n\t * Date.\r\n\t */\r\n\tdate?: string;\r\n\r\n}\r\n\r\n/**\r\n * Defines properties for [[DateAxis]].\r\n */\r\nexport interface IDateAxisProperties extends IValueAxisProperties {\r\n\r\n\t/**\r\n\t * If enabled, axis will automatically collapse empty (without data points)\r\n\t * periods of time, i.e. weekends.\r\n\t *\r\n\t * @default false\r\n\t */\r\n\tskipEmptyPeriods?: boolean;\r\n\r\n\t/**\r\n\t * Use `periodChangeDateFormats` to apply different formats to the first\r\n\t * label in bigger time unit.\r\n\t *\r\n\t * @default true\r\n\t * @param value  Use different format for period beginning?\r\n\t */\r\n\tmarkUnitChange?: boolean;\r\n\r\n\t/**\r\n\t * Should the nearest tooltip be shown if no data item is found on the\r\n\t * current cursor position.\r\n\t *\r\n\t * @default true\r\n\t */\r\n\tsnapTooltip?: boolean;\r\n\r\n\t/**\r\n\t * A special date format to apply axis tooltips.\r\n\t *\r\n\t * Will use same format as for labels, if not set.\r\n\t */\r\n\ttooltipDateFormat?: string | Intl.DateTimeFormatOptions;\r\n\r\n\t/**\r\n\t * Indicates if data should be aggregated to composide data items if there\r\n\t * are more data items in selected range than `groupCount`.\r\n\t *\r\n\t * @default false\r\n\t * @since 4.7.0\r\n\t */\r\n\tgroupData?: boolean;\r\n\r\n\t/**\r\n\t * Indicates threshold of data items in selected range at which to start\r\n\t * aggregating data items if `groupData = true`.\r\n\t * \r\n\t * @default 200\r\n\t * @since 4.7.0\r\n\t */\r\n\tgroupCount?: number;\r\n\r\n\t/**\r\n\t * Disables automatic selection of data grouping intervals and always uses\r\n\t * `groupInterval` if set. Works only if `groupData = true`.\r\n\t * \r\n\t * @since 4.9.24\r\n\t */\r\n\tgroupInterval?: ITimeInterval;\r\n\r\n\t/**\r\n\t * If set will recalculate all timestamps in data by applying specific offset\r\n\t * in minutes.\r\n\t *\r\n\t * IMPORTANT: do not set `timezoneOffset` on both `DateAxis` and `dateFormatter`. It\r\n\t * will skew your results by applying offset twice.\r\n\t *\r\n\t * @since 4.8.5\r\n\t */\r\n\ttimezoneOffset?: number;\r\n\r\n\t/**\r\n\t * If set will recalculate all timestamps in data to specific named timezone,\r\n\t * e.g. `\"America/Vancouver\"`, `\"Australia/Sydney\"`, `\"UTC\"`, etc.\r\n\t *\r\n\t * IMPORTANT: do not set `timezone` on both `DateAxis` and `dateFormatter`. It\r\n\t * will skew your results by applying timezone twice.\r\n\t * \r\n\t * @since 4.10.1\r\n\t */\r\n\ttimezone?: string;\r\n\r\n}\r\n\r\n/**\r\n * Defines events for [[DateAxis]].\r\n */\r\nexport interface IDateAxisEvents extends IValueAxisEvents {\r\n\t/**\r\n\t * Invoked when data grouping is on and grouping period is changed. You can find our the period via dateAxis.currentDataSetId property.\r\n\t */\r\n\tgroupperiodchanged: IDateAxisEvents;\r\n}\r\n\r\n/**\r\n * Defines adapters for [[DateAxis]].\r\n *\r\n * @see {@link Adapter}\r\n */\r\nexport interface IDateAxisAdapters extends IValueAxisAdapters, IDateAxisProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Used to create a date/time-based axis for the chart.\r\n *\r\n * ```TypeScript\r\n * // Create the axis\r\n * let xAxis = chart.xAxes.push(new am4charts.DateAxis());\r\n *\r\n * // Set settings\r\n * xAxis.title.text = \"Time\";\r\n * ```\r\n * ```JavaScript\r\n * // Create the axis\r\n * var valueAxis = chart.xAxes.push(new am4charts.DateAxis());\r\n *\r\n * // Set settings\r\n * valueAxis.title.text = \"Time\";\r\n * ```\r\n * ```JSON\r\n * \"xAxes\": [{\r\n *   \"type\": \"DateAxis\",\r\n *   \"title\": {\r\n *     \"text\": \"Time\"\r\n *   }\r\n * }]\r\n * ```\r\n *\r\n * @see {@link IDateAxisEvents} for a list of available Events\r\n * @see {@link IDateAxisAdapters} for a list of available Adapters\r\n * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/date-axis/} got `DateAxis` documention\r\n * @important\r\n */\r\nexport class DateAxis<T extends AxisRenderer = AxisRenderer> extends ValueAxis<T> {\r\n\r\n\t/**\r\n\t * Defines data fields.\r\n\t */\r\n\tpublic _dataFields: IDateAxisDataFields;\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t */\r\n\tpublic _properties!: IDateAxisProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t */\r\n\tpublic _adapter!: IDateAxisAdapters;\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: IDateAxisEvents;\r\n\r\n\t/**\r\n\t * Defines the type of the Date Items.\r\n\t */\r\n\tpublic _dataItem: DateAxisDataItem;\r\n\r\n\t/**\r\n\t * Defines the type of the axis breaks.\r\n\t */\r\n\tpublic _axisBreak: DateAxisBreak;\r\n\r\n\tprotected _gapBreaks: boolean = false;\r\n\r\n\t/**\r\n\t * A list of date/time intervals for Date axis.\r\n\t *\r\n\t * This define various granularities available for the axis. For example\r\n\t * if you have an axis spanning an hour, and space for 6 grid lines / labels\r\n\t * the axis will choose the granularity of 10 minutes, displaying a label\r\n\t * every 10 minutes.\r\n\t *\r\n\t * Default intervals:\r\n\t *\r\n\t * ```JSON\r\n\t * [\r\n\t *  { timeUnit: \"millisecond\", count: 1 },\r\n\t *  { timeUnit: \"millisecond\", count: 5 },\r\n\t *  { timeUnit: \"millisecond\", count: 10 },\r\n\t *  { timeUnit: \"millisecond\", count: 50 },\r\n\t *  { timeUnit: \"millisecond\", count: 100 },\r\n\t *  { timeUnit: \"millisecond\", count: 500 },\r\n\t *  { timeUnit: \"second\", count: 1 },\r\n\t *  { timeUnit: \"second\", count: 5 },\r\n\t *  { timeUnit: \"second\", count: 10 },\r\n\t *  { timeUnit: \"second\", count: 30 },\r\n\t *  { timeUnit: \"minute\", count: 1 },\r\n\t *  { timeUnit: \"minute\", count: 5 },\r\n\t *  { timeUnit: \"minute\", count: 10 },\r\n\t *  { timeUnit: \"minute\", count: 30 },\r\n\t *  { timeUnit: \"hour\", count: 1 },\r\n\t *  { timeUnit: \"hour\", count: 3 },\r\n\t *  { timeUnit: \"hour\", count: 6 },\r\n\t *  { timeUnit: \"hour\", count: 12 },\r\n\t *  { timeUnit: \"day\", count: 1 },\r\n\t *  { timeUnit: \"day\", count: 2 },\r\n\t *  { timeUnit: \"day\", count: 3 },\r\n\t *  { timeUnit: \"day\", count: 4 },\r\n\t *  { timeUnit: \"day\", count: 5 },\r\n\t *  { timeUnit: \"week\", count: 1 },\r\n\t *  { timeUnit: \"month\", count: 1 },\r\n\t *  { timeUnit: \"month\", count: 2 },\r\n\t *  { timeUnit: \"month\", count: 3 },\r\n\t *  { timeUnit: \"month\", count: 6 },\r\n\t *  { timeUnit: \"year\", count: 1 },\r\n\t *  { timeUnit: \"year\", count: 2 },\r\n\t *  { timeUnit: \"year\", count: 5 },\r\n\t *  { timeUnit: \"year\", count: 10 },\r\n\t *  { timeUnit: \"year\", count: 50 },\r\n\t *  { timeUnit: \"year\", count: 100 }\r\n\t * ]\r\n\t * ```\r\n\t */\r\n\tpublic gridIntervals: List<ITimeInterval> = new List<ITimeInterval>();\r\n\r\n\t/**\r\n\t * If data aggregation is enabled by setting Axis' `groupData = true`, the\r\n\t * chart will try to aggregate data items into grouped data items.\r\n\t *\r\n\t * If there are more data items in selected period than `groupCount`, it will\r\n\t * group data items into bigger period.\r\n\t *\r\n\t * For example seconds might be grouped into 10-second aggregate data items.\r\n\t *\r\n\t * This setting indicates what group intervals can the chart group to.\r\n\t *\r\n\t * Default intervals:\r\n\t *\r\n\t * ```JSON\r\n\t * [\r\n\t *   { timeUnit: \"millisecond\", count: 1},\r\n\t *   { timeUnit: \"millisecond\", count: 10 },\r\n\t *   { timeUnit: \"millisecond\", count: 100 },\r\n\t *   { timeUnit: \"second\", count: 1 },\r\n\t *   { timeUnit: \"second\", count: 10 },\r\n\t *   { timeUnit: \"minute\", count: 1 },\r\n\t *   { timeUnit: \"minute\", count: 10 },\r\n\t *   { timeUnit: \"hour\", count: 1 },\r\n\t *   { timeUnit: \"day\", count: 1 },\r\n\t *   { timeUnit: \"week\", count: 1 },\r\n\t *   { timeUnit: \"month\", count: 1 },\r\n\t *   { timeUnit: \"year\", count: 1 }\r\n\t * ]\r\n\t * ```\r\n\t * `groupData = true` does not work in combination with `skipEmptyPeriods = true`.\r\n\t * \r\n\t * @since 4.7.0\r\n\t * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/date-axis/#Dynamic_data_item_grouping} for more information about dynamic data item grouping.\r\n\t */\r\n\tpublic groupIntervals: List<ITimeInterval> = new List<ITimeInterval>();\r\n\r\n\t/**\r\n\t * A collection of date formats to use when formatting different time units\r\n\t * on Date/time axis.\r\n\t *\r\n\t * Actual defaults will depend on the language locale set for the chart.\r\n\t *\r\n\t * To override format for a specific time unit, say days, you need to set\r\n\t * the appropriate key to a format string. E.g.:\r\n\t *\r\n\t * ```TypeScript\r\n\t * axis.dateFormats.setKey(\"day\", \"MMMM d, yyyy\");\r\n\t * ```\r\n\t * ```JavaScript\r\n\t * axis.dateFormats.setKey(\"day\", \"MMMM d, yyyy\");\r\n\t * ```\r\n\t * ```JSON\r\n\t * \"xAxes\": [{\r\n\t *   \"type\": \"DateAxis\",\r\n\t *   \"dateFormats\": {\r\n\t *     \"day\": \"MMMM d, yyyy\"\r\n\t *   }\r\n\t * }]\r\n\t * ```\r\n\t *\r\n\t * @see {@link DateFormatter}\r\n\t */\r\n\tpublic dateFormats: Dictionary<TimeUnit, string | Intl.DateTimeFormatOptions> = new Dictionary<TimeUnit, string | Intl.DateTimeFormatOptions>();\r\n\r\n\t/**\r\n\t * These formats are applied to labels that are first in a larger unit.\r\n\t *\r\n\t * For example, if we have a DateAxis with days on it, the first day of month\r\n\t * indicates a break in month - a start of the bigger period.\r\n\t *\r\n\t * For those labels, `periodChangeDateFormats` are applied instead of\r\n\t * `dateFormats`.\r\n\t *\r\n\t * This allows us implement convenient structures, like instead of:\r\n\t *\r\n\t * `Jan 1 - Jan 2 - Jan 3 - ...`\r\n\t *\r\n\t * We can have:\r\n\t *\r\n\t * `Jan - 1 - 2 - 3 - ...`\r\n\t *\r\n\t * This can be disabled by setting `markUnitChange = false`.\r\n\t */\r\n\tpublic periodChangeDateFormats: Dictionary<TimeUnit, string | Intl.DateTimeFormatOptions> = new Dictionary<TimeUnit, string | Intl.DateTimeFormatOptions>();\r\n\r\n\t/**\r\n\t * At which intervals grid elements are displayed.\r\n\t */\r\n\tprotected _gridInterval: ITimeInterval;\r\n\r\n\t/**\r\n\t * [_intervalDuration description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprotected _intervalDuration: number;\r\n\r\n\t/**\r\n\t * [_gridDate description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprotected _gridDate: Date;\r\n\r\n\t/**\r\n\t * [_nextGridUnit description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprotected _nextGridUnit: TimeUnit;\r\n\r\n\t/**\r\n\t * User-defined granularity of data.\r\n\t */\r\n\tprotected _baseInterval: ITimeInterval;\r\n\r\n\t/**\r\n\t * This is base interval of the main data set.\r\n\t */\r\n\tprotected _mainBaseInterval: ITimeInterval;\r\n\r\n\t/**\r\n\t * This is base interval of the currently selected data set.\r\n\t */\r\n\tprotected _groupInterval: ITimeInterval;\r\n\r\n\t/**\r\n\t * Actual interval (granularity) derived from the actual data.\r\n\t */\r\n\tprotected _baseIntervalReal: ITimeInterval = { timeUnit: \"day\", count: 1 };\r\n\r\n\t/**\r\n\t */\r\n\tprotected _prevSeriesTime: { [index: string]: number } = {};\r\n\r\n\t/**\r\n\t * [_minDifference description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprotected _minDifference: { [index: string]: number } = {};\r\n\r\n\t/**\r\n\t * A function which applies fills to axis cells.\r\n\t *\r\n\t * Default function fills every second fill. You can set this to a function\r\n\t * that follows some other logic.\r\n\t *\r\n\t * Function should accept a [[DateAxisDataItem]] and modify its `axisFill`\r\n\t * property accordingly.\r\n\t */\r\n\tpublic fillRule(dataItem: this[\"_dataItem\"]): void {\r\n\t\tlet value = dataItem.value;\r\n\t\tlet axis = dataItem.component;\r\n\t\tlet gridInterval = axis._gridInterval;\r\n\t\tlet gridDuration = $time.getDuration(gridInterval.timeUnit, gridInterval.count);\r\n\r\n\t\tif (Math.round((value - axis.min) / gridDuration) / 2 == Math.round(Math.round((value - axis.min) / gridDuration) / 2)) {\r\n\t\t\tdataItem.axisFill.__disabled = true;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tdataItem.axisFill.__disabled = false;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected _firstWeekDay: number = 1;\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected _df: DateFormatter;\r\n\r\n\t/**\r\n\t * A collection of start timestamps to use as axis' min timestamp for\r\n\t * particular data item item periods.\r\n\t *\r\n\t * @since 4.7.0\r\n\t * @readonly\r\n\t */\r\n\tpublic groupMin: { [index: string]: number } = {};\r\n\r\n\t/**\r\n\t * A collection of start timestamps to use as axis' max timestamp for\r\n\t * particular data item item periods.\r\n\t *\r\n\t * @since 4.7.0\r\n\t * @readonly\r\n\t */\r\n\tpublic groupMax: { [index: string]: number } = {};\r\n\r\n\t/**\r\n\t * Date of the last shown axis tooltip.\r\n\t *\r\n\t * @since 4.9.7\r\n\t * @readonly\r\n\t */\r\n\tpublic tooltipDate: Date;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\r\n\t\t// Init\r\n\t\tsuper();\r\n\t\tthis.className = \"DateAxis\";\r\n\r\n\t\tthis.setPropertyValue(\"markUnitChange\", true);\r\n\t\tthis.snapTooltip = true;\r\n\t\tthis.tooltipPosition = \"pointer\";\r\n\r\n\t\tthis.setPropertyValue(\"groupData\", false);\r\n\t\tthis.groupCount = 200;\r\n\r\n\t\tthis.events.on(\"parentset\", this.getDFFormatter, this, false);\r\n\r\n\t\t// Translatable defaults are applied in `applyInternalDefaults()`\r\n\t\t// ...\r\n\r\n\t\t// Define default intervals\r\n\t\tthis.gridIntervals.pushAll([\r\n\t\t\t{ timeUnit: \"millisecond\", count: 1 },\r\n\t\t\t{ timeUnit: \"millisecond\", count: 5 },\r\n\t\t\t{ timeUnit: \"millisecond\", count: 10 },\r\n\t\t\t{ timeUnit: \"millisecond\", count: 50 },\r\n\t\t\t{ timeUnit: \"millisecond\", count: 100 },\r\n\t\t\t{ timeUnit: \"millisecond\", count: 500 },\r\n\t\t\t{ timeUnit: \"second\", count: 1 },\r\n\t\t\t{ timeUnit: \"second\", count: 5 },\r\n\t\t\t{ timeUnit: \"second\", count: 10 },\r\n\t\t\t{ timeUnit: \"second\", count: 30 },\r\n\t\t\t{ timeUnit: \"minute\", count: 1 },\r\n\t\t\t{ timeUnit: \"minute\", count: 5 },\r\n\t\t\t{ timeUnit: \"minute\", count: 10 },\r\n\t\t\t{ timeUnit: \"minute\", count: 15 },\r\n\t\t\t{ timeUnit: \"minute\", count: 30 },\r\n\t\t\t{ timeUnit: \"hour\", count: 1 },\r\n\t\t\t{ timeUnit: \"hour\", count: 3 },\r\n\t\t\t{ timeUnit: \"hour\", count: 6 },\r\n\t\t\t{ timeUnit: \"hour\", count: 12 },\r\n\t\t\t{ timeUnit: \"day\", count: 1 },\r\n\t\t\t{ timeUnit: \"day\", count: 2 },\r\n\t\t\t{ timeUnit: \"day\", count: 3 },\r\n\t\t\t{ timeUnit: \"day\", count: 4 },\r\n\t\t\t{ timeUnit: \"day\", count: 5 },\r\n\t\t\t{ timeUnit: \"week\", count: 1 },\r\n\t\t\t{ timeUnit: \"month\", count: 1 },\r\n\t\t\t{ timeUnit: \"month\", count: 2 },\r\n\t\t\t{ timeUnit: \"month\", count: 3 },\r\n\t\t\t{ timeUnit: \"month\", count: 6 },\r\n\t\t\t{ timeUnit: \"year\", count: 1 },\r\n\t\t\t{ timeUnit: \"year\", count: 2 },\r\n\t\t\t{ timeUnit: \"year\", count: 5 },\r\n\t\t\t{ timeUnit: \"year\", count: 10 },\r\n\t\t\t{ timeUnit: \"year\", count: 50 },\r\n\t\t\t{ timeUnit: \"year\", count: 100 },\r\n\t\t\t{ timeUnit: \"year\", count: 200 },\r\n\t\t\t{ timeUnit: \"year\", count: 500 },\r\n\t\t\t{ timeUnit: \"year\", count: 1000 },\r\n\t\t\t{ timeUnit: \"year\", count: 2000 },\r\n\t\t\t{ timeUnit: \"year\", count: 5000 },\r\n\t\t\t{ timeUnit: \"year\", count: 10000 },\r\n\t\t\t{ timeUnit: \"year\", count: 100000 }\r\n\t\t]);\r\n\r\n\t\tthis.groupIntervals.pushAll([\r\n\t\t\t{ timeUnit: \"millisecond\", count: 1 },\r\n\t\t\t{ timeUnit: \"millisecond\", count: 10 },\r\n\t\t\t{ timeUnit: \"millisecond\", count: 100 },\r\n\t\t\t{ timeUnit: \"second\", count: 1 },\r\n\t\t\t{ timeUnit: \"second\", count: 10 },\r\n\t\t\t{ timeUnit: \"minute\", count: 1 },\r\n\t\t\t{ timeUnit: \"minute\", count: 10 },\r\n\t\t\t{ timeUnit: \"hour\", count: 1 },\r\n\t\t\t{ timeUnit: \"day\", count: 1 },\r\n\t\t\t{ timeUnit: \"week\", count: 1 },\r\n\t\t\t{ timeUnit: \"month\", count: 1 },\r\n\t\t\t{ timeUnit: \"year\", count: 1 }\r\n\t\t]);\r\n\r\n\t\t// Set field name\r\n\t\tthis.axisFieldName = \"date\";\r\n\r\n\t\t// Apply theme\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * Sets defaults that instantiate some objects that rely on parent, so they\r\n\t * cannot be set in constructor.\r\n\t */\r\n\tprotected applyInternalDefaults(): void {\r\n\t\tsuper.applyInternalDefaults();\r\n\r\n\t\t// Set default date formats\r\n\t\tif (!this.dateFormats.hasKey(\"millisecond\")) {\r\n\t\t\tthis.dateFormats.setKey(\"millisecond\", this.language.translate(\"_date_millisecond\"));\r\n\t\t}\r\n\t\tif (!this.dateFormats.hasKey(\"second\")) {\r\n\t\t\tthis.dateFormats.setKey(\"second\", this.language.translate(\"_date_second\"));\r\n\t\t}\r\n\t\tif (!this.dateFormats.hasKey(\"minute\")) {\r\n\t\t\tthis.dateFormats.setKey(\"minute\", this.language.translate(\"_date_minute\"));\r\n\t\t}\r\n\t\tif (!this.dateFormats.hasKey(\"hour\")) {\r\n\t\t\tthis.dateFormats.setKey(\"hour\", this.language.translate(\"_date_hour\"));\r\n\t\t}\r\n\t\tif (!this.dateFormats.hasKey(\"day\")) {\r\n\t\t\tthis.dateFormats.setKey(\"day\", this.language.translate(\"_date_day\"));\r\n\t\t}\r\n\t\tif (!this.dateFormats.hasKey(\"week\")) {\r\n\t\t\tthis.dateFormats.setKey(\"week\", this.language.translate(\"_date_day\"));\t // not a mistake\r\n\t\t}\r\n\t\tif (!this.dateFormats.hasKey(\"month\")) {\r\n\t\t\tthis.dateFormats.setKey(\"month\", this.language.translate(\"_date_month\"));\r\n\t\t}\r\n\t\tif (!this.dateFormats.hasKey(\"year\")) {\r\n\t\t\tthis.dateFormats.setKey(\"year\", this.language.translate(\"_date_year\"));\r\n\t\t}\r\n\r\n\t\tif (!this.periodChangeDateFormats.hasKey(\"millisecond\")) {\r\n\t\t\tthis.periodChangeDateFormats.setKey(\"millisecond\", this.language.translate(\"_date_millisecond\"));\r\n\t\t}\r\n\t\tif (!this.periodChangeDateFormats.hasKey(\"second\")) {\r\n\t\t\tthis.periodChangeDateFormats.setKey(\"second\", this.language.translate(\"_date_second\"));\r\n\t\t}\r\n\t\tif (!this.periodChangeDateFormats.hasKey(\"minute\")) {\r\n\t\t\tthis.periodChangeDateFormats.setKey(\"minute\", this.language.translate(\"_date_minute\"));\r\n\t\t}\r\n\t\tif (!this.periodChangeDateFormats.hasKey(\"hour\")) {\r\n\t\t\tthis.periodChangeDateFormats.setKey(\"hour\", this.language.translate(\"_date_day\"));\r\n\t\t}\r\n\t\tif (!this.periodChangeDateFormats.hasKey(\"day\")) {\r\n\t\t\tthis.periodChangeDateFormats.setKey(\"day\", this.language.translate(\"_date_day\"));\r\n\t\t}\r\n\t\tif (!this.periodChangeDateFormats.hasKey(\"week\")) {\r\n\t\t\tthis.periodChangeDateFormats.setKey(\"week\", this.language.translate(\"_date_day\"));\r\n\t\t}\r\n\t\tif (!this.periodChangeDateFormats.hasKey(\"month\")) {\r\n\t\t\tthis.periodChangeDateFormats.setKey(\"month\", this.language.translate(\"_date_month\") + \" \" + this.language.translate(\"_date_year\"));\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new/empty [[DataItem]] of the type appropriate for this object.\r\n\t *\r\n\t * @see {@link DataItem}\r\n\t * @return Data Item\r\n\t */\r\n\tprotected createDataItem(): this[\"_dataItem\"] {\r\n\t\treturn new DateAxisDataItem();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new/empty [[AxisBreak]] of the appropriate type.\r\n\t *\r\n\t * @return Axis break\r\n\t */\r\n\tprotected createAxisBreak(): this[\"_axisBreak\"] {\r\n\t\treturn new DateAxisBreak();\r\n\t}\r\n\r\n\t/**\r\n\t * Validates Axis' data items.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic validateDataItems(): void {\r\n\t\t// allows to keep selection of the same size\r\n\t\tlet start: number = this.start;\r\n\t\tlet end: number = this.end;\r\n\t\tlet baseDuration = this.baseDuration;\r\n\t\tlet periodCount: number = (this.max - this.min) / baseDuration;\r\n\r\n\t\tthis._firstWeekDay = this.getFirstWeekDay();\r\n\t\tthis.getDFFormatter();\r\n\r\n\t\tsuper.validateDataItems();\r\n\r\n\t\tlet mainBaseDuration = $time.getDuration(this.mainBaseInterval.timeUnit, this.mainBaseInterval.count)\r\n\r\n\t\tthis.maxZoomFactor = Math.max(1, (this.max - this.min) / mainBaseDuration);\r\n\r\n\t\tthis._deltaMinMax = this.baseDuration / 2;\r\n\r\n\t\t// allows to keep selection of the same size\r\n\t\tlet newPeriodCount: number = (this.max - this.min) / baseDuration;\r\n\t\tstart = start + (end - start) * (1 - periodCount / newPeriodCount);\r\n\t\tthis.zoom({ start: start, end: end }, false, true); // added instantlyto solve zoomout problem when we have axes gaps. @todo: check how this affects maxZoomFactor\r\n\t}\r\n\r\n\t/**\r\n\t * Handles process after zoom.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Does nothing?\r\n\t */\r\n\tpublic handleSelectionExtremesChange(): void {\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates all positions, related to axis as per current zoom.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic calculateZoom(): void {\r\n\t\tsuper.calculateZoom();\r\n\r\n\t\tlet difference = this.adjustDifference(this._minZoomed, this._maxZoomed);\r\n\t\tlet dataSetChanged = false;\r\n\r\n\t\t// if data has to be grouped, choose interval and set dataset\r\n\t\tif (this.groupData && $type.hasValue(difference)) {\r\n\t\t\tlet mainBaseInterval = this.mainBaseInterval;\r\n\r\n\t\t\tlet modifiedDifference = difference + (this.startLocation + (1 - this.endLocation)) * this.baseDuration;\r\n\t\t\tlet groupInterval: ITimeInterval;\r\n\t\t\tif (this.groupInterval) {\r\n\t\t\t\tgroupInterval = { ...this.groupInterval }\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tgroupInterval = this.chooseInterval(0, modifiedDifference, this.groupCount, this.groupIntervals);\r\n\t\t\t\tif ($time.getDuration(groupInterval.timeUnit, groupInterval.count) < $time.getDuration(mainBaseInterval.timeUnit, mainBaseInterval.count)) {\r\n\t\t\t\t\tgroupInterval = { ...mainBaseInterval };\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\r\n\t\t\tthis._groupInterval = groupInterval;\r\n\t\t\tlet newId = groupInterval.timeUnit + groupInterval.count;\r\n\t\t\tif (this._currentDataSetId != newId) {\r\n\t\t\t\tthis._currentDataSetId = newId;\r\n\t\t\t\tthis.dispatch(\"groupperiodchanged\");\r\n\t\t\t}\r\n\r\n\t\t\tthis.series.each((series) => {\r\n\t\t\t\tif (series.baseAxis == this) {\r\n\t\t\t\t\tif (series.setDataSet(this._currentDataSetId)) {\r\n\t\t\t\t\t\tdataSetChanged = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\tlet gridInterval: ITimeInterval = this.chooseInterval(0, difference, this._gridCount);\r\n\r\n\t\tif ($time.getDuration(gridInterval.timeUnit, gridInterval.count) < this.baseDuration) {\r\n\t\t\tgridInterval = { ...this.baseInterval };\r\n\t\t}\r\n\r\n\t\tthis._gridInterval = gridInterval;\r\n\t\tthis._nextGridUnit = $time.getNextUnit(gridInterval.timeUnit);\r\n\r\n\t\t// the following is needed to avoid grid flickering while scrolling\r\n\t\tthis._intervalDuration = $time.getDuration(gridInterval.timeUnit, gridInterval.count);\r\n\t\tthis._gridDate = $time.round(\r\n\t\t\tnew Date(this.minZoomed - $time.getDuration(gridInterval.timeUnit, gridInterval.count)),\r\n\t\t\tgridInterval.timeUnit,\r\n\t\t\tgridInterval.count,\r\n\t\t\tthis._firstWeekDay,\r\n\t\t\tthis._df.utc,\r\n\t\t\tnew Date(this.min),\r\n\t\t\tthis._df.timezoneMinutes,\r\n\t\t\tthis._df.timezone\r\n\t\t);\r\n\r\n\t\t// tell series start/end\r\n\t\t$iter.each(this.series.iterator(), (series) => {\r\n\t\t\tif (series.baseAxis == this) {\r\n\t\t\t\tlet field = <keyof XYSeriesDataItem>series.getAxisField(this);\r\n\r\n\t\t\t\tlet minZoomed = $time.round(\r\n\t\t\t\t\tnew Date(this._minZoomed + this.baseDuration * 0.05),\r\n\t\t\t\t\tthis.baseInterval.timeUnit, this.baseInterval.count,\r\n\t\t\t\t\tthis._firstWeekDay,\r\n\t\t\t\t\tthis._df.utc,\r\n\t\t\t\t\tundefined,\r\n\t\t\t\t\tthis._df.timezoneMinutes,\r\n\t\t\t\t\tthis._df.timezone\r\n\t\t\t\t).getTime();\r\n\t\t\t\tlet minZoomedStr = minZoomed.toString();\r\n\t\t\t\tlet startDataItem = series.dataItemsByAxis.getKey(this.uid).getKey(minZoomedStr + series.currentDataSetId);\r\n\r\n\t\t\t\tlet startIndex: number = 0;\r\n\t\t\t\tif (this.start != 0) {\r\n\t\t\t\t\tif (startDataItem) {\r\n\t\t\t\t\t\tstartDataItem = this.findFirst(startDataItem, minZoomed, field);\r\n\t\t\t\t\t\tstartIndex = startDataItem.index;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tstartIndex = series.dataItems.findClosestIndex(this._minZoomed, (x) => <number>x[field], \"left\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// 1 millisecond is removed so that if only first item is selected, it would not count in the second.\r\n\t\t\t\tlet baseInterval = this.baseInterval;\r\n\t\t\t\tlet maxZoomed = $time.add(\r\n\t\t\t\t\t$time.round(\r\n\t\t\t\t\t\tnew Date(this._maxZoomed),\r\n\t\t\t\t\t\tbaseInterval.timeUnit,\r\n\t\t\t\t\t\tbaseInterval.count,\r\n\t\t\t\t\t\tthis._firstWeekDay,\r\n\t\t\t\t\t\tthis._df.utc,\r\n\t\t\t\t\t\tundefined,\r\n\t\t\t\t\t\tthis._df.timezoneMinutes,\r\n\t\t\t\t\t\tthis._df.timezone\r\n\t\t\t\t\t),\r\n\t\t\t\t\tbaseInterval.timeUnit,\r\n\t\t\t\t\tbaseInterval.count,\r\n\t\t\t\t\tthis._df.utc\r\n\t\t\t\t).getTime();\r\n\r\n\t\t\t\tlet maxZoomedStr = maxZoomed.toString();\r\n\t\t\t\tlet endDataItem = series.dataItemsByAxis.getKey(this.uid).getKey(maxZoomedStr + series.currentDataSetId);\r\n\t\t\t\tlet endIndex: number = series.dataItems.length;\r\n\t\t\t\tif (this.end != 1) {\r\n\t\t\t\t\tif (endDataItem) {\r\n\t\t\t\t\t\tendIndex = endDataItem.index;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tmaxZoomed -= 1;\r\n\t\t\t\t\t\tendIndex = series.dataItems.findClosestIndex(maxZoomed, (x) => <number>x[field], \"right\");\r\n\t\t\t\t\t\t// not good - if end is in the gap, indexes go like 5,4,3,4,2,1\r\n\t\t\t\t\t\t//if (endIndex < series.dataItems.length) {\r\n\t\t\t\t\t\tendIndex++;\r\n\t\t\t\t\t\t//}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (series.max(this) < minZoomed) {\r\n\t\t\t\t\tseries.startIndex = series.dataItems.length;\r\n\t\t\t\t\tseries.endIndex = series.dataItems.length;\r\n\t\t\t\t\tseries.outOfRange = true;\r\n\t\t\t\t}\r\n\t\t\t\telse if (series.min(this) > maxZoomed) {\r\n\t\t\t\t\tseries.startIndex = 0;\r\n\t\t\t\t\tseries.endIndex = 0;\r\n\t\t\t\t\tseries.outOfRange = true;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tseries.outOfRange = false;\r\n\t\t\t\t\tseries.startIndex = startIndex;\r\n\t\t\t\t\tseries.endIndex = endIndex;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//\tconsole.log(series.name, startIndex, endIndex);\r\n\r\n\t\t\t\tif (!dataSetChanged && series.dataRangeInvalid) {\r\n\t\t\t\t\tseries.validateDataRange();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tprotected findFirst(dataItem: XYSeriesDataItem, time: number, key: string): XYSeriesDataItem {\r\n\t\tlet index = dataItem.index;\r\n\r\n\t\tif (index > 0) {\r\n\t\t\tlet series = dataItem.component;\r\n\t\t\tlet previousDataItem = series.dataItems.getIndex(index - 1);\r\n\r\n\t\t\tlet previousDate = (<any>previousDataItem)[key];\r\n\r\n\t\t\tif (!previousDate || previousDate.getTime() < time) {\r\n\t\t\t\treturn dataItem;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\treturn this.findFirst(previousDataItem, time, key);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn dataItem;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * (Re)validates data.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic validateData(): void {\r\n\t\tsuper.validateData();\r\n\t\tif (!$type.isNumber(this.baseInterval.count)) {\r\n\t\t\tthis.baseInterval.count = 1;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic get minDifference(): number {\r\n\t\tlet minDifference = Number.MAX_VALUE;\r\n\r\n\t\tthis.series.each((series) => {\r\n\t\t\tif (minDifference > this._minDifference[series.uid]) {\r\n\t\t\t\tminDifference = this._minDifference[series.uid];\r\n\t\t\t}\r\n\t\t})\r\n\r\n\t\tif (minDifference == Number.MAX_VALUE || minDifference == 0) {\r\n\t\t\tminDifference = $time.getDuration(\"day\");\r\n\t\t}\r\n\r\n\t\treturn minDifference;\r\n\t}\r\n\r\n\t/**\r\n\t * [dataChangeUpdate description]\r\n\t *\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t */\r\n\tpublic seriesDataChangeUpdate(series: XYSeries): void {\r\n\t\tthis._minDifference[series.uid] = Number.MAX_VALUE;\r\n\t}\r\n\r\n\t/**\r\n\t * [postProcessSeriesDataItems description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t */\r\n\tpublic postProcessSeriesDataItems(series?: XYSeries): void {\r\n\t\tthis._firstWeekDay = this.getFirstWeekDay();\r\n\t\tif (series) {\r\n\t\t\tthis.seriesGroupUpdate(series);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.series.each((series) => {\r\n\t\t\t\tthis.seriesGroupUpdate(series);\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\tthis.addEmptyUnitsBreaks();\r\n\t}\r\n\r\n\tprotected seriesGroupUpdate(series: XYSeries) {\r\n\t\tif (JSON.stringify(series._baseInterval[this.uid]) != JSON.stringify(this.mainBaseInterval)) {\r\n\r\n\t\t\tseries._baseInterval[this.uid] = this.mainBaseInterval;\r\n\r\n\t\t\tseries.mainDataSet.each((dataItem) => {\r\n\t\t\t\tthis.postProcessSeriesDataItem(dataItem);\r\n\t\t\t});\r\n\r\n\t\t\tif (this.groupData) {\r\n\t\t\t\tthis.groupSeriesData(series);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates series group data.\r\n\t * \r\n\t * @param  series  Series\r\n\t * @ignore\r\n\t */\r\n\tpublic groupSeriesData(series: XYSeries): void {\r\n\t\tif (series.baseAxis == this && series.dataItems.length > 0 && !series.dataGrouped) {\r\n\r\n\t\t\tseries.bulletsContainer.removeChildren();\r\n\r\n\t\t\t// make array of intervals which will be used;\r\n\t\t\tlet intervals: ITimeInterval[] = [];\r\n\t\t\tlet mainBaseInterval = this.mainBaseInterval;\r\n\t\t\tlet mainIntervalDuration = $time.getDuration(mainBaseInterval.timeUnit, mainBaseInterval.count);\r\n\r\n\t\t\tthis.groupIntervals.each((interval) => {\r\n\t\t\t\tlet intervalDuration = $time.getDuration(interval.timeUnit, interval.count);\r\n\t\t\t\tif ((intervalDuration > mainIntervalDuration && intervalDuration < (this.max - this.min)) || this.groupInterval) {\r\n\t\t\t\t\tintervals.push(interval);\r\n\t\t\t\t}\r\n\t\t\t})\r\n\r\n\t\t\tif (series._dataSets) {\r\n\t\t\t\tseries._dataSets.each((key, dataItems) => {\r\n\t\t\t\t\tdataItems.each((dataItem) => {\r\n\t\t\t\t\t\tdataItem.dispose();\r\n\t\t\t\t\t})\r\n\t\t\t\t\tdataItems.clear();\r\n\t\t\t\t})\r\n\t\t\t\tseries._dataSets.clear();\r\n\t\t\t}\r\n\r\n\t\t\tseries.dataGrouped = true;\r\n\r\n\t\t\t$array.each(intervals, (interval) => {\r\n\r\n\t\t\t\t//let mainBaseInterval = this._mainBaseInterval;\r\n\t\t\t\tlet key = \"date\" + this.axisLetter;\r\n\r\n\t\t\t\t// create data set\r\n\t\t\t\tlet dataSetId = interval.timeUnit + interval.count;\r\n\t\t\t\t// todo: check where this clone goes\r\n\t\t\t\tlet dataSet = new OrderedListTemplate(series.mainDataSet.template.clone());\r\n\r\n\t\t\t\tseries.dataSets.setKey(dataSetId, dataSet);\r\n\r\n\t\t\t\tlet dataItems = series.mainDataSet;\r\n\t\t\t\tlet previousTime: number = Number.NEGATIVE_INFINITY;\r\n\t\t\t\tlet i = 0;\r\n\t\t\t\tlet newDataItem: XYSeriesDataItem;\r\n\r\n\t\t\t\tlet dataFields: string[] = [];\r\n\r\n\t\t\t\t$object.each(series.dataFields, (dfkey, df) => {\r\n\t\t\t\t\tlet dfk = <string>dfkey;\r\n\t\t\t\t\tif (dfk != key && dfk.indexOf(\"Show\") == -1) {\r\n\t\t\t\t\t\tdataFields.push(dfk);\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\r\n\t\t\t\tlet roundedDate: Date;\r\n\t\t\t\tdataItems.each((dataItem) => {\r\n\t\t\t\t\tlet date = dataItem.getDate(key);\r\n\t\t\t\t\tif (date) {\r\n\t\t\t\t\t\tlet time = date.getTime();\r\n\t\t\t\t\t\troundedDate = $time.round(\r\n\t\t\t\t\t\t\tnew Date(time),\r\n\t\t\t\t\t\t\tinterval.timeUnit,\r\n\t\t\t\t\t\t\tinterval.count,\r\n\t\t\t\t\t\t\tthis._df.firstDayOfWeek,\r\n\t\t\t\t\t\t\tthis._df.utc,\r\n\t\t\t\t\t\t\tundefined,\r\n\t\t\t\t\t\t\tthis._df.timezoneMinutes,\r\n\t\t\t\t\t\t\tthis._df.timezone\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\tlet currentTime = roundedDate.getTime();\r\n\t\t\t\t\t\t// changed period\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (previousTime < currentTime) {\r\n\r\n\t\t\t\t\t\t\tif (newDataItem && series._adapterO) {\r\n\t\t\t\t\t\t\t\t$array.each(dataFields, (vkey) => {\r\n\t\t\t\t\t\t\t\t\tnewDataItem.values[vkey].value = series._adapterO.apply(\"groupDataItem\", {\r\n\t\t\t\t\t\t\t\t\t\tdataItem: newDataItem,\r\n\t\t\t\t\t\t\t\t\t\tinterval: interval,\r\n\t\t\t\t\t\t\t\t\t\tdataField: <any>vkey,\r\n\t\t\t\t\t\t\t\t\t\tdate: roundedDate,\r\n\t\t\t\t\t\t\t\t\t\tvalue: newDataItem.values[vkey].value\r\n\t\t\t\t\t\t\t\t\t}).value;\r\n\r\n\t\t\t\t\t\t\t\t\tnewDataItem.values[vkey].workingValue = newDataItem.values[vkey].value\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tnewDataItem = dataSet.create();\r\n\r\n\t\t\t\t\t\t\tnewDataItem.dataContext = {};\r\n\r\n\t\t\t\t\t\t\tnewDataItem.setWorkingLocation(\"dateX\", series.dataItems.template.locations.dateX, 0);\r\n\t\t\t\t\t\t\tnewDataItem.setWorkingLocation(\"openDateX\", series.dataItems.template.locations.openDateX, 0);\r\n\t\t\t\t\t\t\tnewDataItem.setWorkingLocation(\"dateY\", series.dataItems.template.locations.dateY, 0);\r\n\t\t\t\t\t\t\tnewDataItem.setWorkingLocation(\"openDateY\", series.dataItems.template.locations.openDateY, 0);\r\n\r\n\t\t\t\t\t\t\tnewDataItem.component = series;\r\n\t\t\t\t\t\t\t// other Dates?\r\n\t\t\t\t\t\t\tnewDataItem.setDate(key, roundedDate);\r\n\t\t\t\t\t\t\tnewDataItem._index = i;\r\n\t\t\t\t\t\t\ti++;\r\n\r\n\t\t\t\t\t\t\t$array.each(dataFields, (vkey) => {\r\n\t\t\t\t\t\t\t\t//let groupFieldName = vkey + \"Group\";\r\n\t\t\t\t\t\t\t\tlet dvalues = dataItem.values[vkey];\r\n\t\t\t\t\t\t\t\tif (dvalues) {\r\n\t\t\t\t\t\t\t\t\tlet value = dvalues.value;\r\n\r\n\t\t\t\t\t\t\t\t\tif (series._adapterO) {\r\n\t\t\t\t\t\t\t\t\t\tvalue = series._adapterO.apply(\"groupValue\", {\r\n\t\t\t\t\t\t\t\t\t\t\tdataItem: dataItem,\r\n\t\t\t\t\t\t\t\t\t\t\tinterval: interval,\r\n\t\t\t\t\t\t\t\t\t\t\tdataField: <any>vkey,\r\n\t\t\t\t\t\t\t\t\t\t\tdate: roundedDate,\r\n\t\t\t\t\t\t\t\t\t\t\tvalue: value\r\n\t\t\t\t\t\t\t\t\t\t}).value;\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\tlet values = newDataItem.values[vkey];\r\n\t\t\t\t\t\t\t\t\tif ($type.isNumber(value)) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tvalues.value = value;\r\n\t\t\t\t\t\t\t\t\t\tvalues.workingValue = value;\r\n\r\n\t\t\t\t\t\t\t\t\t\tvalues.open = value;\r\n\t\t\t\t\t\t\t\t\t\tvalues.close = value;\r\n\t\t\t\t\t\t\t\t\t\tvalues.low = value;\r\n\t\t\t\t\t\t\t\t\t\tvalues.high = value;\r\n\t\t\t\t\t\t\t\t\t\tvalues.sum = value;\r\n\t\t\t\t\t\t\t\t\t\tvalues.average = value;\r\n\t\t\t\t\t\t\t\t\t\tvalues.count = 1;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\t\tvalues.count = 0;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t})\r\n\r\n\t\t\t\t\t\t\tthis.postProcessSeriesDataItem(newDataItem, interval);\r\n\r\n\t\t\t\t\t\t\t$object.each(series.propertyFields, (key, fieldValue) => {\r\n\t\t\t\t\t\t\t\tconst f: string = <string>key;\r\n\t\t\t\t\t\t\t\tlet value: any = (<any>dataItem.properties)[key];\r\n\r\n\t\t\t\t\t\t\t\tif ($type.hasValue(value)) {\r\n\t\t\t\t\t\t\t\t\tnewDataItem.hasProperties = true;\r\n\t\t\t\t\t\t\t\t\tnewDataItem.setProperty(f, value);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\tnewDataItem.groupDataItems = [dataItem];\r\n\t\t\t\t\t\t\tpreviousTime = currentTime;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tif (newDataItem) {\r\n\t\t\t\t\t\t\t\t$array.each(dataFields, (vkey) => {\r\n\t\t\t\t\t\t\t\t\tlet groupFieldName = (<any>series.groupFields)[vkey];\r\n\t\t\t\t\t\t\t\t\tlet dvalues = dataItem.values[vkey];\r\n\t\t\t\t\t\t\t\t\tif (dvalues) {\r\n\t\t\t\t\t\t\t\t\t\tlet value = dvalues.value;\r\n\r\n\t\t\t\t\t\t\t\t\t\tif (series._adapterO) {\r\n\t\t\t\t\t\t\t\t\t\t\tvalue = series._adapterO.apply(\"groupValue\", {\r\n\t\t\t\t\t\t\t\t\t\t\t\tdataItem: dataItem,\r\n\t\t\t\t\t\t\t\t\t\t\t\tinterval: interval,\r\n\t\t\t\t\t\t\t\t\t\t\t\tdataField: <any>vkey,\r\n\t\t\t\t\t\t\t\t\t\t\t\tdate: roundedDate,\r\n\t\t\t\t\t\t\t\t\t\t\t\tvalue: value\r\n\t\t\t\t\t\t\t\t\t\t\t}).value;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\tif ($type.isNumber(value)) {\r\n\t\t\t\t\t\t\t\t\t\t\tlet values = newDataItem.values[vkey];\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tif (!$type.isNumber(values.open)) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tvalues.open = value;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tvalues.close = value;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tif (values.low > value || !$type.isNumber(values.low)) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tvalues.low = value;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\tif (values.high < value || !$type.isNumber(values.high)) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tvalues.high = value;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\tif ($type.isNumber(values.sum)) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tvalues.sum += value;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\t\t\t\tvalues.sum = value;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\tvalues.count++;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tvalues.average = values.sum / values.count;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tif ($type.isNumber(values[groupFieldName])) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tvalues.value = values[groupFieldName];\r\n\t\t\t\t\t\t\t\t\t\t\t\tvalues.workingValue = values.value;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t\t$utils.copyProperties(dataItem.properties, newDataItem.properties);\r\n\r\n\t\t\t\t\t\t\t\t$object.each(series.propertyFields, (key, fieldValue) => {\r\n\t\t\t\t\t\t\t\t\tconst f: string = <string>key;\r\n\t\t\t\t\t\t\t\t\tlet value: any = (<any>dataItem.properties)[key];\r\n\t\t\t\t\t\t\t\t\tif ($type.hasValue(value)) {\r\n\t\t\t\t\t\t\t\t\t\tnewDataItem.hasProperties = true;\r\n\t\t\t\t\t\t\t\t\t\tnewDataItem.setProperty(f, value);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t\t\tnewDataItem.groupDataItems.push(dataItem);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (newDataItem) {\r\n\t\t\t\t\t\t$utils.copyProperties(dataItem.dataContext, newDataItem.dataContext);\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t\tif (newDataItem && series._adapterO) {\r\n\r\n\t\t\t\t\t$array.each(dataFields, (vkey) => {\r\n\t\t\t\t\t\tnewDataItem.values[vkey].value = series._adapterO.apply(\"groupDataItem\", {\r\n\t\t\t\t\t\t\tdataItem: newDataItem,\r\n\t\t\t\t\t\t\tinterval: interval,\r\n\t\t\t\t\t\t\tdataField: <any>vkey,\r\n\t\t\t\t\t\t\tdate: roundedDate,\r\n\t\t\t\t\t\t\tvalue: newDataItem.values[vkey].value\r\n\t\t\t\t\t\t}).value;\r\n\r\n\t\t\t\t\t\tnewDataItem.values[vkey].workingValue = newDataItem.values[vkey].value;\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t})\r\n\r\n\t\t\tthis.calculateZoom();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected getDFFormatter() {\r\n\t\tthis._df = this.dateFormatter;\r\n\t}\r\n\r\n\t/**\r\n\t * [postProcessSeriesDataItem description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @param dataItem Data item\r\n\t */\r\n\tpublic postProcessSeriesDataItem(dataItem: XYSeriesDataItem, interval?: ITimeInterval): void {\r\n\t\t// we need to do this for all series data items not only added recently, as baseInterval might change\r\n\t\tlet intervalID = \"\";\r\n\t\tif (interval) {\r\n\t\t\tintervalID = interval.timeUnit + interval.count;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tinterval = this.mainBaseInterval;\r\n\t\t}\r\n\r\n\t\tlet series: XYSeries = dataItem.component;\r\n\t\tlet dataItemsByAxis = series.dataItemsByAxis.getKey(this.uid);\r\n\r\n\t\t$object.each(dataItem.dates, (key) => {\r\n\t\t\tlet date: Date = dataItem.getDate(key);\r\n\t\t\tlet time = date.getTime();\r\n\r\n\t\t\tlet startDate: Date = $time.round(\r\n\t\t\t\tnew Date(time),\r\n\t\t\t\tinterval.timeUnit,\r\n\t\t\t\tinterval.count,\r\n\t\t\t\tthis._firstWeekDay,\r\n\t\t\t\tthis._df.utc,\r\n\t\t\t\tundefined,\r\n\t\t\t\tthis._df.timezoneMinutes,\r\n\t\t\t\tthis._df.timezone\r\n\t\t\t);\r\n\t\t\tlet startTime = startDate.getTime();\r\n\t\t\tlet endDate: Date = $time.add(new Date(startTime), interval.timeUnit, interval.count, this._df.utc);\r\n\r\n\t\t\tdataItem.setCalculatedValue(key, startTime, \"open\");\r\n\t\t\tdataItem.setCalculatedValue(key, endDate.getTime(), \"close\");\r\n\t\t\tdataItemsByAxis.setKey(startTime + intervalID, dataItem);\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Collapses empty stretches of date/time scale by creating [[AxisBreak]]\r\n\t * elements for them.\r\n\t *\r\n\t * Can be used to automatically remove strethes without data, like weekends.\r\n\t *\r\n\t * No, need to call this manually. It will automatically be done if\r\n\t * `skipEmptyPeriods = true`.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tprotected addEmptyUnitsBreaks(): void {\r\n\r\n\t\tif (this.skipEmptyPeriods && $type.isNumber(this.min) && $type.isNumber(this.max)) {\r\n\t\t\tlet timeUnit: TimeUnit = this.baseInterval.timeUnit;\r\n\t\t\tlet count: number = this.baseInterval.count;\r\n\r\n\t\t\tif (this._axisBreaks) {\r\n\t\t\t\tthis._axisBreaks.clear(); // TODO: what about breaks added by user?\r\n\t\t\t}\r\n\r\n\t\t\tlet date: Date = $time.round(\r\n\t\t\t\tnew Date(this.min),\r\n\t\t\t\ttimeUnit,\r\n\t\t\t\tcount,\r\n\t\t\t\tthis._firstWeekDay,\r\n\t\t\t\tthis._df.utc,\r\n\t\t\t\tundefined,\r\n\t\t\t\tthis._df.timezoneMinutes,\r\n\t\t\t\tthis._df.timezone\r\n\t\t\t);\r\n\t\t\tlet axisBreak: DateAxisBreak;\r\n\r\n\t\t\twhile (date.getTime() < this.max - this.baseDuration) {\r\n\t\t\t\t$time.add(date, timeUnit, count, this._df.utc);\r\n\r\n\t\t\t\tlet startTime: number = date.getTime();\r\n\t\t\t\tlet startTimeStr: string = startTime.toString();\r\n\r\n\t\t\t\tlet hasData = $iter.contains(this.series.iterator(), (series) => {\r\n\t\t\t\t\treturn !!series.dataItemsByAxis.getKey(this.uid).getKey(startTimeStr + series.currentDataSetId);\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// open break if not yet opened\r\n\t\t\t\tif (!hasData) {\r\n\t\t\t\t\tif (!axisBreak) {\r\n\t\t\t\t\t\taxisBreak = <DateAxisBreak>this.axisBreaks.create();\r\n\t\t\t\t\t\taxisBreak.startDate = new Date(startTime);\r\n\t\t\t\t\t\tthis._gapBreaks = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t// close if already opened\r\n\t\t\t\t\tif (axisBreak) {\r\n\t\t\t\t\t\t// close at end time minus one millisecond\r\n\t\t\t\t\t\taxisBreak.endDate = new Date(startTime - 1);\r\n\t\t\t\t\t\taxisBreak = undefined;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Updates positioning of Axis breaks after something changes.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic fixAxisBreaks(): void {\r\n\t\tsuper.fixAxisBreaks();\r\n\t\tlet axisBreaks = this._axisBreaks;\r\n\t\tif (axisBreaks) {\r\n\t\t\tif (axisBreaks.length > 0) {\r\n\t\t\t\t// process breaks\r\n\t\t\t\taxisBreaks.each((axisBreak) => {\r\n\t\t\t\t\tlet breakGridCount: number = Math.ceil(this._gridCount * (Math.min(this.end, axisBreak.endPosition) - Math.max(this.start, axisBreak.startPosition)) / (this.end - this.start));\r\n\t\t\t\t\taxisBreak.gridInterval = this.chooseInterval(0, axisBreak.adjustedEndValue - axisBreak.adjustedStartValue, breakGridCount);\r\n\t\t\t\t\tlet gridDate = $time.round(\r\n\t\t\t\t\t\tnew Date(axisBreak.adjustedStartValue),\r\n\t\t\t\t\t\taxisBreak.gridInterval.timeUnit,\r\n\t\t\t\t\t\taxisBreak.gridInterval.count,\r\n\t\t\t\t\t\tthis._firstWeekDay,\r\n\t\t\t\t\t\tthis._df.utc,\r\n\t\t\t\t\t\tundefined,\r\n\t\t\t\t\t\tthis._df.timezoneMinutes,\r\n\t\t\t\t\t\tthis._df.timezone\r\n\t\t\t\t\t);\r\n\t\t\t\t\tif (gridDate.getTime() > axisBreak.startDate.getTime()) {\r\n\t\t\t\t\t\t$time.add(gridDate, axisBreak.gridInterval.timeUnit, axisBreak.gridInterval.count, this._df.utc);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\taxisBreak.gridDate = gridDate;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected getFirstWeekDay(): number {\r\n\t\tif (this._df) {\r\n\t\t\treturn this._df.firstDayOfWeek;\r\n\t\t}\r\n\t\treturn 1;\r\n\t}\r\n\r\n\t/**\r\n\t * [getGridDate description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @param date           [description]\r\n\t * @param intervalCount  [description]\r\n\t * @return [description]\r\n\t */\r\n\tpublic getGridDate(date: Date, intervalCount: number): Date {\r\n\t\tlet timeUnit: TimeUnit = this._gridInterval.timeUnit;\r\n\t\tlet realIntervalCount: number = this._gridInterval.count;\r\n\t\t// round date\r\n\t\t$time.round(\r\n\t\t\tdate,\r\n\t\t\ttimeUnit,\r\n\t\t\t1,\r\n\t\t\tthis._firstWeekDay,\r\n\t\t\tthis._df.utc,\r\n\t\t\tundefined,\r\n\t\t\tthis._df.timezoneMinutes,\r\n\t\t\tthis._df.timezone\r\n\t\t);\r\n\r\n\t\tlet prevTimestamp: number = date.getTime();\r\n\r\n\t\tlet newDate: Date = $time.copy(date);\r\n\t\t// modify date by adding intervalcount\r\n\t\tlet timestamp: number = $time.add(newDate, timeUnit, intervalCount, this._df.utc).getTime();\r\n\r\n\t\t// if it's axis break, get first rounded date which is not in a break\r\n\t\tlet axisBreak: DateAxisBreak = <DateAxisBreak>this.isInBreak(timestamp);\r\n\t\tif (axisBreak && axisBreak.endDate) {\r\n\t\t\tnewDate = new Date(axisBreak.endDate.getTime());\r\n\t\t\t$time.round(\r\n\t\t\t\tnewDate,\r\n\t\t\t\ttimeUnit,\r\n\t\t\t\trealIntervalCount,\r\n\t\t\t\tthis._firstWeekDay,\r\n\t\t\t\tthis._df.utc,\r\n\t\t\t\tundefined,\r\n\t\t\t\tthis._df.timezoneMinutes,\r\n\t\t\t\tthis._df.timezone\r\n\t\t\t);\r\n\t\t\tif (newDate.getTime() < axisBreak.endDate.getTime()) {\r\n\t\t\t\t$time.add(newDate, timeUnit, realIntervalCount, this._df.utc);\r\n\t\t\t}\r\n\t\t\ttimestamp = newDate.getTime();\r\n\t\t}\r\n\r\n\t\t// get duration between grid lines with break duration removed\r\n\t\tlet durationBreaksRemoved: number = this.adjustDifference(prevTimestamp, timestamp);\r\n\t\t// calculate how many time units fit to this duration\r\n\t\tlet countBreaksRemoved: number = Math.round(durationBreaksRemoved / $time.getDuration(timeUnit));\r\n\r\n\t\t// if less units fit, add one and repeat\r\n\t\tif (countBreaksRemoved < realIntervalCount) {\r\n\t\t\treturn this.getGridDate(date, intervalCount + realIntervalCount);\r\n\t\t}\r\n\r\n\t\treturn newDate;\r\n\t}\r\n\r\n\t/**\r\n\t * [getBreaklessDate description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @param axisBreak  [description]\r\n\t * @param timeUnit   [description]\r\n\t * @param count      [description]\r\n\t * @return [description]\r\n\t */\r\n\tpublic getBreaklessDate(axisBreak: DateAxisBreak, timeUnit: TimeUnit, count: number): Date {\r\n\t\tlet date = new Date(axisBreak.endValue);\r\n\t\t$time.round(\r\n\t\t\tdate,\r\n\t\t\ttimeUnit,\r\n\t\t\tcount,\r\n\t\t\tthis._firstWeekDay,\r\n\t\t\tthis._df.utc,\r\n\t\t\tundefined,\r\n\t\t\tthis._df.timezoneMinutes,\r\n\t\t\tthis._df.timezone\r\n\t\t);\r\n\t\t$time.add(date, timeUnit, count, this._df.utc);\r\n\r\n\t\tlet timestamp = date.getTime();\r\n\r\n\t\taxisBreak = <DateAxisBreak>this.isInBreak(timestamp);\r\n\t\tif (axisBreak) {\r\n\t\t\treturn this.getBreaklessDate(axisBreak, timeUnit, count);\r\n\t\t}\r\n\t\treturn date;\r\n\t}\r\n\r\n\t/**\r\n\t * (Re)validates all Axis elements.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t */\r\n\tpublic validateAxisElements(): void {\r\n\t\tif ($type.isNumber(this.max) && $type.isNumber(this.min)) {\r\n\r\n\t\t\tthis.calculateZoom();\r\n\r\n\t\t\t// first regular items\r\n\t\t\tlet timestamp = this._gridDate.getTime();\r\n\t\t\tlet timeUnit = this._gridInterval.timeUnit;\r\n\t\t\tlet intervalCount = this._gridInterval.count;\r\n\t\t\tlet prevGridDate = $time.copy(this._gridDate);\r\n\r\n\t\t\tlet dataItemsIterator = this._dataItemsIterator;\r\n\t\t\tthis.resetIterators();\r\n\r\n\t\t\twhile (timestamp <= this._maxZoomed) {\r\n\t\t\t\tlet date = this.getGridDate($time.copy(prevGridDate), intervalCount);\r\n\t\t\t\ttimestamp = date.getTime();\r\n\r\n\t\t\t\tlet endDate = $time.copy(date); // you might think it's easier to add intervalduration to timestamp, however it won't work for months or years which are not of the same length\r\n\t\t\t\tendDate = $time.add(endDate, timeUnit, intervalCount, this._df.utc);\r\n\r\n\t\t\t\tlet format = this.dateFormats.getKey(timeUnit);\r\n\r\n\t\t\t\tif (this.markUnitChange && prevGridDate) {\r\n\t\t\t\t\tif ($time.checkChange(date, prevGridDate, this._nextGridUnit, this._df.utc)) {\r\n\t\t\t\t\t\tif (timeUnit !== \"year\") {\r\n\t\t\t\t\t\t\tformat = this.periodChangeDateFormats.getKey(timeUnit);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet text = this._df.format(date, format);\r\n\r\n\t\t\t\tlet dataItem = dataItemsIterator.find((x) => x.text === text);\r\n\t\t\t\tif (dataItem.__disabled) {\r\n\t\t\t\t\tdataItem.__disabled = false;\r\n\t\t\t\t}\r\n\t\t\t\tthis.appendDataItem(dataItem);\r\n\r\n\t\t\t\tdataItem.axisBreak = undefined;\r\n\t\t\t\tdataItem.date = date;\r\n\t\t\t\tdataItem.endDate = endDate;\r\n\r\n\t\t\t\tdataItem.text = text;\r\n\r\n\t\t\t\tthis.validateDataElement(dataItem);\r\n\r\n\t\t\t\tprevGridDate = date;\r\n\t\t\t}\r\n\r\n\t\t\t// breaks later\r\n\t\t\tlet renderer: AxisRenderer = this.renderer;\r\n\r\n\t\t\tif (this._axisBreaks) {\r\n\t\t\t\t$iter.each(this._axisBreaks.iterator(), (axisBreak) => {\r\n\t\t\t\t\tif (axisBreak.breakSize > 0) {\r\n\t\t\t\t\t\tlet timeUnit: TimeUnit = axisBreak.gridInterval.timeUnit;\r\n\t\t\t\t\t\tlet intervalCount: number = axisBreak.gridInterval.count;\r\n\r\n\t\t\t\t\t\t// only add grid if gap is bigger then minGridDistance\r\n\t\t\t\t\t\tif ($math.getDistance(axisBreak.startPoint, axisBreak.endPoint) > renderer.minGridDistance * 4) {\r\n\t\t\t\t\t\t\tlet timestamp: number = axisBreak.gridDate.getTime();\r\n\r\n\t\t\t\t\t\t\tlet prevGridDate;\r\n\t\t\t\t\t\t\tlet count: number = 0;\r\n\t\t\t\t\t\t\twhile (timestamp <= axisBreak.adjustedMax) {\r\n\t\t\t\t\t\t\t\tlet date: Date = $time.copy(axisBreak.gridDate);\r\n\t\t\t\t\t\t\t\ttimestamp = $time.add(date, timeUnit, intervalCount * count, this._df.utc).getTime();\r\n\t\t\t\t\t\t\t\tcount++;\r\n\t\t\t\t\t\t\t\tif (timestamp > axisBreak.adjustedStartValue && timestamp < axisBreak.adjustedEndValue) {\r\n\t\t\t\t\t\t\t\t\tlet endDate = $time.copy(date); // you might think it's easier to add intervalduration to timestamp, however it won't work for months or years which are not of the same length\r\n\t\t\t\t\t\t\t\t\tendDate = $time.add(endDate, timeUnit, intervalCount, this._df.utc);\r\n\r\n\t\t\t\t\t\t\t\t\tlet format = this.dateFormats.getKey(timeUnit);\r\n\r\n\t\t\t\t\t\t\t\t\tif (this.markUnitChange && prevGridDate) {\r\n\t\t\t\t\t\t\t\t\t\tif ($time.checkChange(date, prevGridDate, this._nextGridUnit, this._df.utc)) {\r\n\t\t\t\t\t\t\t\t\t\t\tif (timeUnit !== \"year\") {\r\n\t\t\t\t\t\t\t\t\t\t\t\tformat = this.periodChangeDateFormats.getKey(timeUnit);\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\tlet text: string = this._df.format(date, format);\r\n\r\n\t\t\t\t\t\t\t\t\tlet dataItem: this[\"_dataItem\"] = dataItemsIterator.find((x) => x.text === text);\r\n\t\t\t\t\t\t\t\t\tif (dataItem.__disabled) {\r\n\t\t\t\t\t\t\t\t\t\tdataItem.__disabled = false;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t//this.processDataItem(dataItem);\r\n\t\t\t\t\t\t\t\t\tthis.appendDataItem(dataItem);\r\n\t\t\t\t\t\t\t\t\tdataItem.axisBreak = axisBreak;\r\n\t\t\t\t\t\t\t\t\taxisBreak.dataItems.moveValue(dataItem);\r\n\r\n\t\t\t\t\t\t\t\t\tdataItem.date = date;\r\n\t\t\t\t\t\t\t\t\tdataItem.endDate = endDate;\r\n\t\t\t\t\t\t\t\t\tdataItem.text = text;\r\n\t\t\t\t\t\t\t\t\tprevGridDate = date;\r\n\t\t\t\t\t\t\t\t\tthis.validateDataElement(dataItem);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Validates Axis data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param dataItem Data item\r\n\t */\r\n\tpublic validateDataElement(dataItem: this[\"_dataItem\"]): void {\r\n\r\n\t\tdataItem.itemIndex = this._axisItemCount;\r\n\t\tthis._axisItemCount++;\r\n\r\n\t\tif ($type.isNumber(this.max) && $type.isNumber(this.min)) {\r\n\t\t\tlet renderer: AxisRenderer = this.renderer;\r\n\r\n\t\t\tlet timestamp = dataItem.value;\r\n\t\t\tlet endTimestamp = dataItem.endValue;\r\n\r\n\t\t\tif (!$type.isNumber(endTimestamp)) {\r\n\t\t\t\tendTimestamp = timestamp;\r\n\t\t\t}\r\n\r\n\t\t\tlet position: number = this.valueToPosition(timestamp);\r\n\t\t\tlet endPosition: number = this.valueToPosition(endTimestamp);\r\n\t\t\tlet fillEndPosition = endPosition;\r\n\r\n\t\t\tif (!dataItem.isRange && this._gridInterval.count > this.baseInterval.count) {\r\n\t\t\t\tendPosition = position + (endPosition - position) / (this._gridInterval.count / this.baseInterval.count);\r\n\t\t\t}\r\n\r\n\t\t\tdataItem.position = position;\r\n\r\n\t\t\tlet tick: AxisTick = dataItem.tick;\r\n\t\t\tif (tick && !tick.disabled) {\r\n\t\t\t\trenderer.updateTickElement(tick, position, endPosition);\r\n\t\t\t}\r\n\r\n\t\t\tlet grid: Grid = dataItem.grid;\r\n\t\t\tif (grid && !grid.disabled) {\r\n\t\t\t\trenderer.updateGridElement(grid, position, endPosition);\r\n\t\t\t}\r\n\r\n\t\t\tlet fill: AxisFill = dataItem.axisFill;\r\n\t\t\tif (fill && !fill.disabled) {\r\n\t\t\t\trenderer.updateFillElement(fill, position, fillEndPosition);\r\n\t\t\t\tif (!dataItem.isRange) {\r\n\t\t\t\t\tthis.fillRule(dataItem);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tlet mask: AxisFill = dataItem.mask;\r\n\t\t\tif (mask) {\r\n\t\t\t\trenderer.updateFillElement(mask, position, endPosition);\r\n\t\t\t}\r\n\r\n\t\t\tif (dataItem.bullet) {\r\n\t\t\t\trenderer.updateBullet(dataItem.bullet, position, endPosition);\r\n\t\t\t}\r\n\r\n\t\t\tlet label: AxisLabel = dataItem.label;\r\n\t\t\tif (label && !label.disabled) {\r\n\t\t\t\tlet location = label.location;\r\n\r\n\r\n\r\n\t\t\t\tif (location == 0) {\r\n\t\t\t\t\tif (this._gridInterval.count == 1 && this._gridInterval.timeUnit != \"week\" && !dataItem.isRange) {\r\n\t\t\t\t\t\tlocation = 0.5;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tlocation = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\trenderer.updateLabelElement(label, position, endPosition, location);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * A duration in milliseconds of the `baseInterval`.\r\n\t *\r\n\t * @return Duration (ms)\r\n\t */\r\n\tpublic get baseDuration(): number {\r\n\t\treturn $time.getDuration(this.baseInterval.timeUnit, this.baseInterval.count);\r\n\t}\r\n\r\n\t/**\r\n\t * Adjusts min/max values.\r\n\t *\r\n\t * @ignore Exclude from docs.\r\n\t * @todo Description (review)\r\n\t * @param min  Min timestamp\r\n\t * @param max  Max timestamp\r\n\t * @return Adjusted min/max step\r\n\t */\r\n\tpublic adjustMinMax(min: number, max: number): IMinMaxStep {\r\n\t\treturn { min: min, max: max, step: this.baseDuration };\r\n\t}\r\n\r\n\t/**\r\n\t * Adjusts the minimum timestamp as per cell start location.\r\n\t *\r\n\t * @param value  Value\r\n\t * @return Adjusted value\r\n\t */\r\n\tprotected fixMin(value: number) {\r\n\t\t// like this because months are not equal\r\n\t\tlet interval = this.baseInterval;\r\n\r\n\t\tlet startTime = $time.round(\r\n\t\t\tnew Date(value),\r\n\t\t\tinterval.timeUnit,\r\n\t\t\tinterval.count,\r\n\t\t\tthis._firstWeekDay,\r\n\t\t\tthis._df.utc,\r\n\t\t\tundefined,\r\n\t\t\tthis._df.timezoneMinutes,\r\n\t\t\tthis._df.timezone\r\n\t\t).getTime();\r\n\t\tlet endTime = $time.add(new Date(startTime), interval.timeUnit, interval.count, this._df.utc).getTime();\r\n\r\n\t\treturn startTime + (endTime - startTime) * this.startLocation;\r\n\t}\r\n\r\n\t/**\r\n\t * Adjusts the maximum timestamp as per cell start location.\r\n\t *\r\n\t * @param value  Value\r\n\t * @return Adjusted value\r\n\t */\r\n\tprotected fixMax(value: number) {\r\n\t\t// like this because months are not equal\r\n\t\tlet interval = this.baseInterval;\r\n\r\n\t\tlet startTime = $time.round(\r\n\t\t\tnew Date(value),\r\n\t\t\tinterval.timeUnit,\r\n\t\t\tinterval.count,\r\n\t\t\tthis._firstWeekDay,\r\n\t\t\tthis._df.utc,\r\n\t\t\tundefined,\r\n\t\t\tthis._df.timezoneMinutes,\r\n\t\t\tthis._df.timezone\r\n\t\t).getTime();\r\n\t\tlet endTime = $time.add(new Date(startTime), interval.timeUnit, interval.count, this._df.utc).getTime();\r\n\r\n\t\treturn startTime + (endTime - startTime) * this.endLocation;\r\n\t}\r\n\r\n\t/**\r\n\t * [chooseInterval description]\r\n\t *\r\n\t * @ignore Exclude from docs.\r\n\t * @todo Description\r\n\t * @param index      [description]\r\n\t * @param duration   [description]\r\n\t * @param gridCount  [description]\r\n\t * @return [description]\r\n\t */\r\n\tpublic chooseInterval(index: number, duration: number, gridCount: number, intervals?: List<ITimeInterval>): ITimeInterval {\r\n\t\tif (!intervals) {\r\n\t\t\tintervals = this.gridIntervals;\r\n\t\t}\r\n\r\n\t\tlet gridInterval: ITimeInterval = intervals.getIndex(index);\r\n\r\n\t\tlet intervalDuration: number = $time.getDuration(gridInterval.timeUnit, gridInterval.count);\r\n\r\n\t\tlet lastIndex: number = intervals.length - 1;\r\n\t\tif (index >= lastIndex) {\r\n\t\t\treturn { ...intervals.getIndex(lastIndex) };\r\n\t\t}\r\n\r\n\t\tlet count: number = Math.ceil(duration / intervalDuration);\r\n\r\n\t\tif (duration < intervalDuration && index > 0) {\r\n\t\t\treturn { ...intervals.getIndex(index - 1) };\r\n\t\t}\r\n\t\tif (count <= gridCount) {\r\n\t\t\treturn { ...intervals.getIndex(index) };\r\n\t\t} else {\r\n\t\t\tif (index + 1 < intervals.length) {\r\n\t\t\t\treturn this.chooseInterval(index + 1, duration, gridCount, intervals);\r\n\t\t\t} else {\r\n\t\t\t\treturn { ...intervals.getIndex(index) };\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Formats the value according to axis' own [[DateFormatter]].\r\n\t *\r\n\t * @param value  Source value\r\n\t * @return Formatted value\r\n\t */\r\n\tpublic formatLabel(value: number): string {\r\n\t\treturn this._df.format(value);\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a Date to an asbolute pixel position within Axis.\r\n\t *\r\n\t * @param date  Date\r\n\t * @return Position (px)\r\n\t */\r\n\tpublic dateToPosition(date: Date): number {\r\n\t\treturn this.valueToPosition(date.getTime());\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a numeric timestamp or a `Date` to a relative position on axis.\r\n\t *\r\n\t * @param date  Date or a timestamp\r\n\t * @return Relative position\r\n\t */\r\n\tpublic anyToPosition(date: Date | number): number {\r\n\t\tif (date instanceof Date) {\r\n\t\t\treturn this.dateToPosition(date);\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn this.valueToPosition(date);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Converts date to orientation point (x, y, angle) on axis\r\n\t *\r\n\t * @param date Date\r\n\t * @return IOrientationPoint\r\n\t */\r\n\tpublic dateToPoint(date: Date): IOrientationPoint {\r\n\t\tlet position = this.dateToPosition(date);\r\n\t\tlet point = this.renderer.positionToPoint(position);\r\n\t\tlet angle = this.renderer.positionToAngle(position);\r\n\t\treturn { x: point.x, y: point.y, angle: angle };\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Converts a numeric value to orientation (x, y, angle) point on axis\r\n\t *\r\n\t * @param value  Value\r\n\t * @return Orientation point\r\n\t */\r\n\tpublic anyToPoint(date: Date | number): IOrientationPoint {\r\n\t\tif (date instanceof Date) {\r\n\t\t\treturn this.dateToPoint(date);\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn this.valueToPoint(date);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Converts pixel position within Axis to a corresponding Date.\r\n\t *\r\n\t * @param position  Position (px)\r\n\t * @return Date\r\n\t */\r\n\tpublic positionToDate(position: number): Date {\r\n\t\treturn new Date(this.positionToValue(position));\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the relative position on axis for series' data item's value.\r\n\t *\r\n\t * @since 4.5.14\r\n\t * @param  dataItem  Data item\r\n\t * @param  key       Data field to get value from\r\n\t * @param  location  Location (0-1)\r\n\t * @return           Relative position\r\n\t */\r\n\tpublic getPositionX(dataItem: XYSeriesDataItem, key: string, location?: number, stackKey?: string, range?: IRange): number {\r\n\t\tlet value: number = this.getTimeByLocation(dataItem, key, location);\r\n\t\t//let stack: number = dataItem.getValue(\"valueX\", \"stack\");\r\n\r\n\t\tif (!$type.isNumber(value)) {\r\n\t\t\tvalue = this.baseValue;\r\n\t\t}\r\n\r\n\t\tlet position = this.valueToPosition(value);\r\n\t\tif (range) {\r\n\t\t\tposition = $math.fitToRange(position, range.start, range.end);\r\n\t\t}\r\n\r\n\t\treturn position;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Returns relative position on axis for series' data item's value.\r\n\t *\r\n\t * @since 4.5.14\r\n\t * @param  dataItem  Data item\r\n\t * @param  key       Data field to get value from\r\n\t * @param  location  Location (0-1)\r\n\t * @return           Relative position\r\n\t */\r\n\tpublic getPositionY(dataItem: XYSeriesDataItem, key: string, location?: number, stackKey?: string, range?: IRange): number {\r\n\t\tlet value: number = this.getTimeByLocation(dataItem, key, location);\r\n\t\tlet stack: number = dataItem.getValue(\"valueX\", \"stack\");\r\n\r\n\t\tif (!$type.isNumber(value)) {\r\n\t\t\tvalue = this.baseValue;\r\n\t\t}\r\n\r\n\t\tlet position = this.valueToPosition(value + stack);\r\n\t\tif (range) {\r\n\t\t\tposition = $math.fitToRange(position, range.start, range.end);\r\n\t\t}\r\n\r\n\t\treturn position;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an angle for series data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t * @param dataItem  Data item\r\n\t * @param key       Data field to get value from\r\n\t * @param location  Location (0-1)\r\n\t * @param stackKey  Stack ID\r\n\t * @param range Range to fit in\r\n\t * @return Angle\r\n\t */\r\n\tpublic getAngle(dataItem: XYSeriesDataItem, key: string, location?: number, stackKey?: string, range?: IRange): number {\r\n\t\tlet value: number = this.getTimeByLocation(dataItem, key, location);\r\n\t\tlet stack: number = dataItem.getValue(stackKey, \"stack\");\r\n\r\n\t\tif (!$type.isNumber(value)) {\r\n\t\t\tvalue = this.baseValue;\r\n\t\t}\r\n\r\n\t\tlet position = this.valueToPosition(value + stack);\r\n\t\tif (range) {\r\n\t\t\tposition = $math.fitToRange(position, range.start, range.end);\r\n\t\t}\r\n\r\n\t\treturn this.positionToAngle(position);\r\n\t}\r\n\r\n\t/**\r\n\t * [getTimeByLocation description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @param dataItem  [description]\r\n\t * @param key       [description]\r\n\t * @param location  [description]\r\n\t * @return [description]\r\n\t */\r\n\tprotected getTimeByLocation(dataItem: XYSeriesDataItem, key: string, location: number): number {\r\n\r\n\t\tif (!$type.hasValue(key)) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (!$type.isNumber(location)) {\r\n\t\t\tlocation = dataItem.workingLocations[key];\r\n\r\n\t\t\tif (!$type.isNumber(location)) {\r\n\t\t\t\tlocation = 0;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet startTime: number = dataItem.values[key][\"open\"];\r\n\t\tlet endTime: number = dataItem.values[key][\"close\"];\r\n\r\n\t\tlet workingValue = dataItem.values[key].workingValue;\r\n\t\tlet value = dataItem.values[key].value;\r\n\r\n\t\tlet difference = value - workingValue;\r\n\t\tstartTime -= difference;\r\n\t\tendTime -= difference;\r\n\r\n\t\tif ($type.isNumber(startTime) && $type.isNumber(endTime)) {\r\n\t\t\treturn startTime + (endTime - startTime) * location;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Processes a related series' data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @param dataItem  Data item\r\n\t */\r\n\tpublic processSeriesDataItem(dataItem: XYSeriesDataItem, axisLetter?: string): void {\r\n\t\tlet series = dataItem.component;\r\n\t\tlet time: number;\r\n\r\n\t\tlet date: Date = (<any>dataItem)[\"date\" + axisLetter];\r\n\r\n\t\tif ($type.isNumber(this.timezoneOffset)) {\r\n\t\t\tdate.setTime(date.getTime() + (date.getTimezoneOffset() - this.timezoneOffset) * 60000)\r\n\t\t\tdataItem.setValue(\"date\" + axisLetter, date.getTime(), 0);\r\n\t\t}\r\n\t\telse if ($type.hasValue(this.timezone)) {\r\n\t\t\tdate = $time.setTimezone(date, this.timezone);\r\n\t\t\tdataItem.setValue(\"date\" + axisLetter, date.getTime(), 0);\r\n\t\t\t(<any>dataItem)[\"date\" + axisLetter] = date;\r\n\t\t}\r\n\r\n\t\tif (date) {\r\n\t\t\ttime = date.getTime();\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet openDate: Date = (<any>dataItem)[\"openDate\" + axisLetter];\r\n\t\tlet prevSeriesTime: number = this._prevSeriesTime[series.uid];\r\n\r\n\r\n\t\tlet openTime: number;\r\n\t\tif (openDate) {\r\n\t\t\topenTime = openDate.getTime();\r\n\t\t}\r\n\r\n\t\tif ($type.isNumber(openTime)) {\r\n\t\t\tlet difference = Math.abs(time - openTime);\r\n\r\n\t\t\tif (this._minDifference[series.uid] > difference) {\r\n\t\t\t\tthis._minDifference[series.uid] = difference;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet differece: number = time - prevSeriesTime;\r\n\r\n\t\tif (differece > 0) {\r\n\t\t\tif (this._minDifference[series.uid] > differece) {\r\n\t\t\t\tthis._minDifference[series.uid] = differece;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis._prevSeriesTime[series.uid] = time;\r\n\r\n\t\tif (series._baseInterval[this.uid]) {\r\n\t\t\tthis.postProcessSeriesDataItem(dataItem);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * [updateAxisBySeries description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t */\r\n\tpublic updateAxisBySeries() {\r\n\t\tsuper.updateAxisBySeries();\r\n\r\n\t\tlet baseInterval: ITimeInterval = this.chooseInterval(0, this.minDifference, 1);\r\n\r\n\t\t// handle short months\r\n\r\n\t\tif (this.minDifference >= $time.getDuration(\"day\", 27) && baseInterval.timeUnit == \"week\") {\r\n\t\t\tbaseInterval.timeUnit = \"month\";\r\n\t\t\tbaseInterval.count = 1;\r\n\t\t}\r\n\t\tif (baseInterval.timeUnit == \"month\") {\r\n\t\t\tif (this.minDifference >= $time.getDuration(\"day\", 29 * 2) && baseInterval.count == 1) {\r\n\t\t\t\tbaseInterval.count = 2;\r\n\t\t\t}\r\n\r\n\t\t\tif (this.minDifference >= $time.getDuration(\"day\", 29 * 3) && baseInterval.count == 2) {\r\n\t\t\t\tbaseInterval.count = 3;\r\n\t\t\t}\r\n\r\n\t\t\tif (this.minDifference >= $time.getDuration(\"day\", 29 * 6) && baseInterval.count == 5) {\r\n\t\t\t\tbaseInterval.count = 6;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// handle daylight saving\r\n\t\tif (this.minDifference >= $time.getDuration(\"hour\", 23) && baseInterval.timeUnit == \"hour\") {\r\n\t\t\tbaseInterval.timeUnit = \"day\";\r\n\t\t\tbaseInterval.count = 1;\r\n\t\t}\r\n\r\n\t\tif (this.minDifference >= $time.getDuration(\"week\", 1) - $time.getDuration(\"hour\", 1) && baseInterval.timeUnit == \"day\") {\r\n\t\t\tbaseInterval.timeUnit = \"week\";\r\n\t\t\tbaseInterval.count = 1;\r\n\t\t}\r\n\r\n\t\tif (this.minDifference >= $time.getDuration(\"year\", 1) - $time.getDuration(\"day\", 1.01) && baseInterval.timeUnit == \"month\") {\r\n\t\t\tbaseInterval.timeUnit = \"year\";\r\n\t\t\tbaseInterval.count = 1;\r\n\t\t}\r\n\r\n\t\tthis._baseIntervalReal = baseInterval;\r\n\t\tthis._mainBaseInterval = baseInterval;\r\n\r\n\t\t// no need to invalidate\r\n\t}\r\n\r\n\t/**\r\n\t * A base interval (granularity) of data.\r\n\t *\r\n\t * Used to indicate what are the base units of your data.\r\n\t *\r\n\t * For example, if you have a data set that has a data point every 5 minutes,\r\n\t * you may want to set this to `{ timeUnit: \"minute\", count: 5 }`.\r\n\t *\r\n\t * If not set, the Axis will try to determine the setting by its own, looking\r\n\t * at actual data.\r\n\t *\r\n\t * For best results, try to follow these values for `count`:\r\n\t *\r\n\t * When unit is \"month\", use 12 / count = round number\r\n\t * When unit is \"hour\", use 24 / count = round number\r\n\t * When unit is \"second\" and \"minute\", use 60 / count = round number\r\n\t *\r\n\t * @param timeInterval base interval\r\n\t */\r\n\tpublic set baseInterval(timeInterval: ITimeInterval) {\r\n\t\tif (JSON.stringify(this._baseInterval) != JSON.stringify(timeInterval)) {\r\n\t\t\tthis._baseInterval = timeInterval;\r\n\t\t\tthis._mainBaseInterval = timeInterval;\r\n\t\t\tif (!$type.isNumber(timeInterval.count)) {\r\n\t\t\t\ttimeInterval.count = 1;\r\n\t\t\t}\r\n\t\t\tthis.invalidate();\r\n\t\t\tthis.postProcessSeriesDataItems();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Base interval\r\n\t */\r\n\tpublic get baseInterval(): ITimeInterval {\r\n\t\tif (this._groupInterval) {\r\n\t\t\treturn this._groupInterval;\r\n\t\t}\r\n\t\telse if (this._baseInterval) {\r\n\t\t\treturn this._baseInterval;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn this._baseIntervalReal;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Indicates granularity of the data of source (unaggregated) data.\r\n\t *\r\n\t * @since 4.7.0\r\n\t * @return Granularity of the main data set\r\n\t */\r\n\tpublic get mainBaseInterval(): ITimeInterval {\r\n\t\tif (this._baseInterval) {\r\n\t\t\treturn this._baseInterval;\r\n\t\t}\r\n\t\telse if (this._mainBaseInterval) {\r\n\t\t\treturn this._mainBaseInterval;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn this._baseIntervalReal;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * If enabled, axis will automatically collapse empty (without data points)\r\n\t * periods of time, i.e. weekends.\r\n\t *\r\n\t * An \"empty\" period is considered a stretch of time in the length of current\r\n\t * `baseInterval` without a single data point in it.\r\n\t *\r\n\t * For each such empty period, axis will automatically create an\r\n\t * [[AxisBreak]]. By default they will be invisible. You can still configure\r\n\t * them by accessing `axis.breaks.template`.\r\n\t *\r\n\t * [More info about breaks](https://www.amcharts.com/docs/v4/concepts/axes/#Breaks).\r\n\t *\r\n\t * Important notes:\r\n\t * * If you set this property to `true`, you can not add your custom axis breaks to this axis anymore.\r\n\t * * Using this feature affects performance. Use only if you need it.\r\n\t * * Setting this to `true` will reset appearance of breaks. If you want to modify appearance, do it *after* you set `skipEmptyPeriods`.\r\n\t * * Some axis label overlapping might happen.\r\n\t * * This setting is not compatible with `groupData = true`.\r\n\t *\r\n\t * @default false\r\n\t * @param value  Remove empty stretches of time?\r\n\t */\r\n\tpublic set skipEmptyPeriods(value: boolean) {\r\n\r\n\t\tif (value) {\r\n\t\t\tlet breakTemplate = this.axisBreaks.template;\r\n\t\t\tbreakTemplate.startLine.disabled = true;\r\n\t\t\tbreakTemplate.endLine.disabled = true;\r\n\t\t\tbreakTemplate.fillShape.disabled = true;\r\n\t\t\tbreakTemplate.breakSize = 0;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (this._gapBreaks) {\r\n\t\t\t\tthis.axisBreaks.clear();\r\n\t\t\t\tthis._gapBreaks = false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (this.setPropertyValue(\"skipEmptyPeriods\", value)) {\r\n\t\t\tthis.invalidate();\r\n\t\t\tthis.postProcessSeriesDataItems();\r\n\t\t\tthis.invalidateSeries();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Remove empty stretches of time?\r\n\t */\r\n\tpublic get skipEmptyPeriods(): boolean {\r\n\t\treturn this.getPropertyValue(\"skipEmptyPeriods\");\r\n\t}\r\n\r\n\t/**\r\n\t * A special date format to apply axis tooltips.\r\n\t *\r\n\t * Will use same format as for labels, if not set.\r\n\t *\r\n\t * @param value  Date format\r\n\t */\r\n\tpublic set tooltipDateFormat(value: string | Intl.DateTimeFormatOptions) {\r\n\t\tthis.setPropertyValue(\"tooltipDateFormat\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Date format\r\n\t */\r\n\tpublic get tooltipDateFormat(): string | Intl.DateTimeFormatOptions {\r\n\t\treturn this.getPropertyValue(\"tooltipDateFormat\");\r\n\t}\r\n\r\n\t/**\r\n\t * Use `periodChangeDateFormats` to apply different formats to the first\r\n\t * label in bigger time unit.\r\n\t *\r\n\t * @default true\r\n\t * @param value  Use different format for period beginning?\r\n\t */\r\n\tpublic set markUnitChange(value: boolean) {\r\n\t\tif (this.setPropertyValue(\"markUnitChange\", value)) {\r\n\t\t\tthis.invalidateData();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Use different format for period beginning?\r\n\t */\r\n\tpublic get markUnitChange(): boolean {\r\n\t\treturn this.getPropertyValue(\"markUnitChange\");\r\n\t}\r\n\r\n\t/**\r\n\t * Returns text to show in a tooltip, based on specific relative position\r\n\t * within axis.\r\n\t *\r\n\t * The label will be formatted as per [[DateFormatter]] set for the whole\r\n\t * chart, or explicitly for this Axis.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param position  Position\r\n\t * @return Label (formatted date)\r\n\t */\r\n\tpublic getTooltipText(position: number): string {\r\n\t\tlet text: string;\r\n\t\tlet date = this.positionToDate(position);\r\n\t\tdate = $time.round(\r\n\t\t\tdate,\r\n\t\t\tthis.baseInterval.timeUnit,\r\n\t\t\tthis.baseInterval.count,\r\n\t\t\tthis._firstWeekDay,\r\n\t\t\tthis._df.utc,\r\n\t\t\tnew Date(this.min),\r\n\t\t\tthis._df.timezoneMinutes,\r\n\t\t\tthis._df.timezone\r\n\t\t);\r\n\r\n\t\tthis.tooltipDate = date;\r\n\r\n\t\tif ($type.hasValue(this.tooltipDateFormat)) {\r\n\t\t\ttext = this._df.format(date, this.tooltipDateFormat, [\"day\", \"month\", \"week\", \"year\"].indexOf(this.baseInterval.timeUnit) == -1);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tlet dateFormat = this.dateFormats.getKey(this.baseInterval.timeUnit);\r\n\t\t\tif (dateFormat) {\r\n\t\t\t\ttext = this._df.format(date, dateFormat);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\ttext = this.getPositionLabel(position);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!this._adapterO) {\r\n\t\t\treturn text;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn this._adapterO.apply(\"getTooltipText\", text);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Takes an absolute position within axis and adjust it to a specific position within base interval. (cell)\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param position Source position\r\n\t * @param location  Location in the cell\r\n\t * @return Adjusted position\r\n\t */\r\n\tpublic roundPosition(position: number, location?: AxisItemLocation, axisLocation?: number): number {\r\n\t\tlet baseInterval = this.baseInterval;\r\n\t\tlet timeUnit = baseInterval.timeUnit;\r\n\t\tlet count = baseInterval.count;\r\n\r\n\t\tlet date: Date = this.positionToDate(position);\r\n\r\n\t\t$time.round(\r\n\t\t\tdate,\r\n\t\t\ttimeUnit,\r\n\t\t\tcount,\r\n\t\t\tthis._firstWeekDay,\r\n\t\t\tthis._df.utc,\r\n\t\t\tundefined,\r\n\t\t\tthis._df.timezoneMinutes,\r\n\t\t\tthis._df.timezone\r\n\t\t);\r\n\r\n\t\tif (location > 0) {\r\n\t\t\t$time.add(date, timeUnit, location * count, this._df.utc);\r\n\t\t}\r\n\r\n\t\tif (axisLocation > 0 && axisLocation < 1) {\r\n\t\t\tdate.setTime(date.getTime() + this.baseDuration * axisLocation);\r\n\t\t}\r\n\r\n\t\tif (this.isInBreak(date.getTime())) {\r\n\t\t\twhile (date.getTime() < this.max) {\r\n\t\t\t\t$time.add(date, timeUnit, count, this._df.utc);\r\n\t\t\t\tif (!this.isInBreak(date.getTime())) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this.dateToPosition(date);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an relative position of the start of the cell (period), that specific position value falls into.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t * @param position  Relative position\r\n\t * @return Cell start relative position\r\n\t */\r\n\tpublic getCellStartPosition(position: number): number {\r\n\t\treturn this.roundPosition(position, 0);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an relative position of the end of the cell (period), that specific position value falls into.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t * @param position  Relative position\r\n\t * @return Cell end relative position\r\n\t */\r\n\tpublic getCellEndPosition(position: number): number {\r\n\t\treturn this.roundPosition(position, 1);\r\n\t\t//return this.dateToPosition($time.add(this.positionToDate(this.roundPosition(position, 1)), this.baseInterval.timeUnit, this.baseInterval.count));\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a Series data item that corresponds to the specific pixel position\r\n\t * of the Axis.\r\n\t *\r\n\t * If `findNearest` (third parameter) is set to `true`, the method will try\r\n\t * to locate nearest available data item if none is found directly under\r\n\t * `position`.\r\n\t *\r\n\t * @param series       Series\r\n\t * @param position     Position (px)\r\n\t * @param findNearest  Should axis try to find nearest tooltip if there is no data item at exact position\r\n\t * @return Data item\r\n\t */\r\n\tpublic getSeriesDataItem(series: XYSeries, position: number, findNearest?: boolean): XYSeriesDataItem {\r\n\r\n\t\tlet value: number = this.positionToValue(position);\r\n\r\n\t\tlet location = 0.5;\r\n\t\tif (this.axisLetter == \"Y\") {\r\n\t\t\tlocation = series.dataItems.template.locations.dateY;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tlocation = series.dataItems.template.locations.dateX;\r\n\t\t}\r\n\r\n\t\tlet deltaValue = value - location * this.baseDuration;\r\n\r\n\t\tlet date: Date = $time.round(\r\n\t\t\tnew Date(value),\r\n\t\t\tthis.baseInterval.timeUnit,\r\n\t\t\tthis.baseInterval.count,\r\n\t\t\tthis._firstWeekDay,\r\n\t\t\tthis._df.utc,\r\n\t\t\tundefined,\r\n\t\t\tthis._df.timezoneMinutes,\r\n\t\t\tthis._df.timezone\r\n\t\t);\r\n\t\tlet nextDate: Date = $time.round(\r\n\t\t\tnew Date(value + this.baseDuration),\r\n\t\t\tthis.baseInterval.timeUnit,\r\n\t\t\tthis.baseInterval.count,\r\n\t\t\tthis._firstWeekDay,\r\n\t\t\tthis._df.utc,\r\n\t\t\tundefined,\r\n\t\t\tthis._df.timezoneMinutes,\r\n\t\t\tthis._df.timezone\r\n\t\t);\r\n\r\n\t\tif (nextDate.getTime() > date.getTime()) {\r\n\t\t\tif (Math.abs(nextDate.getTime() - deltaValue) < Math.abs(deltaValue - date.getTime())) {\r\n\t\t\t\tdate = nextDate;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet dataItemsByAxis = series.dataItemsByAxis.getKey(this.uid);\r\n\r\n\t\tlet dataItem = dataItemsByAxis.getKey(date.getTime() + series.currentDataSetId);\r\n\r\n\t\t// todo:  alternatively we can find closiest here\r\n\t\tif (!dataItem && findNearest) {\r\n\r\n\t\t\tlet key: \"dateX\" | \"dateY\";\r\n\r\n\t\t\tif (this.axisLetter == \"Y\") {\r\n\t\t\t\tkey = \"dateY\";\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tkey = \"dateX\";\r\n\t\t\t}\r\n\r\n\t\t\tdataItem = series.dataItems.getIndex(series.dataItems.findClosestIndex(date.getTime(), (x) => {\r\n\t\t\t\tif (x[key]) {\r\n\t\t\t\t\treturn <number>x[key].getTime();\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\treturn -Infinity;\r\n\t\t\t\t}\r\n\t\t\t}, \"any\"));\r\n\t\t}\r\n\r\n\t\treturn dataItem;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a formatted date based on position in axis scale.\r\n\t *\r\n\t * Please note that `position` represents position within axis which may be\r\n\t * zoomed and not correspond to Cursor's `position`.\r\n\t *\r\n\t * To convert Cursor's `position` to Axis' `position` use `toAxisPosition()` method.\r\n\t *\r\n\t * @see {@link https://www.amcharts.com/docs/v4/tutorials/tracking-cursors-position-via-api/#Tracking_Cursor_s_position} For more information about cursor tracking.\r\n\t * @param position  Relative position on axis (0-1)\r\n\t * @return Position label\r\n\t */\r\n\tpublic getPositionLabel(position: number): string {\r\n\t\t// @todo Better format recognition\r\n\t\tlet date = this.positionToDate(position);\r\n\t\treturn this._df.format(date, this.getCurrentLabelFormat());\r\n\t}\r\n\r\n\t/**\r\n\t * Returns label date format based on currently used time units\r\n\t *\r\n\t * @return Format\r\n\t */\r\n\tprotected getCurrentLabelFormat(): string | Intl.DateTimeFormatOptions {\r\n\t\treturn this.dateFormats.getKey(this._gridInterval ? this._gridInterval.timeUnit : \"day\");\r\n\t}\r\n\r\n\t/**\r\n\t * Initializes an Axis renderer.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic initRenderer(): void {\r\n\t\tsuper.initRenderer();\r\n\t\tlet renderer = this.renderer;\r\n\t\tif (renderer) {\r\n\t\t\t// Set defaults\r\n\t\t\trenderer.ticks.template.location = 0;\r\n\t\t\trenderer.grid.template.location = 0;\r\n\t\t\trenderer.labels.template.location = 0;\r\n\t\t\trenderer.baseGrid.disabled = true;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Coordinates of the actual axis start.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @return Base point\r\n\t */\r\n\tpublic get basePoint(): IPoint {\r\n\t\treturn { x: 0, y: 0 };\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected animateMinMax(min: number, max: number): Animation {\r\n\t\tlet animation = this.animate([{ property: \"_minAdjusted\", from: this._minAdjusted, to: min }, { property: \"_maxAdjusted\", from: this._maxAdjusted, to: max }], this.rangeChangeDuration, this.rangeChangeEasing);\r\n\t\tanimation.events.on(\"animationprogress\", () => {\r\n\t\t\tthis.dispatch(\"extremeschanged\");\r\n\t\t})\r\n\t\treturn animation;\r\n\t}\r\n\r\n\t/**\r\n\t * Invalidates axis data items when series extremes change\r\n\t */\r\n\tprotected handleExtremesChange() {\r\n\t\tsuper.handleExtremesChange();\r\n\r\n\t\tif (this.groupData) {\r\n\t\t\tlet id = this.baseInterval.timeUnit + this.baseInterval.count;\r\n\t\t\tthis.groupMin[id] = this._finalMin;\r\n\t\t\tthis.groupMax[id] = this._finalMax;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Zooms axis to specific Dates.\r\n\t *\r\n\t * @param startDate       Start date\r\n\t * @param endValue        End date\r\n\t * @param skipRangeEvent  Do not invoke events\r\n\t * @param instantly       Do not play zoom animations\r\n\t */\r\n\tpublic zoomToDates(startDate: Date, endDate: Date, skipRangeEvent?: boolean, instantly?: boolean, adjust?: boolean): void {\r\n\t\tstartDate = this._df.parse(startDate);\r\n\t\tendDate = this._df.parse(endDate);\r\n\t\tthis.zoomToValues(startDate.getTime(), endDate.getTime(), skipRangeEvent, instantly, adjust);\r\n\t}\r\n\r\n\t/**\r\n\t * Zooms axis to specific values.\r\n\t *\r\n\t * @param startValue      Start value\r\n\t * @param endValue        End value\r\n\t * @param skipRangeEvent  Do not invoke events\r\n\t * @param instantly       Do not play zoom animations\r\n\t */\r\n\tpublic zoomToValues(startValue: number, endValue: number, skipRangeEvent?: boolean, instantly?: boolean, adjust?: boolean): void {\r\n\t\tif (!this.groupData) {\r\n\t\t\t//let start: number = (startValue - this.min) / (this.max - this.min);\r\n\t\t\t//let end: number = (endValue - this.min) / (this.max - this.min);\r\n\r\n\t\t\tlet start = this.valueToPosition(startValue);\r\n\t\t\tlet end = this.valueToPosition(endValue);\r\n\r\n\t\t\tthis.zoom({ start: start, end: end }, skipRangeEvent, instantly);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tlet difference = this.adjustDifference(startValue, endValue);\r\n\t\t\tlet isEnd = false;\r\n\t\t\tif (endValue == this.max) {\r\n\t\t\t\tisEnd = true;\r\n\t\t\t}\r\n\t\t\tlet isStart = false;\r\n\t\t\tif (startValue == this.min) {\r\n\t\t\t\tisStart = true;\r\n\t\t\t}\r\n\r\n\t\t\tif ($type.hasValue(difference)) {\r\n\t\t\t\tlet mainBaseInterval = this.mainBaseInterval;\r\n\t\t\t\tlet groupInterval = this.chooseInterval(0, difference, this.groupCount, this.groupIntervals);\r\n\r\n\t\t\t\tif ((groupInterval.timeUnit == mainBaseInterval.timeUnit && groupInterval.count < mainBaseInterval.count) || $time.getDuration(groupInterval.timeUnit, 1) < $time.getDuration(mainBaseInterval.timeUnit, 1)) {\r\n\t\t\t\t\tgroupInterval = { ...mainBaseInterval };\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet id = groupInterval.timeUnit + groupInterval.count;\r\n\t\t\t\tlet min = this.groupMin[id];\r\n\t\t\t\tlet max = this.groupMax[id];\r\n\r\n\t\t\t\tif (!$type.isNumber(min) || !$type.isNumber(max)) {\r\n\t\t\t\t\tmin = Number.POSITIVE_INFINITY;\r\n\t\t\t\t\tmax = Number.NEGATIVE_INFINITY;\r\n\t\t\t\t\tthis.series.each((series) => {\r\n\t\t\t\t\t\tlet seriesMin = series.min(this);\r\n\t\t\t\t\t\tlet seriesMax = series.max(this);\r\n\r\n\t\t\t\t\t\tif (series._dataSets) {\r\n\t\t\t\t\t\t\tlet ds = series._dataSets.getKey(groupInterval.timeUnit + groupInterval.count);\r\n\r\n\t\t\t\t\t\t\tif (ds) {\r\n\t\t\t\t\t\t\t\tlet mindi = ds.getIndex(0);\r\n\t\t\t\t\t\t\t\tlet maxdi = ds.getIndex(ds.length - 1);\r\n\r\n\t\t\t\t\t\t\t\tif (mindi) {\r\n\t\t\t\t\t\t\t\t\tif (series.xAxis == this) {\r\n\t\t\t\t\t\t\t\t\t\tseriesMin = mindi.dateX.getTime();\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\telse if (series.yAxis == this) {\r\n\t\t\t\t\t\t\t\t\t\tseriesMin = mindi.dateY.getTime();\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tif (maxdi) {\r\n\t\t\t\t\t\t\t\t\tif (series.xAxis == this) {\r\n\t\t\t\t\t\t\t\t\t\tseriesMax = maxdi.dateX.getTime();\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\telse if (series.yAxis == this) {\r\n\t\t\t\t\t\t\t\t\t\tseriesMax = maxdi.dateY.getTime();\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tseriesMax = $time.round(\r\n\t\t\t\t\t\t\t$time.add(new Date(seriesMax), groupInterval.timeUnit, 1, this._df.utc),\r\n\t\t\t\t\t\t\tgroupInterval.timeUnit,\r\n\t\t\t\t\t\t\t1,\r\n\t\t\t\t\t\t\tthis._df.firstDayOfWeek,\r\n\t\t\t\t\t\t\tthis._df.utc,\r\n\t\t\t\t\t\t\tundefined,\r\n\t\t\t\t\t\t\tthis._df.timezoneMinutes,\r\n\t\t\t\t\t\t\tthis._df.timezone\r\n\t\t\t\t\t\t).getTime();\r\n\r\n\t\t\t\t\t\tif (seriesMin < min) {\r\n\t\t\t\t\t\t\tmin = seriesMin;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (seriesMax > max) {\r\n\t\t\t\t\t\t\tmax = seriesMax;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t\tthis.groupMin[id] = min;\r\n\t\t\t\t\tthis.groupMax[id] = max;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tstartValue = $math.fitToRange(startValue, min, max);\r\n\t\t\t\tendValue = $math.fitToRange(endValue, min, max);\r\n\r\n\t\t\t\tif (adjust) {\r\n\t\t\t\t\tif (isEnd) {\r\n\t\t\t\t\t\tstartValue = endValue - difference;\r\n\t\t\t\t\t\tstartValue = $math.fitToRange(startValue, min, max);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (isStart) {\r\n\t\t\t\t\t\tendValue = startValue + difference;\r\n\t\t\t\t\t\tendValue = $math.fitToRange(endValue, min, max);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet start: number = (startValue - min) / (max - min);\r\n\t\t\t\tlet end: number = (endValue - min) / (max - min);\r\n\r\n\t\t\t\tthis.zoom({ start: start, end: end }, skipRangeEvent, instantly);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Adds `baseInterval` to \"as is\" fields.\r\n\t *\r\n\t * @param field  Field name\r\n\t * @return Assign as is?\r\n\t */\r\n\tprotected asIs(field: string): boolean {\r\n\t\treturn field == \"baseInterval\" || super.asIs(field);\r\n\t}\r\n\r\n\t/**\r\n\t * Copies all properties and related data from a different instance of Axis.\r\n\t *\r\n\t * @param source Source Axis\r\n\t */\r\n\tpublic copyFrom(source: this): void {\r\n\t\tsuper.copyFrom(source);\r\n\t\tthis.dateFormats = source.dateFormats;\r\n\t\tthis.periodChangeDateFormats = source.periodChangeDateFormats;\r\n\t\tthis.groupIntervals.clear();\r\n\t\tsource.groupIntervals.each((interval) => {\r\n\t\t\tthis.groupIntervals.push({ ...interval });\r\n\t\t})\r\n\r\n\t\tthis.gridIntervals.clear();\r\n\t\tsource.gridIntervals.each((interval) => {\r\n\t\t\tthis.gridIntervals.push({ ...interval });\r\n\t\t})\r\n\r\n\t\tif (source._baseInterval) {\r\n\t\t\tthis.baseInterval = source._baseInterval;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Shows Axis tooltip at specific relative position within Axis. (0-1)\r\n\t *\r\n\t * @param position Position (0-1)\r\n\t * @param local or global position\r\n\t */\r\n\tpublic showTooltipAtPosition(position: number, local?: boolean) {\r\n\r\n\t\tif (!local) {\r\n\t\t\tposition = this.toAxisPosition(position);\r\n\t\t}\r\n\r\n\t\tif (this.snapTooltip) {\r\n\t\t\t// rounding is not good, pen/aac4e7f66f019d36b2447f050c600c13 (no last tootltip shown)\r\n\t\t\tlet actualDate = this.positionToDate(position) //$time.round(this.positionToDate(position), this.baseInterval.timeUnit, 1, this.getFirstWeekDay(), this.dateFormatter.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\r\n\r\n\t\t\tlet actualTime = actualDate.getTime();\r\n\t\t\tlet closestDate: Date;\r\n\r\n\t\t\tthis.series.each((series) => {\r\n\t\t\t\tif (series.baseAxis == this) {\r\n\t\t\t\t\tlet dataItem = this.getSeriesDataItem(series, position, true);\r\n\r\n\t\t\t\t\tif (dataItem) {\r\n\t\t\t\t\t\tlet date: Date;\r\n\t\t\t\t\t\tif (series.xAxis == this) {\r\n\t\t\t\t\t\t\tdate = dataItem.dateX;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (series.yAxis == this) {\r\n\t\t\t\t\t\t\tdate = dataItem.dateY;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (!closestDate) {\r\n\t\t\t\t\t\t\tclosestDate = date;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tif (Math.abs(closestDate.getTime() - actualTime) > Math.abs(date.getTime() - actualTime)) {\r\n\t\t\t\t\t\t\t\tclosestDate = date;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\r\n\t\t\tif (closestDate) {\r\n\t\t\t\tlet closestTime = closestDate.getTime();\r\n\t\t\t\tclosestDate = $time.round(\r\n\t\t\t\t\tnew Date(closestTime),\r\n\t\t\t\t\tthis.baseInterval.timeUnit,\r\n\t\t\t\t\tthis.baseInterval.count,\r\n\t\t\t\t\tthis._firstWeekDay,\r\n\t\t\t\t\tthis._df.utc,\r\n\t\t\t\t\tundefined,\r\n\t\t\t\t\tthis._df.timezoneMinutes,\r\n\t\t\t\t\tthis._df.timezone\r\n\t\t\t\t);\r\n\t\t\t\tclosestTime = closestDate.getTime();\r\n\r\n\t\t\t\tlet tooltipLocation = this.renderer.tooltipLocation;\r\n\t\t\t\tif (tooltipLocation == 0) {\r\n\t\t\t\t\ttooltipLocation = 0.0001;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tclosestDate = new Date(closestDate.getTime() + this.baseDuration * tooltipLocation);\r\n\t\t\t\tposition = this.dateToPosition(closestDate);\r\n\r\n\t\t\t\tif (this.chart.cursor && this.chart.cursor.snapToSeries) {\r\n\t\t\t\t\t//void\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthis.series.each((series) => {\r\n\r\n\t\t\t\t\t\tlet dataItem = series.dataItemsByAxis.getKey(this.uid).getKey(closestTime + series.currentDataSetId);\r\n\t\t\t\t\t\tlet point = series.showTooltipAtDataItem(dataItem);\r\n\t\t\t\t\t\tif (point) {\r\n\t\t\t\t\t\t\tthis.chart._seriesPoints.push({ series: series, point: point });\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t// check, otherwise column tooltip will be hidden\r\n\t\t\t\t\t\t\tif (series.tooltipText || series.tooltipHTML) {\r\n\t\t\t\t\t\t\t\tseries.hideTooltip();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//this.chart.sortSeriesTooltips(seriesPoints);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tsuper.showTooltipAtPosition(position, true);\r\n\t}\r\n\r\n\t/**\r\n\t * Should the nearest tooltip be shown if no data item is found on the\r\n\t * current cursor position.\r\n\t *\r\n\t * @default true\r\n\t * @param value  Should snap?\r\n\t */\r\n\tpublic set snapTooltip(value: boolean) {\r\n\t\tthis.setPropertyValue(\"snapTooltip\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Should snap?\r\n\t */\r\n\tpublic get snapTooltip(): boolean {\r\n\t\treturn this.getPropertyValue(\"snapTooltip\");\r\n\t}\r\n\r\n\t/**\r\n\t * Indicates if data should be aggregated to composide data items if there\r\n\t * are more data items in selected range than `groupCount`.\r\n\t *\r\n\t * Grouping will occur automatically, based on current selection range, and\r\n\t * will change dynamically when user zooms in/out the chart.\r\n\t *\r\n\t * NOTE: This works only if [[DateAxis]] is base axis of an [[XYSeries]].\r\n\t *\r\n\t * The related [[XYSeries]] also needs to be set up to take advantage of, by\r\n\t * setting its [`groupFields`](https://www.amcharts.com/docs/v4/reference/xyseries/#groupFields_property).\r\n\t *\r\n\t * The group intervals to aggregate data to is defined by `groupIntervals`\r\n\t * property.\r\n\t *\r\n\t * ```TypeScript\r\n\t * let dateAxis = chart.xAxes.push(new am4charts.DateAxis());\r\n\t * dateAxis.groupData = true;\r\n\t * \r\n\t * let valueAxis = chart.xAxes.push(new am4charts.valueAxis());\r\n\t * \r\n\t * let series = chart.series.push(new am4charts.LineSeries());\r\n\t * series.dataFields.dateX = \"date\";\r\n\t * series.dataFields.valueY = \"value\";\r\n\t * series.groupFields.valueY = \"average\";\r\n\t * ```\r\n\t * ```JavaScript\r\n\t * var dateAxis = chart.xAxes.push(new am4charts.DateAxis());\r\n\t * dateAxis.groupData = true;\r\n\t * \r\n\t * var valueAxis = chart.xAxes.push(new am4charts.valueAxis());\r\n\t * \r\n\t * var series = chart.series.push(new am4charts.LineSeries());\r\n\t * series.dataFields.dateX = \"date\";\r\n\t * series.dataFields.valueY = \"value\";\r\n\t * series.groupFields.valueY = \"average\";\r\n\t * ```\r\n\t * ```JSON\r\n\t * {\r\n\t *   // ...\r\n\t *   \"xAxes\": [{\r\n\t *     \"type\": \"DateAxis\",\r\n\t *     \"groupData\": true\r\n\t *   }],\r\n\t *   \"yAxes\": [{\r\n\t *     \"type\": \"ValueAxis\"\r\n\t *   }],\r\n\t *   \"series\": [{\r\n\t *     \"type\": \"LineSeries\",\r\n\t *     \"dataFields\": {\r\n\t *       \"dateX\": \"date\",\r\n\t *       \"valueY\": \"value\"\r\n\t *     },\r\n\t *     \"groupFields\": {\r\n\t *       \"valueY\": \"average\"\r\n\t *     }\r\n\t *   }]\r\n\t * }\r\n\t * ```\r\n\t *\r\n\t * @default false\r\n\t * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/date-axis/#Dynamic_data_item_grouping} for more information about dynamic data item grouping.\r\n\t * @since 4.7.0\r\n\t * @param  value  Group data points?\r\n\t */\r\n\tpublic set groupData(value: boolean) {\r\n\t\tif (this.setPropertyValue(\"groupData\", value)) {\r\n\t\t\tthis.series.each((series) => {\r\n\t\t\t\tseries.setDataSet(\"\");\r\n\r\n\t\t\t\tif (value && !series.dataGrouped && series.inited) {\r\n\t\t\t\t\tseries._baseInterval[this.uid] = this.mainBaseInterval;\r\n\t\t\t\t\tthis.groupSeriesData(series);\r\n\t\t\t\t}\r\n\t\t\t})\r\n\r\n\t\t\tthis._currentDataSetId = \"\"\r\n\t\t\tthis._groupInterval = undefined;\r\n\t\t\tthis.invalidate();\r\n\t\t\tthis.invalidateSeries();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Group data points?\r\n\t */\r\n\tpublic get groupData(): boolean {\r\n\t\treturn this.getPropertyValue(\"groupData\");\r\n\t}\r\n\r\n\t/**\r\n\t * Disables automatic selection of data grouping intervals and always uses\r\n\t * `groupInterval` if set. Works only if `groupData = true`.\r\n\t * \r\n\t * @since 4.9.24\r\n\t * @param  value  Interval\r\n\t */\r\n\tpublic set groupInterval(value: ITimeInterval) {\r\n\t\tif (this.setPropertyValue(\"groupInterval\", value)) {\r\n\t\t\tthis.invalidate();\r\n\t\t\tthis.invalidateSeries();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Interval\r\n\t */\r\n\tpublic get groupInterval(): ITimeInterval {\r\n\t\treturn this.getPropertyValue(\"groupInterval\");\r\n\t}\r\n\r\n\t/**\r\n\t * Indicates threshold of data items in selected range at which to start\r\n\t * aggregating data items if `groupData = true`.\r\n\t * \r\n\t * @default 200\r\n\t * @since 4.7.0\r\n\t * @param  value  Number of data items\r\n\t */\r\n\tpublic set groupCount(value: number) {\r\n\t\tthis.setPropertyValue(\"groupCount\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Number of data items\r\n\t */\r\n\tpublic get groupCount(): number {\r\n\t\treturn this.getPropertyValue(\"groupCount\");\r\n\t}\r\n\r\n\t/**\r\n\t * If set will recalculate all timestamps in data by applying specific offset\r\n\t * in minutes.\r\n\t *\r\n\t * IMPORTANT: do not set `timezoneOffset` on both `DateAxis` and `dateFormatter`. It\r\n\t * will skew your results by applying offset twice.\r\n\t * \r\n\t * @since 4.8.5\r\n\t * @param  value Time zone offset in minutes\r\n\t */\r\n\tpublic set timezoneOffset(value: number) {\r\n\t\tthis.setPropertyValue(\"timezoneOffset\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @todo Timezone offset in minutes\r\n\t */\r\n\tpublic get timezoneOffset(): number {\r\n\t\treturn this.getPropertyValue(\"timezoneOffset\");\r\n\t}\r\n\r\n\t/**\r\n\t * If set will recalculate all timestamps in data to specific named timezone,\r\n\t * e.g. `\"America/Vancouver\"`, `\"Australia/Sydney\"`, `\"UTC\"`, etc.\r\n\t *\r\n\t * IMPORTANT: it is no longer recommended to use this setting. Please \r\n\t * set`timezone` on `dateFormatter`.\r\n\t *\r\n\t * @deprecated\r\n\t * @since 4.10.1\r\n\t * @param  value Time zone\r\n\t */\r\n\tpublic set timezone(value: string) {\r\n\t\tthis.setPropertyValue(\"timezone\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Timezone\r\n\t */\r\n\tpublic get timezone(): string {\r\n\t\treturn this.getPropertyValue(\"timezone\");\r\n\t}\r\n\r\n\t/**\r\n\t * Current grid interval.\r\n\t *\r\n\t * @return Grid interval\r\n\t */\r\n\tpublic get gridInterval(): ITimeInterval {\r\n\t\treturn this._gridInterval;\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic makeGap(dataItem: LineSeriesDataItem, previous: LineSeriesDataItem): boolean {\r\n\t\tlet series = dataItem.component;\r\n\t\tif (dataItem && previous) {\r\n\t\t\tif (!series.connect && $type.isNumber(series.autoGapCount)) {\r\n\t\t\t\tif (series.baseAxis == this) {\r\n\t\t\t\t\tlet date = dataItem.dates[\"date\" + this.axisLetter];\r\n\t\t\t\t\tlet prevDate = previous.dates[\"date\" + this.axisLetter];\r\n\r\n\t\t\t\t\tif (date && prevDate) {\r\n\t\t\t\t\t\tlet time = date.getTime();\r\n\t\t\t\t\t\tlet prevTime = prevDate.getTime();\r\n\r\n\t\t\t\t\t\tif (time - prevTime > series.autoGapCount * this.baseDuration) {\r\n\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * @return base value\r\n\t */\r\n\tpublic get baseValue(): number {\r\n\t\treturn this.min;\r\n\t}\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"DateAxis\"] = DateAxis;\r\nregistry.registeredClasses[\"DateAxisDataItem\"] = DateAxisDataItem;\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}