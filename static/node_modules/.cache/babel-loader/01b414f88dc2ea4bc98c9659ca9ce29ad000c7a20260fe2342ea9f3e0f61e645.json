{"ast":null,"code":"/** @ignore */ /** */\nimport * as $array from \"./Array\";\nimport * as $utils from \"./Utils\";\n/**\r\n * @ignore\r\n */\nvar Native = /** @class */function () {\n  function Native() {\n    var _this = this;\n    Object.defineProperty(this, \"_observer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_targets\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    this._observer = new ResizeObserver(function (entries) {\n      $array.each(entries, function (entry) {\n        $array.each(_this._targets, function (x) {\n          if (x.target === entry.target) {\n            x.callback();\n          }\n        });\n      });\n    });\n  }\n  Object.defineProperty(Native.prototype, \"addTarget\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (target, callback) {\n      this._observer.observe(target, {\n        box: \"border-box\"\n      });\n      this._targets.push({\n        target: target,\n        callback: callback\n      });\n    }\n  });\n  Object.defineProperty(Native.prototype, \"removeTarget\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (target) {\n      this._observer.unobserve(target);\n      $array.keepIf(this._targets, function (x) {\n        return x.target !== target;\n      });\n    }\n  });\n  return Native;\n}();\n/**\r\n * @ignore\r\n */\nvar Raf = /** @class */function () {\n  function Raf() {\n    Object.defineProperty(this, \"_timer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, \"_targets\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n  }\n  Object.defineProperty(Raf.prototype, \"addTarget\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (target, callback) {\n      var _this = this;\n      if (this._timer === null) {\n        var lastTime_1 = null;\n        var loop_1 = function () {\n          var currentTime = Date.now();\n          if (lastTime_1 === null || currentTime > lastTime_1 + Raf.delay) {\n            lastTime_1 = currentTime;\n            $array.each(_this._targets, function (x) {\n              var newSize = x.target.getBoundingClientRect();\n              if (newSize.width !== x.size.width || newSize.height !== x.size.height) {\n                x.size = newSize;\n                x.callback();\n              }\n            });\n          }\n          if (_this._targets.length === 0) {\n            _this._timer = null;\n          } else {\n            _this._timer = requestAnimationFrame(loop_1);\n          }\n        };\n        this._timer = requestAnimationFrame(loop_1);\n      }\n      // We start off with fake bounds so that sensor always kicks in\n      var size = {\n        width: 0,\n        height: 0,\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0,\n        x: 0,\n        y: 0\n      };\n      this._targets.push({\n        target: target,\n        callback: callback,\n        size: size\n      });\n    }\n  });\n  Object.defineProperty(Raf.prototype, \"removeTarget\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (target) {\n      $array.keepIf(this._targets, function (x) {\n        return x.target !== target;\n      });\n      if (this._targets.length === 0) {\n        if (this._timer !== null) {\n          cancelAnimationFrame(this._timer);\n          this._timer = null;\n        }\n      }\n    }\n  });\n  Object.defineProperty(Raf, \"delay\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: 200\n  });\n  return Raf;\n}();\n/**\r\n * @ignore\r\n */\nvar observer = null;\n/**\r\n * @ignore\r\n */\nfunction makeSensor() {\n  if (observer === null) {\n    if (typeof ResizeObserver !== \"undefined\") {\n      observer = new Native();\n    } else {\n      observer = new Raf();\n    }\n  }\n  return observer;\n}\n/**\r\n * @ignore\r\n */\nvar ResizeSensor = /** @class */function () {\n  function ResizeSensor(element, callback) {\n    Object.defineProperty(this, \"_sensor\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_element\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_listener\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_disposed\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    this._sensor = makeSensor();\n    this._element = element;\n    // This is needed because we need to know when the window is zoomed\n    this._listener = $utils.onZoom(callback);\n    this._sensor.addTarget(element, callback);\n  }\n  Object.defineProperty(ResizeSensor.prototype, \"isDisposed\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return this._disposed;\n    }\n  });\n  Object.defineProperty(ResizeSensor.prototype, \"dispose\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      if (!this._disposed) {\n        this._disposed = true;\n        this._sensor.removeTarget(this._element);\n        this._listener.dispose();\n      }\n    }\n  });\n  Object.defineProperty(ResizeSensor.prototype, \"sensor\", {\n    get: function () {\n      return this._sensor;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return ResizeSensor;\n}();\nexport { ResizeSensor };","map":{"version":3,"mappings":"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","names":["$array","$utils","Object","_observer","ResizeObserver","entries","each","entry","_this","_targets","x","target","callback","observe","box","push","unobserve","keepIf","_timer","lastTime_1","loop_1","currentTime","Date","now","Raf","delay","newSize","getBoundingClientRect","width","size","height","length","requestAnimationFrame","left","right","top","bottom","y","cancelAnimationFrame","observer","makeSensor","Native","element","_sensor","_element","_listener","onZoom","addTarget","_disposed","removeTarget","dispose","ResizeSensor"],"sources":["C:\\Users\\Lucian\\Documents\\DEV\\nodejs\\stock-market-api\\dev\\static\\node_modules\\src\\.internal\\core\\util\\ResizeSensor.ts"],"sourcesContent":["/** @ignore *//** */\n\nimport type { IDisposer } from \"./Disposer\";\nimport * as $array from \"./Array\";\nimport * as $utils from \"./Utils\";\n\n/**\n * @ignore\n */\ninterface Sensor {\n\taddTarget(target: Element, callback: () => void): void;\n\tremoveTarget(target: Element): void;\n}\n\n/**\n * @ignore\n */\ndeclare const ResizeObserver: any;\n\n/**\n * @ignore\n */\nclass Native implements Sensor {\n\tprivate _observer: any;\n\tprivate _targets: Array<{ target: Element, callback: () => void }> = [];\n\n\tconstructor() {\n\t\tthis._observer = new ResizeObserver((entries: Array<any>) => {\n\t\t\t$array.each(entries, (entry) => {\n\t\t\t\t$array.each(this._targets, (x) => {\n\t\t\t\t\tif (x.target === entry.target) {\n\t\t\t\t\t\tx.callback();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\taddTarget(target: Element, callback: () => void) {\n\t\tthis._observer.observe(target, { box: \"border-box\" });\n\t\tthis._targets.push({ target, callback });\n\t}\n\n\tremoveTarget(target: Element) {\n\t\tthis._observer.unobserve(target);\n\n\t\t$array.keepIf(this._targets, (x) => {\n\t\t\treturn x.target !== target;\n\t\t});\n\t}\n}\n\n/**\n * @ignore\n */\ninterface ClientBounds {\n\twidth: number,\n\theight: number,\n\tleft: number,\n\tright: number,\n\ttop: number,\n\tbottom: number,\n\tx: number,\n\ty: number\n}\n\n\n/**\n * @ignore\n */\nclass Raf implements Sensor {\n\tpublic static delay: number = 200;\n\n\tprivate _timer: number | null = null;\n\tprivate _targets: Array<{ target: Element, callback: () => void, size: ClientRect | DOMRect | ClientBounds }> = [];\n\n\taddTarget(target: Element, callback: () => void) {\n\t\tif (this._timer === null) {\n\t\t\tlet lastTime: number | null = null;\n\n\t\t\tconst loop = () => {\n\t\t\t\tconst currentTime = Date.now();\n\n\t\t\t\tif (lastTime === null || currentTime > (lastTime + Raf.delay)) {\n\t\t\t\t\tlastTime = currentTime;\n\n\t\t\t\t\t$array.each(this._targets, (x) => {\n\t\t\t\t\t\tlet newSize = x.target.getBoundingClientRect();\n\n\t\t\t\t\t\tif (newSize.width !== x.size.width || newSize.height !== x.size.height) {\n\t\t\t\t\t\t\tx.size = newSize;\n\t\t\t\t\t\t\tx.callback();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tif (this._targets.length === 0) {\n\t\t\t\t\tthis._timer = null;\n\n\t\t\t\t} else {\n\t\t\t\t\tthis._timer = requestAnimationFrame(loop);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis._timer = requestAnimationFrame(loop);\n\t\t}\n\n\t\t// We start off with fake bounds so that sensor always kicks in\n\t\tlet size = { width: 0, height: 0, left: 0, right: 0, top: 0, bottom: 0, x: 0, y: 0 };\n\t\tthis._targets.push({ target, callback, size });\n\t}\n\n\tremoveTarget(target: Element) {\n\t\t$array.keepIf(this._targets, (x) => {\n\t\t\treturn x.target !== target;\n\t\t});\n\n\t\tif (this._targets.length === 0) {\n\t\t\tif (this._timer !== null) {\n\t\t\t\tcancelAnimationFrame(this._timer);\n\t\t\t\tthis._timer = null;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n/**\n * @ignore\n */\nlet observer: Sensor | null = null;\n\n/**\n * @ignore\n */\nfunction makeSensor(): Sensor {\n\tif (observer === null) {\n\t\tif (typeof ResizeObserver !== \"undefined\") {\n\t\t\tobserver = new Native();\n\n\t\t} else {\n\t\t\tobserver = new Raf();\n\t\t}\n\t}\n\n\treturn observer;\n}\n\n/**\n * @ignore\n */\nexport class ResizeSensor implements IDisposer {\n\tprivate _sensor: Sensor;\n\tprivate _element: Element;\n\tprivate _listener: IDisposer;\n\tprivate _disposed: boolean = false;\n\n\tconstructor(element: Element, callback: () => void) {\n\t\tthis._sensor = makeSensor();\n\t\tthis._element = element;\n\n\t\t// This is needed because we need to know when the window is zoomed\n\t\tthis._listener = $utils.onZoom(callback);\n\n\t\tthis._sensor.addTarget(element, callback);\n\t}\n\n\tpublic isDisposed() {\n\t\treturn this._disposed;\n\t}\n\n\tpublic dispose() {\n\t\tif (!this._disposed) {\n\t\t\tthis._disposed = true;\n\t\t\tthis._sensor.removeTarget(this._element);\n\t\t\tthis._listener.dispose();\n\t\t}\n\t}\n\n\tpublic get sensor(): Sensor {\n\t\treturn this._sensor;\n\t}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}