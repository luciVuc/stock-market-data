{"ast":null,"code":"/**\r\n * Category axis module\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\nimport { Axis, AxisDataItem } from \"./Axis\";\nimport { AxisRendererX } from \"./AxisRendererX\";\nimport { AxisRendererY } from \"./AxisRendererY\";\nimport { registry } from \"../../core/Registry\";\nimport { Dictionary } from \"../../core/utils/Dictionary\";\nimport { CategoryAxisBreak } from \"./CategoryAxisBreak\";\nimport * as $math from \"../../core/utils/Math\";\nimport * as $type from \"../../core/utils/Type\";\nimport * as $iter from \"../../core/utils/Iterator\";\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * Defines a [[DataItem]] for [[CategoryAxis]].\r\n *\r\n * @see {@link DataItem}\r\n */\nvar CategoryAxisDataItem = /** @class */function (_super) {\n  __extends(CategoryAxisDataItem, _super);\n  /**\r\n   * Constructor\r\n   */\n  function CategoryAxisDataItem() {\n    var _this = _super.call(this) || this;\n    _this.seriesDataItems = {};\n    _this.className = \"CategoryAxisDataItem\";\n    _this.text = \"{category}\";\n    _this.locations.category = 0;\n    _this.locations.endCategory = 1;\n    _this.deltaPosition = 0;\n    _this.applyTheme();\n    return _this;\n  }\n  Object.defineProperty(CategoryAxisDataItem.prototype, \"category\", {\n    /**\r\n     * @return Category\r\n     */\n    get: function () {\n      if (this._adapterO) {\n        if (this._adapterO.isEnabled(\"category\")) {\n          return this._adapterO.apply(\"category\", this.properties.category);\n        }\n      }\n      return this.properties.category;\n    },\n    /**\r\n     * Category.\r\n     *\r\n     * @param value  Category\r\n     */\n    set: function (value) {\n      var oldCategory = this.properties.category;\n      this.setProperty(\"category\", value);\n      if ($type.hasValue(oldCategory) && oldCategory != value) {\n        if (this.component) {\n          this.component.validateDataElement(this);\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CategoryAxisDataItem.prototype, \"endCategory\", {\n    /**\r\n     * @return End category\r\n     */\n    get: function () {\n      return this.properties.endCategory;\n    },\n    /**\r\n     * End category.\r\n     *\r\n     * Used for items that span several categories, like [[CategoryAxisBreak]].\r\n     *\r\n     * @param value  End category\r\n     */\n    set: function (value) {\n      this.setProperty(\"endCategory\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CategoryAxisDataItem.prototype, \"deltaPosition\", {\n    get: function () {\n      return this.properties.deltaCoordinate;\n    },\n    set: function (value) {\n      if (value != this.properties.deltaCoordinate) {\n        this.setProperty(\"deltaCoordinate\", value);\n        if (this.component) {\n          this.component.invalidateDataItems();\n          this.component.invalidateSeries();\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return CategoryAxisDataItem;\n}(AxisDataItem);\nexport { CategoryAxisDataItem };\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * Used to create a category-based axis for the chart.\r\n *\r\n * ```TypeScript\r\n * // Create the axis\r\n * let xAxis = chart.xAxes.push(new am4charts.CategoryAxis());\r\n *\r\n * // Set settings\r\n * xAxis.title.text = \"Clients\";\r\n * ```\r\n * ```JavaScript\r\n * // Create the axis\r\n * var valueAxis = chart.xAxes.push(new am4charts.CategoryAxis());\r\n *\r\n * // Set settings\r\n * valueAxis.title.text = \"Clients\";\r\n * ```\r\n * ```JSON\r\n * \"xAxes\": [{\r\n *   \"type\": \"CategoryAxis\",\r\n *   \"title\": {\r\n *     \"text\": \"Clients\"\r\n *   }\r\n * }]\r\n * ```\r\n *\r\n * @see {@link ICategoryAxisEvents} for a list of available Events\r\n * @see {@link ICategoryAxisAdapters} for a list of available Adapters\r\n * @important\r\n */\nvar CategoryAxis = /** @class */function (_super) {\n  __extends(CategoryAxis, _super);\n  /**\r\n   * Constructor\r\n   */\n  function CategoryAxis() {\n    var _this =\n    // Init\n    _super.call(this) || this;\n    /**\r\n     * A collection that holds Axis' data items sorted by each category.\r\n     */\n    _this.dataItemsByCategory = new Dictionary();\n    _this.className = \"CategoryAxis\";\n    // Set field name\n    _this.axisFieldName = \"category\";\n    _this._lastDataItem = _this.createDataItem();\n    _this._lastDataItem.component = _this;\n    _this._disposers.push(_this._lastDataItem);\n    // Apply theme\n    _this.applyTheme();\n    var dataItemsByCategory = _this.dataItemsByCategory;\n    _this.addDisposer(_this.mainDataSet.events.on(\"removed\", function (event) {\n      dataItemsByCategory.removeKey(event.oldValue.category);\n    }));\n    return _this;\n  }\n  /**\r\n   * Returns a new/empty [[DataItem]] of the type appropriate for this object.\r\n   *\r\n   * @see {@link DataItem}\r\n   * @return Data Item\r\n   */\n  CategoryAxis.prototype.createDataItem = function () {\n    return new CategoryAxisDataItem();\n  };\n  /**\r\n   * Returns a new/empty [[AxisBreak]] of the appropriate type.\r\n   *\r\n   * @return Axis break\r\n   */\n  CategoryAxis.prototype.createAxisBreak = function () {\n    return new CategoryAxisBreak();\n  };\n  /**\r\n   * Processes a related series' data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param dataItem  Data item\r\n   */\n  CategoryAxis.prototype.processSeriesDataItem = function (dataItem, axisLetter) {\n    _super.prototype.processSeriesDataItem.call(this, dataItem, axisLetter);\n    var category = dataItem[\"category\" + this.axisLetter];\n    if ($type.hasValue(category)) {\n      var categoryAxisDataItem = this.dataItemsByCategory.getKey(category);\n      if (categoryAxisDataItem) {\n        var seriesId = dataItem.component.uid;\n        var seriesDataItems = categoryAxisDataItem.seriesDataItems[seriesId];\n        if (!seriesDataItems) {\n          seriesDataItems = [];\n          categoryAxisDataItem.seriesDataItems[seriesId] = seriesDataItems;\n        }\n        seriesDataItems.push(dataItem);\n      }\n    } else {\n      dataItem.component.dataItems.remove(dataItem);\n    }\n  };\n  /**\r\n   * Validates the data range.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   */\n  CategoryAxis.prototype.validateDataRange = function () {\n    var _this = this;\n    _super.prototype.validateDataRange.call(this);\n    $iter.each(this._series.iterator(), function (series) {\n      if (series.xAxis instanceof CategoryAxis && series.yAxis instanceof CategoryAxis) {\n        series.invalidateDataRange();\n      } else {\n        var startIndex = _this.positionToIndex(_this.start);\n        var endIndex = _this.positionToIndex(_this.end);\n        if (endIndex >= _this.dataItems.length) {\n          endIndex--;\n        }\n        var seriesId = series.uid;\n        var minIndex = void 0;\n        var maxIndex = void 0;\n        for (var i = startIndex; i <= endIndex; i++) {\n          var axisDataItem = _this.dataItems.getIndex(i);\n          if (axisDataItem) {\n            var seriesDataItems = axisDataItem.seriesDataItems[seriesId];\n            if (seriesDataItems) {\n              for (var i_1 = 0; i_1 < seriesDataItems.length; i_1++) {\n                var seriesDataItem = seriesDataItems[i_1];\n                if (seriesDataItem) {\n                  var index = seriesDataItem.index;\n                  if (!$type.isNumber(minIndex) || index < minIndex) {\n                    minIndex = index;\n                  }\n                  if (!$type.isNumber(maxIndex) || index > maxIndex) {\n                    maxIndex = index;\n                  }\n                }\n              }\n            }\n          }\n        }\n        if ($type.isNumber(minIndex)) {\n          series.startIndex = minIndex;\n        } else {\n          series.start = _this.start;\n        }\n        if ($type.isNumber(maxIndex)) {\n          series.endIndex = maxIndex + 1;\n        } else {\n          series.end = _this.end;\n        }\n        // range might not change, but axis breaks might.\n        if (_this._axisBreaks && _this._axisBreaks.length > 0) {\n          series.invalidateDataRange();\n        }\n      }\n    });\n  };\n  /**\r\n   * Validates the whole axis. Causes it to redraw.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   */\n  CategoryAxis.prototype.validate = function () {\n    var _this = this;\n    _super.prototype.validate.call(this);\n    var dataCount = this.dataItems.length;\n    var startIndex = $math.fitToRange(Math.floor(this.start * dataCount - 1), 0, dataCount);\n    var endIndex = $math.fitToRange(Math.ceil(this.end * dataCount), 0, dataCount);\n    if (this.renderer.invalid) {\n      this.renderer.validate();\n    }\n    // find frequency at which we'll show items\n    var maxCount = this.renderer.axisLength / Math.max(this.renderer.minGridDistance, 1 / Number.MAX_SAFE_INTEGER);\n    var frequency = Math.min(this.dataItems.length, Math.ceil((endIndex - startIndex) / maxCount));\n    this._startIndex = Math.floor(startIndex / frequency) * frequency;\n    this._endIndex = Math.ceil(this.end * dataCount);\n    this.fixAxisBreaks();\n    if (this._startIndex == this._endIndex) {\n      this._endIndex++;\n    }\n    this._frequency = frequency;\n    if (this.axisLength <= 0) {\n      return;\n    }\n    this.maxZoomFactor = this.dataItems.length;\n    if (this.dataItems.length <= 0) {\n      this.maxZoomFactor = 1;\n    }\n    this.resetIterators();\n    // it's important to use protected variables here, as getters will return 0 - length\n    // TODO use iterator instead\n    // @ todo: not solved cat axis item fading\n    startIndex = $math.max(0, this._startIndex - this._frequency);\n    endIndex = $math.min(this.dataItems.length, this._endIndex + this._frequency);\n    var itemIndex = 0;\n    for (var i = 0; i < startIndex; i++) {\n      var dataItem = this.dataItems.getIndex(i);\n      dataItem.__disabled = true;\n    }\n    for (var i = endIndex, len = this.dataItems.length; i < len; i++) {\n      var dataItem = this.dataItems.getIndex(i);\n      dataItem.__disabled = true;\n    }\n    for (var i = startIndex; i < endIndex; i++) {\n      if (i < this.dataItems.length) {\n        var dataItem = this.dataItems.getIndex(i);\n        if (i / this._frequency == Math.round(i / this._frequency)) {\n          var axisBreak = this.isInBreak(i);\n          if (!axisBreak) {\n            this.appendDataItem(dataItem);\n            this.validateDataElement(dataItem, itemIndex);\n          }\n          itemIndex++;\n        } else {\n          //previously we disabled all before, but this is better for cpu\n          //this.validateDataElement(dataItem, itemIndex); // helps to solve shrinking // not good - creates all items\n          dataItem.__disabled = true;\n        }\n      }\n    }\n    this.appendDataItem(this._lastDataItem);\n    this.validateDataElement(this._lastDataItem, itemIndex + 1, this.dataItems.length);\n    if (this._axisBreaks) {\n      var axisBreaks = this._axisBreaks;\n      axisBreaks.each(function (axisBreak) {\n        var adjustedStartValue = axisBreak.adjustedStartValue;\n        var adjustedEndValue = axisBreak.adjustedEndValue;\n        if ($math.intersect({\n          start: adjustedStartValue,\n          end: adjustedEndValue\n        }, {\n          start: _this._startIndex,\n          end: _this._endIndex\n        })) {\n          for (var b = adjustedStartValue; b <= adjustedEndValue; b++) {\n            var dataItem = _this.dataItems.getIndex(b);\n            dataItem.__disabled = true;\n          }\n          var frequency_1 = $math.fitToRange(Math.ceil(_this._frequency / axisBreak.breakSize), 1, adjustedEndValue - adjustedStartValue);\n          var itemIndex_1 = 0;\n          if (axisBreak.breakSize > 0) {\n            // TODO use iterator instead\n            for (var b = adjustedStartValue; b <= adjustedEndValue; b = b + frequency_1) {\n              var dataItem = _this.dataItems.getIndex(b);\n              dataItem.__disabled = false;\n              _this.appendDataItem(dataItem);\n              _this.validateDataElement(dataItem, itemIndex_1);\n              itemIndex_1++;\n            }\n          }\n        }\n      });\n    }\n    this.validateBreaks();\n    this.validateAxisRanges();\n    this.ghostLabel.invalidate(); // solves font issue\n    this.renderer.invalidateLayout();\n  };\n  /**\r\n   * [validateDataElement description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param dataItem   [description]\r\n   * @param itemIndex  [description]\r\n   */\n  CategoryAxis.prototype.validateDataElement = function (dataItem, itemIndex, index) {\n    _super.prototype.validateDataElement.call(this, dataItem);\n    dataItem.itemIndex = this._axisItemCount;\n    this._axisItemCount++;\n    //dataItem.__disabled = false;\n    var renderer = this.renderer;\n    if (!$type.isNumber(index)) {\n      index = this.categoryToIndex(dataItem.category);\n    }\n    var endIndex = this.categoryToIndex(dataItem.endCategory);\n    if (!$type.isNumber(endIndex)) {\n      endIndex = index;\n    }\n    var position = this.indexToPosition(index, dataItem.locations.category);\n    var endPosition = this.indexToPosition(endIndex, dataItem.locations.endCategory);\n    dataItem.position = position;\n    var fillEndIndex;\n    var fillPosition;\n    var fillEndPosition;\n    if (dataItem.isRange) {\n      fillEndIndex = endIndex;\n      fillPosition = this.indexToPosition(index, dataItem.locations.category);\n      fillEndPosition = this.indexToPosition(fillEndIndex, dataItem.locations.endCategory);\n    }\n    dataItem.point = renderer.positionToPoint(position);\n    var tick = dataItem.tick;\n    if (tick && !tick.disabled) {\n      renderer.updateTickElement(tick, position, endPosition);\n    }\n    var grid = dataItem.grid;\n    if (grid && !grid.disabled) {\n      renderer.updateGridElement(grid, position, endPosition);\n    }\n    var label = dataItem.label;\n    if (label && !label.disabled) {\n      // theorethically this might result problems if category text changes, the range text won't change. But otherwise range.label.text = \"custom text\" won't work, which is not intuitive.\n      if (!dataItem.isRange || label.text == undefined) {\n        dataItem.text = dataItem.text;\n      }\n      renderer.updateLabelElement(label, position, endPosition);\n      if (renderer instanceof AxisRendererY && dataItem.label.measuredWidth > this.ghostLabel.measuredWidth || renderer instanceof AxisRendererX && dataItem.label.measuredHeight > this.ghostLabel.measuredHeight) {\n        if (dataItem.label.html) {\n          this.ghostLabel.html = dataItem.label.currentText;\n        } else {\n          this.ghostLabel.text = dataItem.label.currentText;\n        }\n      }\n    }\n    var fill = dataItem.axisFill;\n    if (fill && !fill.disabled) {\n      if (!dataItem.isRange) {\n        fillEndIndex = index + this._frequency;\n        fillPosition = this.indexToPosition(index, fill.location);\n        fillEndPosition = this.indexToPosition(fillEndIndex, fill.location);\n      }\n      renderer.updateFillElement(fill, fillPosition, fillEndPosition);\n      if (!dataItem.isRange) {\n        this.fillRule(dataItem, itemIndex);\n      }\n    }\n    if (dataItem.bullet) {\n      renderer.updateBullet(dataItem.bullet, position, endPosition);\n    }\n    var mask = dataItem.mask;\n    if (mask) {\n      renderer.updateFillElement(mask, fillPosition, fillEndPosition);\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n  CategoryAxis.prototype.disposeData = function () {\n    this.dataItemsByCategory.clear();\n    _super.prototype.disposeData.call(this);\n  };\n  /**\r\n   * Processes the axis data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param dataItem     Data item\r\n   * @param dataContext  The raw data that corresponds to this data item\r\n   */\n  CategoryAxis.prototype.processDataItem = function (dataItem, dataContext) {\n    if (dataItem) {\n      // creat a collection for fast access\n      _super.prototype.processDataItem.call(this, dataItem, dataContext);\n      // check if such category already exists\n      //let existingDataItem: CategoryAxisDataItem = this.dataItemsByCategory.getKey(dataItem.category);\n      //if (existingDataItem && existingDataItem != dataItem) {\n      //\tthis.dataItems.remove(existingDataItem);\n      //}\n      if ($type.hasValue(dataItem.category)) {\n        this.dataItemsByCategory.setKey(dataItem.category, dataItem);\n      }\n    }\n  };\n  CategoryAxis.prototype.getDataItem = function (dataContext) {\n    var category = dataContext[this.dataFields.category];\n    if ($type.hasValue(category)) {\n      var dataItem = this.dataItemsByCategory.getKey(category);\n      if (dataItem) {\n        return dataItem;\n      } else {\n        return this.dataItems.create();\n      }\n    }\n  };\n  /**\r\n   * Converts a category index to an actual screen coordinate on the axis.\r\n   *\r\n   * `location` identifies relative location within category. 0 - beginning,\r\n   * 0.5 - middle, 1 - end, and anything inbetween.\r\n   *\r\n   * @param index     Index\r\n   * @param location  Location (0-1)\r\n   * @return Position (px)\r\n   */\n  CategoryAxis.prototype.indexToPosition = function (index, location) {\n    if (!$type.isNumber(location)) {\n      location = 0.5;\n    }\n    var startIndex = this.startIndex;\n    var endIndex = this.endIndex;\n    var difference = this.adjustDifference(startIndex, endIndex);\n    var startLocation = this.startLocation;\n    var endLocation = this.endLocation;\n    difference -= startLocation;\n    difference -= 1 - endLocation;\n    if (this._axisBreaks) {\n      var axisBreaks = this._axisBreaks;\n      $iter.eachContinue(axisBreaks.iterator(), function (axisBreak) {\n        var breakStartIndex = axisBreak.adjustedStartValue;\n        var breakEndIndex = axisBreak.adjustedEndValue;\n        if (index < startIndex || !$type.isNumber(breakStartIndex) || !$type.isNumber(breakEndIndex)) {\n          return false;\n        }\n        if ($math.intersect({\n          start: breakStartIndex,\n          end: breakEndIndex\n        }, {\n          start: startIndex,\n          end: endIndex\n        })) {\n          breakStartIndex = Math.max(startIndex, breakStartIndex);\n          breakEndIndex = Math.min(endIndex, breakEndIndex);\n          var breakSize = axisBreak.breakSize;\n          // value to the right of break end\n          if (index > breakEndIndex) {\n            startIndex += (breakEndIndex - breakStartIndex) * (1 - breakSize);\n          }\n          // value to the left of break start\n          else if (index < breakStartIndex) {}\n          // value within break\n          else {\n            index = breakStartIndex + (index - breakStartIndex) * breakSize;\n          }\n        }\n        return true;\n      });\n    }\n    var deltaPosition = 0;\n    var dataItem = this.dataItems.getIndex(index);\n    if (dataItem) {\n      deltaPosition = dataItem.deltaPosition;\n    }\n    return $math.round(deltaPosition + (index + location - startLocation - startIndex) / difference, 5);\n  };\n  /**\r\n   * Converts a string category name to relative position on axis.\r\n   *\r\n   * `location` identifies relative location within category. 0 - beginning,\r\n   * 0.5 - middle, 1 - end, and anything inbetween.\r\n   *\r\n   * @param category  Category name\r\n   * @param location  Location (0-1)\r\n   * @return Position\r\n   */\n  CategoryAxis.prototype.categoryToPosition = function (category, location) {\n    var index = this.categoryToIndex(category);\n    return this.indexToPosition(index, location);\n  };\n  /**\r\n   * Converts a string category name to a orientation point (x, y, angle) on axis\r\n   *\r\n   * `location` identifies relative location within category. 0 - beginning,\r\n   * 0.5 - middle, 1 - end, and anything inbetween.\r\n   * @param category  Category name\r\n   * @param location  Location (0-1)\r\n   * @return Orientation point\r\n   */\n  CategoryAxis.prototype.categoryToPoint = function (category, location) {\n    var position = this.categoryToPosition(category, location);\n    var point = this.renderer.positionToPoint(position);\n    var angle = this.renderer.positionToAngle(position);\n    return {\n      x: point.x,\n      y: point.y,\n      angle: angle\n    };\n  };\n  /**\r\n   * Converts a string category name to a orientation point (x, y, angle) on axis\r\n   *\r\n   * `location` identifies relative location within category. 0 - beginning,\r\n   * 0.5 - middle, 1 - end, and anything inbetween.\r\n   * @param category  Category name\r\n   * @param location  Location (0-1)\r\n   * @return Orientation point\r\n   */\n  CategoryAxis.prototype.anyToPoint = function (category, location) {\n    return this.categoryToPoint(category, location);\n  };\n  /**\r\n   * Converts a string category name to relative position on axis.\r\n   *\r\n   * An alias to `categoryToPosition()`.\r\n   *\r\n   * @param category  Category name\r\n   * @param location  Location (0-1)\r\n   * @return Relative position\r\n   */\n  CategoryAxis.prototype.anyToPosition = function (category, location) {\n    return this.categoryToPosition(category, location);\n  };\n  /**\r\n   * Converts named category to an index of data item it corresponds to.\r\n   *\r\n   * @param category  Category\r\n   * @return Data item index\r\n   */\n  CategoryAxis.prototype.categoryToIndex = function (category) {\n    if ($type.hasValue(category)) {\n      var dataItem = this.dataItemsByCategory.getKey(category);\n      if (dataItem) {\n        return dataItem.index;\n      }\n    }\n  };\n  /**\r\n   * Zooms the axis to specific named ctaegories.\r\n   *\r\n   * @param startCategory  Start category\r\n   * @param endCategory    End category\r\n   */\n  CategoryAxis.prototype.zoomToCategories = function (startCategory, endCategory) {\n    this.zoomToIndexes(this.categoryToIndex(startCategory), this.categoryToIndex(endCategory) + 1);\n  };\n  /**\r\n   * [getAnyRangePath description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param start         [description]\r\n   * @param end           [description]\r\n   * @param startLocation [description]\r\n   * @param endLocation   [description]\r\n   * @return [description]\r\n   */\n  CategoryAxis.prototype.getAnyRangePath = function (start, end, startLocation, endLocation) {\n    var startPos = this.categoryToPosition(start, startLocation);\n    var endPos = this.categoryToPosition(end, endLocation);\n    return this.getPositionRangePath(startPos, endPos); // Base class (Axis) gets range shape from AxisRenderer\n  };\n  /**\r\n   * Takes an absolute position (px) within axis and adjust it to a specific\r\n   * `location` within category it corresponds to.\r\n   *\r\n   * @param position  Source position (px)\r\n   * @param location  Location within category (0-1)\r\n   * @return Adjusted position (px)\r\n   */\n  CategoryAxis.prototype.roundPosition = function (position, location) {\n    var index = this.positionToIndex(position);\n    return this.indexToPosition(index, location);\n  };\n  /**\r\n   * Finds and returns first series data item with specific category\r\n   * @param series    Target series\r\n   * @param category  Category\r\n   * @return XYSeriesDataItem data item\r\n   */\n  CategoryAxis.prototype.getFirstSeriesDataItem = function (series, category) {\n    for (var i = 0; i < series.dataItems.length; i++) {\n      var dataItem = series.dataItems.getIndex(i);\n      if (series.xAxis == this) {\n        if (dataItem.categoryX == category) {\n          return dataItem;\n        }\n      }\n      if (series.yAxis == this) {\n        if (dataItem.categoryY == category) {\n          return dataItem;\n        }\n      }\n    }\n  };\n  /**\r\n   * Finds and returns last series data item with specific category.\r\n   * @param series    Target series\r\n   * @param category  Category\r\n   * @return XYSeriesDataItem data item\r\n   */\n  CategoryAxis.prototype.getLastSeriesDataItem = function (series, category) {\n    for (var i = series.dataItems.length - 1; i >= 0; i--) {\n      var dataItem = series.dataItems.getIndex(i);\n      if (series.xAxis == this) {\n        if (dataItem.categoryX == category) {\n          return dataItem;\n        }\n      }\n      if (series.yAxis == this) {\n        if (dataItem.categoryY == category) {\n          return dataItem;\n        }\n      }\n    }\n  };\n  // todo: optimize\n  CategoryAxis.prototype.getSeriesDataItemByCategory = function (category, series) {\n    var _this = this;\n    var seriesDataItem;\n    series.dataItems.each(function (dataItem) {\n      if (series.xAxis == _this) {\n        if (dataItem.categoryX == category) {\n          seriesDataItem = dataItem;\n        }\n      } else if (series.yAxis == _this) {\n        if (dataItem.categoryY == category) {\n          seriesDataItem = dataItem;\n        }\n      }\n    });\n    return seriesDataItem;\n  };\n  /**\r\n   * Returns a data item from Series that corresponds to a specific absolute\r\n   * position on the Axis.\r\n   *\r\n   * @param series    Target series\r\n   * @param position  Position (px)\r\n   * @return XYSeriesDataItem data item\r\n   */\n  CategoryAxis.prototype.getSeriesDataItem = function (series, position, findNearest) {\n    var _this = this;\n    if ($type.isNumber(position)) {\n      var index_1 = this.positionToIndex(position);\n      if (index_1 >= this.dataItems.length) {\n        index_1--;\n      }\n      var dataItem = this.dataItems.getIndex(index_1);\n      if (dataItem) {\n        var category_1 = dataItem.category;\n        var sdi_1;\n        var seriesDataItem = series.dataItems.getIndex(index_1);\n        if (seriesDataItem) {\n          if (series.xAxis == this) {\n            if (seriesDataItem.categoryX == category_1) {\n              return seriesDataItem;\n            }\n          }\n          if (series.yAxis == this) {\n            if (seriesDataItem.categoryY == category_1) {\n              return seriesDataItem;\n            }\n          }\n        }\n        series.dataItems.each(function (dataItem) {\n          if (series.xAxis == _this) {\n            if (dataItem.categoryX == category_1) {\n              if (!sdi_1) {\n                sdi_1 = dataItem;\n              }\n              if (Math.abs(index_1 - sdi_1.index) > Math.abs(index_1 - dataItem.index)) {\n                sdi_1 = dataItem;\n              }\n            }\n          }\n          if (series.yAxis == _this) {\n            if (dataItem.categoryY == category_1) {\n              if (!sdi_1) {\n                sdi_1 = dataItem;\n              }\n              if (Math.abs(index_1 - sdi_1.index) > Math.abs(index_1 - dataItem.index)) {\n                sdi_1 = dataItem;\n              }\n            }\n          }\n        });\n        //@todo\n        if (findNearest) {}\n        return sdi_1;\n      }\n    }\n  };\n  /**\r\n   * Returns the X coordinate for series' data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param dataItem  Data item\r\n   * @param key       Category\r\n   * @param location  Location (0-1)\r\n   * @return X coordinate (px)\r\n   */\n  CategoryAxis.prototype.getX = function (dataItem, key, location, stackKey, range) {\n    var position = this.getPositionX(dataItem, key, location, stackKey, range);\n    if ($type.isNaN(position)) {\n      return this.basePoint.x;\n    } else {\n      return this.renderer.positionToPoint(position).x;\n    }\n  };\n  /**\r\n   * Returns relative position on axis for series' data item.\r\n   *\r\n   * @since 4.5.14\r\n   * @param  dataItem  Data item\r\n   * @param  key       Category\r\n   * @param  location  Location (0-1)\r\n   * @return           Relative position\r\n   */\n  CategoryAxis.prototype.getPositionX = function (dataItem, key, location, stackKey, range) {\n    var position;\n    if ($type.hasValue(key)) {\n      position = this.categoryToPosition(dataItem.categories[key], location);\n    }\n    if (range) {\n      position = $math.fitToRange(position, range.start, range.end);\n    }\n    return position;\n  };\n  /**\r\n   * Returns the Y coordinate for series' data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param dataItem  Data item\r\n   * @param key       Category\r\n   * @param location  Location (0-1)\r\n   * @return Y coordinate (px)\r\n   */\n  CategoryAxis.prototype.getY = function (dataItem, key, location, stackKey, range) {\n    var position = this.getPositionY(dataItem, key, location, stackKey, range);\n    if ($type.isNaN(position)) {\n      return this.basePoint.y;\n    } else {\n      return this.renderer.positionToPoint(position).y;\n    }\n  };\n  /**\r\n   * Returns relative position on axis for series' data item.\r\n   *\r\n   * @since 4.5.14\r\n   * @param  dataItem  Data item\r\n   * @param  key       Category\r\n   * @param  location  Location (0-1)\r\n   * @return           Relative position\r\n   */\n  CategoryAxis.prototype.getPositionY = function (dataItem, key, location, stackKey, range) {\n    var position;\n    if ($type.hasValue(key)) {\n      position = this.categoryToPosition(dataItem.categories[key], location);\n    }\n    if (range) {\n      position = $math.fitToRange(position, range.start, range.end);\n    }\n    return position;\n  };\n  /**\r\n   * Returns an angle for series data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param dataItem  Data item\r\n   * @param key       Category\r\n   * @param location  Location (0-1)\r\n   * @param stackKey  Stack key (?)\r\n   * @param range Range to fit in\r\n   * @return Angle\r\n   */\n  CategoryAxis.prototype.getAngle = function (dataItem, key, location, stackKey, range) {\n    var position = this.categoryToPosition(dataItem.categories[key], location);\n    if (range) {\n      position = $math.fitToRange(position, range.start, range.end);\n    }\n    return this.positionToAngle(position);\n  };\n  /**\r\n   * Returns an absolute pixel coordinate of the start of the cell (category),\r\n   * that specific position value falls into.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param position  Position (px)\r\n   * @return Cell start position (px)\r\n   */\n  CategoryAxis.prototype.getCellStartPosition = function (position) {\n    return this.roundPosition(position, 0);\n  };\n  /**\r\n   * Returns an absolute pixel coordinate of the end of the cell (category),\r\n   * that specific position value falls into.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param position  Position (px)\r\n   * @return Cell end position (px)\r\n   */\n  CategoryAxis.prototype.getCellEndPosition = function (position) {\n    return this.roundPosition(position, 1);\n  };\n  /**\r\n   * Returns text to show in a category tooltip, based on specific position\r\n   * within axis.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param position  Position (px)\r\n   * @return Label (category)\r\n   */\n  CategoryAxis.prototype.getTooltipText = function (position) {\n    var dataItem = this.dataItems.getIndex(this.positionToIndex(position));\n    if (dataItem) {\n      this.tooltipDataItem = dataItem;\n      this.tooltip.dataItem = dataItem;\n      if (this.tooltipText) {\n        return this.tooltipText;\n      }\n      if (!this._adapterO) {\n        return dataItem.category;\n      } else {\n        return this._adapterO.apply(\"getTooltipText\", dataItem.category);\n      }\n    }\n  };\n  /**\r\n   * Returns an index of the category that corresponds to specific pixel\r\n   * position within axis.\r\n   *\r\n   * @param position  Position (px)\r\n   * @return Category index\r\n   */\n  CategoryAxis.prototype.positionToIndex = function (position) {\n    position = $math.round(position, 10);\n    if (position < 0) {\n      position = 0;\n    }\n    if (position > 1) {\n      position = 1;\n    }\n    var startIndex = this.startIndex;\n    var endIndex = this.endIndex;\n    var difference = endIndex - startIndex - this.startLocation - (1 - this.endLocation);\n    position += 1 / difference * this.startLocation;\n    var index = null;\n    if (this._axisBreaks) {\n      var axisBreaks = this._axisBreaks;\n      // in case we have some axis breaks\n      $iter.eachContinue(axisBreaks.iterator(), function (axisBreak) {\n        var breakStartPosition = axisBreak.startPosition;\n        var breakEndPosition = axisBreak.endPosition;\n        var breakStartIndex = axisBreak.adjustedStartValue;\n        var breakEndIndex = axisBreak.adjustedEndValue;\n        breakStartIndex = $math.max(breakStartIndex, startIndex);\n        breakEndIndex = $math.min(breakEndIndex, endIndex);\n        var breakSize = axisBreak.breakSize;\n        difference -= (breakEndIndex - breakStartIndex) * (1 - breakSize);\n        // position to the right of break end\n        if (position > breakEndPosition) {\n          startIndex += (breakEndIndex - breakStartIndex) * (1 - breakSize);\n        }\n        // position to the left of break start\n        else if (position < breakStartPosition) {}\n        // value within break\n        else {\n          var breakPosition = (position - breakStartPosition) / (breakEndPosition - breakStartPosition);\n          index = breakStartIndex + Math.round(breakPosition * (breakEndIndex - breakStartIndex));\n          return false;\n        }\n        return true;\n      });\n    }\n    if (!$type.isNumber(index)) {\n      index = Math.floor(position * difference + startIndex);\n    }\n    if (index >= this.dataItems.length) {\n      index = this.dataItems.length - 1;\n    }\n    // not good, when panning out of bounds, each time one less item gets selected\n    //if (index >= endIndex) {\n    //\tindex--;\n    //}\n    return index;\n  };\n  /**\r\n   * Returns category based on position.\r\n   *\r\n   * Please note that `position` represents position within axis which may be\r\n   * zoomed and not correspond to Cursor's `position`.\r\n   *\r\n   * To convert Cursor's `position` to Axis' `position` use `toAxisPosition()` method.\r\n   *\r\n   * This is a synonim of `getPositionLabel()` implemented here for consistentcy.\r\n   *\r\n   * @since 4.3.8\r\n   * @see {@link https://www.amcharts.com/docs/v4/tutorials/tracking-cursors-position-via-api/#Tracking_Cursor_s_position} For more information about cursor tracking.\r\n   * @param position  Relative position on axis (0-1)\r\n   * @return Position label\r\n   */\n  CategoryAxis.prototype.positionToCategory = function (position) {\n    return this.getPositionLabel(position);\n  };\n  /**\r\n   * Returns category based on position.\r\n   *\r\n   * Please note that `position` represents position within axis which may be\r\n   * zoomed and not correspond to Cursor's `position`.\r\n   *\r\n   * To convert Cursor's `position` to Axis' `position` use `toAxisPosition()` method.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v4/tutorials/tracking-cursors-position-via-api/#Tracking_Cursor_s_position} For more information about cursor tracking.\r\n   * @param position  Relative position on axis (0-1)\r\n   * @return Position label\r\n   */\n  CategoryAxis.prototype.getPositionLabel = function (position) {\n    var dataItem = this.dataItems.getIndex(this.positionToIndex(position));\n    if (dataItem) {\n      return dataItem.category;\n    }\n  };\n  Object.defineProperty(CategoryAxis.prototype, \"basePoint\", {\n    /**\r\n     * Coordinates of the actual axis start.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @return Base point\r\n     */\n    get: function () {\n      // This makes base grid to be drawn at the end of the axis and adds extra\n      // grid which we need to nicely close the chart.\n      return this.renderer.positionToPoint(1);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Initializes Axis' renderer.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  CategoryAxis.prototype.initRenderer = function () {\n    _super.prototype.initRenderer.call(this);\n    var renderer = this.renderer;\n    renderer.baseGrid.disabled = true;\n  };\n  Object.defineProperty(CategoryAxis.prototype, \"frequency\", {\n    /**\r\n     * Current frequency of labels of the axis.\r\n     *\r\n     * Normally it would be 1, but when labels start to be hidden due\r\n     * to `minGridDistance` this read-only property will increase.\r\n     *\r\n     * @readonly\r\n     * @since 4.2.0\r\n     * @return Label frequency\r\n     */\n    get: function () {\n      return this._frequency;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CategoryAxis.prototype, \"sortBySeries\", {\n    /**\r\n     * @return Sort categories?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"sortBySeries\");\n    },\n    /**\r\n     * If set to a reference of [[ColumnSeries]] the categories will be sorted\r\n     * by actual values.\r\n     *\r\n     * The categories are ordered in descending order (from highest values to\r\n     * lowest). To reverse the order, use axis renderer's `inversed` setting.\r\n     * E.g.:\r\n     *\r\n     * ```TypeScript\r\n     * categoryAxis.sortBySeries = series;\r\n     * categoryAxis.renderer.inversed = true;\r\n     * ```\r\n     * ```JavaScript\r\n     * categoryAxis.sortBySeries = series;\r\n     * categoryAxis.renderer.inversed = true;\r\n     * ```\r\n     * ```JSON\r\n     * {\r\n     *   // ...\r\n     *   \"xAxes\": [{\r\n     *     // ...\r\n     *     \"sortBySeries\": \"s1\",\r\n     *     \"renderer\": {\r\n     *       // ...\r\n     *       \"inversed\": true\r\n     *     }\r\n     *   }]\r\n     * }\r\n     * ```\r\n     *\r\n     * @since 4.8.7\r\n     * @param  value  Sort categories?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"sortBySeries\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Processes JSON-based config before it is applied to the object.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param config  Config\r\n   */\n  CategoryAxis.prototype.processConfig = function (config) {\n    if (config) {\n      if ($type.hasValue(config.sortBySeries) && $type.isString(config.sortBySeries)) {\n        if (this.map.hasKey(config.sortBySeries)) {\n          config.sortBySeries = this.map.getKey(config.sortBySeries);\n        } else {\n          this.addDelayedMap(\"sortBySeries\", config.sortBySeries);\n          delete config.sortBySeries;\n        }\n      }\n    }\n    _super.prototype.processConfig.call(this, config);\n  };\n  return CategoryAxis;\n}(Axis);\nexport { CategoryAxis };\n/**\r\n * Register class, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\nregistry.registeredClasses[\"CategoryAxis\"] = CategoryAxis;\nregistry.registeredClasses[\"CategoryAxisDataItem\"] = CategoryAxisDataItem;","map":{"version":3,"mappings":"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","names":["Axis","AxisDataItem","AxisRendererX","AxisRendererY","registry","Dictionary","CategoryAxisBreak","$math","$type","$iter","__extends","_super","_this","className","text","locations","category","endCategory","deltaPosition","applyTheme","Object","CategoryAxisDataItem","_adapterO","isEnabled","apply","properties","value","oldCategory","setProperty","hasValue","component","validateDataElement","deltaCoordinate","invalidateDataItems","invalidateSeries","axisFieldName","_lastDataItem","createDataItem","_disposers","push","dataItemsByCategory","addDisposer","mainDataSet","events","on","event","removeKey","oldValue","CategoryAxis","dataItem","axisLetter","processSeriesDataItem","categoryAxisDataItem","getKey","seriesId","uid","seriesDataItems","dataItems","remove","validateDataRange","each","_series","iterator","series","xAxis","yAxis","invalidateDataRange","startIndex","positionToIndex","start","endIndex","end","length","minIndex","maxIndex","i","axisDataItem","getIndex","i_1","seriesDataItem","index","isNumber","_axisBreaks","validate","dataCount","fitToRange","Math","floor","ceil","renderer","invalid","maxCount","axisLength","max","minGridDistance","Number","MAX_SAFE_INTEGER","frequency","min","_startIndex","_endIndex","fixAxisBreaks","_frequency","maxZoomFactor","resetIterators","itemIndex","__disabled","len","round","axisBreak","isInBreak","appendDataItem","axisBreaks","adjustedStartValue","adjustedEndValue","intersect","b","frequency_1","breakSize","itemIndex_1","validateBreaks","validateAxisRanges","ghostLabel","invalidate","invalidateLayout","_axisItemCount","categoryToIndex","position","indexToPosition","endPosition","fillEndIndex","fillPosition","fillEndPosition","isRange","point","positionToPoint","tick","disabled","updateTickElement","grid","updateGridElement","label","undefined","updateLabelElement","measuredWidth","measuredHeight","html","currentText","fill","axisFill","location","updateFillElement","fillRule","bullet","updateBullet","mask","clear","disposeData","dataContext","processDataItem","setKey","dataFields","create","difference","adjustDifference","startLocation","endLocation","eachContinue","breakStartIndex","breakEndIndex","categoryToPosition","angle","positionToAngle","x","y","categoryToPoint","startCategory","zoomToIndexes","startPos","endPos","getPositionRangePath","categoryX","categoryY","findNearest","index_1","category_1","sdi_1","abs","key","stackKey","range","getPositionX","isNaN","basePoint","categories","getPositionY","roundPosition","tooltipDataItem","tooltip","tooltipText","breakStartPosition","startPosition","breakEndPosition","breakPosition","getPositionLabel","initRenderer","baseGrid","getPropertyValue","setPropertyValue","config","sortBySeries","isString","map","hasKey","addDelayedMap","processConfig","registeredClasses"],"sources":["C:\\Users\\Lucian\\Documents\\DEV\\nodejs\\stock-market-api\\dev\\static\\node_modules\\src\\.internal\\charts\\axes\\CategoryAxis.ts"],"sourcesContent":["/**\r\n * Category axis module\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Axis, AxisItemLocation, AxisDataItem, IAxisProperties, IAxisDataFields, IAxisAdapters, IAxisEvents, IAxisDataItemAdapters } from \"./Axis\";\r\nimport { IPoint, IOrientationPoint } from \"../../core/defs/IPoint\";\r\nimport { Animation } from \"../../core/utils/Animation\";\r\nimport { AxisFill } from \"./AxisFill\";\r\nimport { AxisRenderer } from \"./AxisRenderer\";\r\nimport { AxisRendererX } from \"./AxisRendererX\";\r\nimport { AxisRendererY } from \"./AxisRendererY\";\r\nimport { SerialChart } from \"../types/SerialChart\";\r\nimport { AxisTick } from \"./AxisTick\";\r\nimport { Grid } from \"./Grid\";\r\nimport { AxisLabel } from \"./AxisLabel\";\r\nimport { registry } from \"../../core/Registry\";\r\nimport { Dictionary } from \"../../core/utils/Dictionary\";\r\nimport { XYSeries, XYSeriesDataItem } from \"../series/XYSeries\";\r\nimport { ColumnSeries } from \"../series/ColumnSeries\";\r\nimport { CategoryAxisBreak } from \"./CategoryAxisBreak\";\r\nimport * as $math from \"../../core/utils/Math\";\r\nimport * as $type from \"../../core/utils/Type\";\r\nimport * as $iter from \"../../core/utils/Iterator\";\r\nimport { IRange } from \"../../core/defs/IRange\";\r\n\r\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines a [[DataItem]] for [[CategoryAxis]].\r\n *\r\n * @see {@link DataItem}\r\n */\r\nexport class CategoryAxisDataItem extends AxisDataItem {\r\n\r\n\t/**\r\n\t * Defines a type of [[Component]] this data item is used for.\r\n\t */\r\n\tpublic _component!: CategoryAxis;\r\n\r\n\tpublic seriesDataItems: { [index: string]: XYSeriesDataItem[] } = {};\r\n\r\n\tpublic deltaAnimation: Animation;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t */\r\n\tpublic _adapter!: ICategoryAxisDataItemAdapters;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"CategoryAxisDataItem\";\r\n\t\tthis.text = \"{category}\";\r\n\r\n\t\tthis.locations.category = 0;\r\n\t\tthis.locations.endCategory = 1;\r\n\r\n\t\tthis.deltaPosition = 0;\r\n\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * Category.\r\n\t *\r\n\t * @param value  Category\r\n\t */\r\n\tpublic set category(value: string) {\r\n\t\tlet oldCategory = this.properties.category;\r\n\t\tthis.setProperty(\"category\", value);\r\n\t\tif ($type.hasValue(oldCategory) && oldCategory != value) {\r\n\t\t\tif (this.component) {\r\n\t\t\t\tthis.component.validateDataElement(this);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Category\r\n\t */\r\n\tpublic get category(): string {\r\n\t\tif (this._adapterO) {\r\n\t\t\tif (this._adapterO.isEnabled(\"category\")) {\r\n\t\t\t\treturn this._adapterO.apply(\"category\", this.properties.category);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this.properties.category;\r\n\t}\r\n\r\n\t/**\r\n\t * End category.\r\n\t *\r\n\t * Used for items that span several categories, like [[CategoryAxisBreak]].\r\n\t *\r\n\t * @param value  End category\r\n\t */\r\n\tpublic set endCategory(value: string) {\r\n\t\tthis.setProperty(\"endCategory\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return End category\r\n\t */\r\n\tpublic get endCategory(): string {\r\n\t\treturn this.properties.endCategory;\r\n\t}\r\n\r\n\tpublic set deltaPosition(value: number) {\r\n\t\tif (value != this.properties.deltaCoordinate) {\r\n\t\t\tthis.setProperty(\"deltaCoordinate\", value);\r\n\t\t\tif (this.component) {\r\n\t\t\t\tthis.component.invalidateDataItems();\r\n\t\t\t\tthis.component.invalidateSeries();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tpublic get deltaPosition(): number {\r\n\t\treturn this.properties.deltaCoordinate;\r\n\t}\r\n}\r\n\r\n/**\r\n * Defines adapters for [[DataItem]]\r\n * Includes both the [[Adapter]] definitions and properties\r\n * @see {@link Adapter}\r\n */\r\nexport interface ICategoryAxisDataItemAdapters extends IAxisDataItemAdapters {\r\n\tcategory: string;\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines data fields for [[CategoryAxis]].\r\n */\r\nexport interface ICategoryAxisDataFields extends IAxisDataFields {\r\n\r\n\t/**\r\n\t * A field that holds category information.\r\n\t */\r\n\tcategory?: string;\r\n\r\n}\r\n\r\n/**\r\n * Defines properties for [[CategoryAxis]].\r\n */\r\nexport interface ICategoryAxisProperties extends IAxisProperties {\r\n\tsortBySeries?: ColumnSeries;\r\n}\r\n\r\n/**\r\n * Defines events for [[CategoryAxis]].\r\n */\r\nexport interface ICategoryAxisEvents extends IAxisEvents { }\r\n\r\n/**\r\n * Defines adapter for [[CategoryAxis]].\r\n *\r\n * @see {@link Adapter}\r\n */\r\nexport interface ICategoryAxisAdapters extends IAxisAdapters, ICategoryAxisProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Used to create a category-based axis for the chart.\r\n *\r\n * ```TypeScript\r\n * // Create the axis\r\n * let xAxis = chart.xAxes.push(new am4charts.CategoryAxis());\r\n *\r\n * // Set settings\r\n * xAxis.title.text = \"Clients\";\r\n * ```\r\n * ```JavaScript\r\n * // Create the axis\r\n * var valueAxis = chart.xAxes.push(new am4charts.CategoryAxis());\r\n *\r\n * // Set settings\r\n * valueAxis.title.text = \"Clients\";\r\n * ```\r\n * ```JSON\r\n * \"xAxes\": [{\r\n *   \"type\": \"CategoryAxis\",\r\n *   \"title\": {\r\n *     \"text\": \"Clients\"\r\n *   }\r\n * }]\r\n * ```\r\n *\r\n * @see {@link ICategoryAxisEvents} for a list of available Events\r\n * @see {@link ICategoryAxisAdapters} for a list of available Adapters\r\n * @important\r\n */\r\nexport class CategoryAxis<T extends AxisRenderer = AxisRenderer> extends Axis<T> {\r\n\r\n\t/**\r\n\t * Defines data fields.\r\n\t */\r\n\tpublic _dataFields: ICategoryAxisDataFields;\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t */\r\n\tpublic _properties!: ICategoryAxisProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t */\r\n\tpublic _adapter!: ICategoryAxisAdapters;\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: ICategoryAxisEvents;\r\n\r\n\t/**\r\n\t * Defines the type of the Date Items.\r\n\t */\r\n\tpublic _dataItem: CategoryAxisDataItem;\r\n\r\n\t/**\r\n\t * Defines the type of the axis breaks.\r\n\t */\r\n\tpublic _axisBreak: CategoryAxisBreak;\r\n\r\n\t/**\r\n\t * A reference to chart the axis is for.\r\n\t */\r\n\tpublic chart: SerialChart;\r\n\r\n\t/**\r\n\t * Frequency of the labels on axis.\r\n\t */\r\n\tprotected _frequency: number;\r\n\r\n\t/**\r\n\t * A collection that holds Axis' data items sorted by each category.\r\n\t */\r\n\tpublic dataItemsByCategory: Dictionary<string, this[\"_dataItem\"]> = new Dictionary<string, this[\"_dataItem\"]>();\r\n\r\n\t/**\r\n\t * last data item is used for the closing grid\r\n\t */\r\n\tprotected _lastDataItem: CategoryAxisDataItem;\r\n\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\r\n\t\t// Init\r\n\t\tsuper();\r\n\t\tthis.className = \"CategoryAxis\";\r\n\r\n\t\t// Set field name\r\n\t\tthis.axisFieldName = \"category\";\r\n\r\n\t\tthis._lastDataItem = this.createDataItem();\r\n\t\tthis._lastDataItem.component = this;\r\n\t\tthis._disposers.push(this._lastDataItem);\r\n\r\n\r\n\t\t// Apply theme\r\n\t\tthis.applyTheme();\r\n\r\n\t\tlet dataItemsByCategory = this.dataItemsByCategory;\r\n\t\tthis.addDisposer(this.mainDataSet.events.on(\"removed\", function(event) {\r\n\t\t\tdataItemsByCategory.removeKey(event.oldValue.category);\r\n\t\t}))\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new/empty [[DataItem]] of the type appropriate for this object.\r\n\t *\r\n\t * @see {@link DataItem}\r\n\t * @return Data Item\r\n\t */\r\n\tprotected createDataItem(): this[\"_dataItem\"] {\r\n\t\treturn new CategoryAxisDataItem();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new/empty [[AxisBreak]] of the appropriate type.\r\n\t *\r\n\t * @return Axis break\r\n\t */\r\n\tprotected createAxisBreak(): this[\"_axisBreak\"] {\r\n\t\treturn new CategoryAxisBreak();\r\n\t}\r\n\r\n\t/**\r\n\t * Processes a related series' data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @param dataItem  Data item\r\n\t */\r\n\tpublic processSeriesDataItem(dataItem: XYSeriesDataItem, axisLetter?: string): void {\r\n\t\tsuper.processSeriesDataItem(dataItem, axisLetter);\r\n\t\tlet category: string = (<any>dataItem)[\"category\" + this.axisLetter];\r\n\t\tif ($type.hasValue(category)) {\r\n\t\t\tlet categoryAxisDataItem: this[\"_dataItem\"] = this.dataItemsByCategory.getKey(category);\r\n\t\t\tif (categoryAxisDataItem) {\r\n\t\t\t\tlet seriesId = dataItem.component.uid;\r\n\t\t\t\tlet seriesDataItems = categoryAxisDataItem.seriesDataItems[seriesId];\r\n\t\t\t\tif (!seriesDataItems) {\r\n\t\t\t\t\tseriesDataItems = [];\r\n\t\t\t\t\tcategoryAxisDataItem.seriesDataItems[seriesId] = seriesDataItems;\r\n\t\t\t\t}\r\n\t\t\t\tseriesDataItems.push(dataItem);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tdataItem.component.dataItems.remove(dataItem);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Validates the data range.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t */\r\n\tpublic validateDataRange(): void {\r\n\r\n\t\tsuper.validateDataRange();\r\n\r\n\t\t$iter.each(this._series.iterator(), (series) => {\r\n\t\t\tif ((series.xAxis instanceof CategoryAxis) && (series.yAxis instanceof CategoryAxis)) {\r\n\t\t\t\tseries.invalidateDataRange();\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tlet startIndex = this.positionToIndex(this.start);\r\n\t\t\t\tlet endIndex = this.positionToIndex(this.end);\r\n\r\n\t\t\t\tif (endIndex >= this.dataItems.length) {\r\n\t\t\t\t\tendIndex--;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet seriesId = series.uid;\r\n\t\t\t\tlet minIndex: number;\r\n\t\t\t\tlet maxIndex: number;\r\n\r\n\t\t\t\tfor (let i = startIndex; i <= endIndex; i++) {\r\n\t\t\t\t\tlet axisDataItem = this.dataItems.getIndex(i);\r\n\t\t\t\t\tif (axisDataItem) {\r\n\t\t\t\t\t\tlet seriesDataItems = axisDataItem.seriesDataItems[seriesId];\r\n\r\n\t\t\t\t\t\tif (seriesDataItems) {\r\n\t\t\t\t\t\t\tfor (let i = 0; i < seriesDataItems.length; i++) {\r\n\t\t\t\t\t\t\t\tlet seriesDataItem = seriesDataItems[i];\r\n\t\t\t\t\t\t\t\tif (seriesDataItem) {\r\n\t\t\t\t\t\t\t\t\tlet index = seriesDataItem.index;\r\n\t\t\t\t\t\t\t\t\tif (!$type.isNumber(minIndex) || index < minIndex) {\r\n\t\t\t\t\t\t\t\t\t\tminIndex = index;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tif (!$type.isNumber(maxIndex) || index > maxIndex) {\r\n\t\t\t\t\t\t\t\t\t\tmaxIndex = index;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ($type.isNumber(minIndex)) {\r\n\t\t\t\t\tseries.startIndex = minIndex;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tseries.start = this.start;\r\n\t\t\t\t}\r\n\t\t\t\tif ($type.isNumber(maxIndex)) {\r\n\t\t\t\t\tseries.endIndex = maxIndex + 1;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tseries.end = this.end;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// range might not change, but axis breaks might.\r\n\t\t\t\tif (this._axisBreaks && this._axisBreaks.length > 0) {\r\n\t\t\t\t\tseries.invalidateDataRange();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Validates the whole axis. Causes it to redraw.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t */\r\n\tpublic validate(): void {\r\n\r\n\t\tsuper.validate();\r\n\r\n\t\tlet dataCount: number = this.dataItems.length;\r\n\r\n\t\tlet startIndex = $math.fitToRange(Math.floor(this.start * dataCount - 1), 0, dataCount);\r\n\t\tlet endIndex = $math.fitToRange(Math.ceil(this.end * dataCount), 0, dataCount);\r\n\r\n\t\tif (this.renderer.invalid) {\r\n\t\t\tthis.renderer.validate();\r\n\t\t}\r\n\r\n\t\t// find frequency at which we'll show items\r\n\t\tlet maxCount: number = this.renderer.axisLength / Math.max(this.renderer.minGridDistance, 1 / Number.MAX_SAFE_INTEGER);\r\n\t\tlet frequency: number = Math.min(this.dataItems.length, Math.ceil((endIndex - startIndex) / maxCount));\r\n\r\n\t\tthis._startIndex = Math.floor(startIndex / frequency) * frequency;\r\n\t\tthis._endIndex = Math.ceil(this.end * dataCount);\r\n\r\n\t\tthis.fixAxisBreaks();\r\n\r\n\t\tif (this._startIndex == this._endIndex) {\r\n\t\t\tthis._endIndex++;\r\n\t\t}\r\n\r\n\t\tthis._frequency = frequency;\r\n\r\n\t\tif (this.axisLength <= 0) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis.maxZoomFactor = this.dataItems.length;\r\n\t\tif (this.dataItems.length <= 0) {\r\n\t\t\tthis.maxZoomFactor = 1;\r\n\t\t}\r\n\r\n\t\tthis.resetIterators();\r\n\r\n\t\t// it's important to use protected variables here, as getters will return 0 - length\r\n\t\t// TODO use iterator instead\r\n\t\t// @ todo: not solved cat axis item fading\r\n\t\tstartIndex = $math.max(0, this._startIndex - this._frequency);\r\n\t\tendIndex = $math.min(this.dataItems.length, this._endIndex + this._frequency);\r\n\r\n\t\tlet itemIndex = 0;\r\n\r\n\t\tfor (let i = 0; i < startIndex; i++) {\r\n\t\t\tlet dataItem = this.dataItems.getIndex(i);\r\n\t\t\tdataItem.__disabled = true;\r\n\t\t}\r\n\r\n\t\tfor (let i = endIndex, len = this.dataItems.length; i < len; i++) {\r\n\t\t\tlet dataItem = this.dataItems.getIndex(i);\r\n\t\t\tdataItem.__disabled = true;\r\n\t\t}\r\n\r\n\t\tfor (let i = startIndex; i < endIndex; i++) {\r\n\t\t\tif (i < this.dataItems.length) {\r\n\t\t\t\tlet dataItem: this[\"_dataItem\"] = this.dataItems.getIndex(i);\r\n\t\t\t\tif (i / this._frequency == Math.round(i / this._frequency)) {\r\n\t\t\t\t\tlet axisBreak: CategoryAxisBreak = this.isInBreak(i);\r\n\t\t\t\t\tif (!axisBreak) {\r\n\t\t\t\t\t\tthis.appendDataItem(dataItem);\r\n\t\t\t\t\t\tthis.validateDataElement(dataItem, itemIndex);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\titemIndex++;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t//previously we disabled all before, but this is better for cpu\r\n\t\t\t\t\t//this.validateDataElement(dataItem, itemIndex); // helps to solve shrinking // not good - creates all items\r\n\t\t\t\t\tdataItem.__disabled = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.appendDataItem(this._lastDataItem);\r\n\t\tthis.validateDataElement(this._lastDataItem, itemIndex + 1, this.dataItems.length);\r\n\r\n\t\tif (this._axisBreaks) {\r\n\t\t\tlet axisBreaks = this._axisBreaks;\r\n\r\n\t\t\taxisBreaks.each((axisBreak) => {\r\n\t\t\t\tlet adjustedStartValue: number = axisBreak.adjustedStartValue;\r\n\t\t\t\tlet adjustedEndValue: number = axisBreak.adjustedEndValue;\r\n\r\n\t\t\t\tif ($math.intersect({ start: adjustedStartValue, end: adjustedEndValue }, { start: this._startIndex, end: this._endIndex })) {\r\n\r\n\t\t\t\t\tfor (let b = adjustedStartValue; b <= adjustedEndValue; b++) {\r\n\t\t\t\t\t\tlet dataItem = this.dataItems.getIndex(b);\r\n\t\t\t\t\t\tdataItem.__disabled = true;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet frequency: number = $math.fitToRange(Math.ceil(this._frequency / axisBreak.breakSize), 1, adjustedEndValue - adjustedStartValue);\r\n\t\t\t\t\tlet itemIndex = 0;\r\n\t\t\t\t\tif (axisBreak.breakSize > 0) {\r\n\t\t\t\t\t\t// TODO use iterator instead\r\n\t\t\t\t\t\tfor (let b = adjustedStartValue; b <= adjustedEndValue; b = b + frequency) {\r\n\t\t\t\t\t\t\tlet dataItem: this[\"_dataItem\"] = this.dataItems.getIndex(b);\r\n\t\t\t\t\t\t\tdataItem.__disabled = false;\r\n\t\t\t\t\t\t\tthis.appendDataItem(dataItem);\r\n\t\t\t\t\t\t\tthis.validateDataElement(dataItem, itemIndex);\r\n\t\t\t\t\t\t\titemIndex++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tthis.validateBreaks();\r\n\t\tthis.validateAxisRanges();\r\n\r\n\t\tthis.ghostLabel.invalidate(); // solves font issue\r\n\t\tthis.renderer.invalidateLayout();\r\n\t}\r\n\r\n\t/**\r\n\t * [validateDataElement description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @param dataItem   [description]\r\n\t * @param itemIndex  [description]\r\n\t */\r\n\tpublic validateDataElement(dataItem: this[\"_dataItem\"], itemIndex?: number, index?: number): void {\r\n\t\tsuper.validateDataElement(dataItem);\r\n\r\n\t\tdataItem.itemIndex = this._axisItemCount;\r\n\t\tthis._axisItemCount++;\r\n\r\n\t\t//dataItem.__disabled = false;\r\n\r\n\t\tlet renderer: AxisRenderer = this.renderer;\r\n\t\tif (!$type.isNumber(index)) {\r\n\t\t\tindex = this.categoryToIndex(dataItem.category);\r\n\t\t}\r\n\r\n\t\tlet endIndex = this.categoryToIndex(dataItem.endCategory);\r\n\r\n\t\tif (!$type.isNumber(endIndex)) {\r\n\t\t\tendIndex = index;\r\n\t\t}\r\n\r\n\t\tlet position: number = this.indexToPosition(index, dataItem.locations.category);\r\n\t\tlet endPosition: number = this.indexToPosition(endIndex, dataItem.locations.endCategory);\r\n\r\n\t\tdataItem.position = position;\r\n\r\n\t\tlet fillEndIndex: number;\r\n\t\tlet fillPosition: number;\r\n\t\tlet fillEndPosition: number;\r\n\r\n\t\tif (dataItem.isRange) {\r\n\t\t\tfillEndIndex = endIndex;\r\n\t\t\tfillPosition = this.indexToPosition(index, dataItem.locations.category);\r\n\t\t\tfillEndPosition = this.indexToPosition(fillEndIndex, dataItem.locations.endCategory);\r\n\t\t}\r\n\r\n\t\tdataItem.point = renderer.positionToPoint(position);\r\n\r\n\t\tlet tick: AxisTick = dataItem.tick;\r\n\t\tif (tick && !tick.disabled) {\r\n\t\t\trenderer.updateTickElement(tick, position, endPosition);\r\n\t\t}\r\n\r\n\t\tlet grid: Grid = dataItem.grid;\r\n\t\tif (grid && !grid.disabled) {\r\n\t\t\trenderer.updateGridElement(grid, position, endPosition);\r\n\t\t}\r\n\r\n\r\n\t\tlet label: AxisLabel = dataItem.label;\r\n\t\tif (label && !label.disabled) {\r\n\t\t\t// theorethically this might result problems if category text changes, the range text won't change. But otherwise range.label.text = \"custom text\" won't work, which is not intuitive.\r\n\t\t\tif (!dataItem.isRange || label.text == undefined) {\r\n\t\t\t\tdataItem.text = dataItem.text;\r\n\t\t\t}\r\n\r\n\t\t\trenderer.updateLabelElement(label, position, endPosition);\r\n\r\n\t\t\tif ((renderer instanceof AxisRendererY && dataItem.label.measuredWidth > this.ghostLabel.measuredWidth) || (renderer instanceof AxisRendererX && dataItem.label.measuredHeight > this.ghostLabel.measuredHeight)) {\r\n\t\t\t\tif (dataItem.label.html) {\r\n\t\t\t\t\tthis.ghostLabel.html = dataItem.label.currentText;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthis.ghostLabel.text = dataItem.label.currentText;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet fill: AxisFill = dataItem.axisFill;\r\n\t\tif (fill && !fill.disabled) {\r\n\r\n\t\t\tif (!dataItem.isRange) {\r\n\t\t\t\tfillEndIndex = index + this._frequency;\r\n\t\t\t\tfillPosition = this.indexToPosition(index, fill.location);\r\n\t\t\t\tfillEndPosition = this.indexToPosition(fillEndIndex, fill.location);\r\n\t\t\t}\r\n\r\n\t\t\trenderer.updateFillElement(fill, fillPosition, fillEndPosition);\r\n\t\t\tif (!dataItem.isRange) {\r\n\t\t\t\tthis.fillRule(dataItem, itemIndex);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (dataItem.bullet) {\r\n\t\t\trenderer.updateBullet(dataItem.bullet, position, endPosition);\r\n\t\t}\r\n\r\n\r\n\t\tlet mask: AxisFill = dataItem.mask;\r\n\t\tif (mask) {\r\n\t\t\trenderer.updateFillElement(mask, fillPosition, fillEndPosition);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic disposeData() {\r\n\t\tthis.dataItemsByCategory.clear();\r\n\t\tsuper.disposeData();\r\n\t}\r\n\r\n\t/**\r\n\t * Processes the axis data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param dataItem     Data item\r\n\t * @param dataContext  The raw data that corresponds to this data item\r\n\t */\r\n\tpublic processDataItem(dataItem: this[\"_dataItem\"], dataContext: Object): void {\r\n\t\tif (dataItem) {\r\n\t\t\t// creat a collection for fast access\r\n\t\t\tsuper.processDataItem(dataItem, dataContext);\r\n\t\t\t// check if such category already exists\r\n\t\t\t//let existingDataItem: CategoryAxisDataItem = this.dataItemsByCategory.getKey(dataItem.category);\r\n\t\t\t//if (existingDataItem && existingDataItem != dataItem) {\r\n\t\t\t//\tthis.dataItems.remove(existingDataItem);\r\n\t\t\t//}\r\n\r\n\t\t\tif ($type.hasValue(dataItem.category)) {\r\n\t\t\t\tthis.dataItemsByCategory.setKey(dataItem.category, dataItem);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tprotected getDataItem(dataContext?: any): this[\"_dataItem\"] {\r\n\t\tlet category: string = <string>(dataContext[this.dataFields.category]);\r\n\t\tif ($type.hasValue(category)) {\r\n\t\t\tlet dataItem: this[\"_dataItem\"] = this.dataItemsByCategory.getKey(category);\r\n\r\n\t\t\tif (dataItem) {\r\n\t\t\t\treturn dataItem;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\treturn this.dataItems.create();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a category index to an actual screen coordinate on the axis.\r\n\t *\r\n\t * `location` identifies relative location within category. 0 - beginning,\r\n\t * 0.5 - middle, 1 - end, and anything inbetween.\r\n\t *\r\n\t * @param index     Index\r\n\t * @param location  Location (0-1)\r\n\t * @return Position (px)\r\n\t */\r\n\tpublic indexToPosition(index: number, location?: AxisItemLocation | number): number {\r\n\t\tif (!$type.isNumber(location)) {\r\n\t\t\tlocation = 0.5;\r\n\t\t}\r\n\r\n\t\tlet startIndex: number = this.startIndex;\r\n\t\tlet endIndex: number = this.endIndex;\r\n\r\n\t\tlet difference: number = this.adjustDifference(startIndex, endIndex);\r\n\r\n\t\tlet startLocation = this.startLocation;\r\n\t\tlet endLocation = this.endLocation;\r\n\r\n\t\tdifference -= startLocation;\r\n\t\tdifference -= (1 - endLocation);\r\n\r\n\t\tif (this._axisBreaks) {\r\n\t\t\tlet axisBreaks = this._axisBreaks;\r\n\r\n\t\t\t$iter.eachContinue(axisBreaks.iterator(), (axisBreak) => {\r\n\t\t\t\tlet breakStartIndex: number = axisBreak.adjustedStartValue;\r\n\t\t\t\tlet breakEndIndex: number = axisBreak.adjustedEndValue;\r\n\r\n\t\t\t\tif (index < startIndex || !$type.isNumber(breakStartIndex) || !$type.isNumber(breakEndIndex)) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ($math.intersect({ start: breakStartIndex, end: breakEndIndex }, { start: startIndex, end: endIndex })) {\r\n\t\t\t\t\tbreakStartIndex = Math.max(startIndex, breakStartIndex);\r\n\t\t\t\t\tbreakEndIndex = Math.min(endIndex, breakEndIndex);\r\n\r\n\t\t\t\t\tlet breakSize: number = axisBreak.breakSize;\r\n\r\n\t\t\t\t\t// value to the right of break end\r\n\t\t\t\t\tif (index > breakEndIndex) {\r\n\t\t\t\t\t\tstartIndex += (breakEndIndex - breakStartIndex) * (1 - breakSize);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// value to the left of break start\r\n\t\t\t\t\telse if (index < breakStartIndex) {\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// value within break\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tindex = breakStartIndex + (index - breakStartIndex) * breakSize;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn true;\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tlet deltaPosition = 0;\r\n\t\tlet dataItem = this.dataItems.getIndex(index);\r\n\t\tif (dataItem) {\r\n\t\t\tdeltaPosition = dataItem.deltaPosition;\r\n\t\t}\r\n\r\n\t\treturn $math.round(deltaPosition + (index + location - startLocation - startIndex) / difference, 5);\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a string category name to relative position on axis.\r\n\t *\r\n\t * `location` identifies relative location within category. 0 - beginning,\r\n\t * 0.5 - middle, 1 - end, and anything inbetween.\r\n\t *\r\n\t * @param category  Category name\r\n\t * @param location  Location (0-1)\r\n\t * @return Position\r\n\t */\r\n\tpublic categoryToPosition(category: string, location?: AxisItemLocation): number {\r\n\t\tlet index: number = this.categoryToIndex(category);\r\n\t\treturn this.indexToPosition(index, location);\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a string category name to a orientation point (x, y, angle) on axis\r\n\t *\r\n\t * `location` identifies relative location within category. 0 - beginning,\r\n\t * 0.5 - middle, 1 - end, and anything inbetween.\r\n\t * @param category  Category name\r\n\t * @param location  Location (0-1)\r\n\t * @return Orientation point\r\n\t */\r\n\tpublic categoryToPoint(category: string, location?: AxisItemLocation): IOrientationPoint {\r\n\t\tlet position = this.categoryToPosition(category, location);\r\n\t\tlet point = this.renderer.positionToPoint(position);\r\n\t\tlet angle = this.renderer.positionToAngle(position);\r\n\t\treturn { x: point.x, y: point.y, angle: angle };\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Converts a string category name to a orientation point (x, y, angle) on axis\r\n\t *\r\n\t * `location` identifies relative location within category. 0 - beginning,\r\n\t * 0.5 - middle, 1 - end, and anything inbetween.\r\n\t * @param category  Category name\r\n\t * @param location  Location (0-1)\r\n\t * @return Orientation point\r\n\t */\r\n\tanyToPoint(category: string, location?: AxisItemLocation): IOrientationPoint {\r\n\t\treturn this.categoryToPoint(category, location);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Converts a string category name to relative position on axis.\r\n\t *\r\n\t * An alias to `categoryToPosition()`.\r\n\t *\r\n\t * @param category  Category name\r\n\t * @param location  Location (0-1)\r\n\t * @return Relative position\r\n\t */\r\n\tpublic anyToPosition(category: string, location?: AxisItemLocation): number {\r\n\t\treturn this.categoryToPosition(category, location);\r\n\t}\r\n\r\n\t/**\r\n\t * Converts named category to an index of data item it corresponds to.\r\n\t *\r\n\t * @param category  Category\r\n\t * @return Data item index\r\n\t */\r\n\tpublic categoryToIndex(category: string): number {\r\n\t\tif ($type.hasValue(category)) {\r\n\t\t\tlet dataItem: this[\"_dataItem\"] = this.dataItemsByCategory.getKey(category);\r\n\t\t\tif (dataItem) {\r\n\t\t\t\treturn dataItem.index;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Zooms the axis to specific named ctaegories.\r\n\t *\r\n\t * @param startCategory  Start category\r\n\t * @param endCategory    End category\r\n\t */\r\n\tpublic zoomToCategories(startCategory: string, endCategory: string): void {\r\n\t\tthis.zoomToIndexes(this.categoryToIndex(startCategory), this.categoryToIndex(endCategory) + 1);\r\n\t}\r\n\r\n\t/**\r\n\t * [getAnyRangePath description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @param start         [description]\r\n\t * @param end           [description]\r\n\t * @param startLocation [description]\r\n\t * @param endLocation   [description]\r\n\t * @return [description]\r\n\t */\r\n\tpublic getAnyRangePath(start: string, end: string, startLocation?: AxisItemLocation, endLocation?: AxisItemLocation): string {\r\n\t\tlet startPos: number = this.categoryToPosition(start, startLocation);\r\n\t\tlet endPos: number = this.categoryToPosition(end, endLocation);\r\n\t\treturn this.getPositionRangePath(startPos, endPos); // Base class (Axis) gets range shape from AxisRenderer\r\n\t}\r\n\r\n\t/**\r\n\t * Takes an absolute position (px) within axis and adjust it to a specific\r\n\t * `location` within category it corresponds to.\r\n\t *\r\n\t * @param position  Source position (px)\r\n\t * @param location  Location within category (0-1)\r\n\t * @return Adjusted position (px)\r\n\t */\r\n\tpublic roundPosition(position: number, location?: AxisItemLocation): number {\r\n\t\tlet index: number = this.positionToIndex(position);\r\n\t\treturn this.indexToPosition(index, location);\r\n\t}\r\n\r\n\t/**\r\n\t * Finds and returns first series data item with specific category\r\n\t * @param series    Target series\r\n\t * @param category  Category\r\n\t * @return XYSeriesDataItem data item\r\n\t */\r\n\tpublic getFirstSeriesDataItem(series: XYSeries, category: string): XYSeriesDataItem {\r\n\r\n\t\tfor (let i = 0; i < series.dataItems.length; i++) {\r\n\t\t\tlet dataItem = series.dataItems.getIndex(i);\r\n\t\t\tif (series.xAxis == this) {\r\n\t\t\t\tif (dataItem.categoryX == category) {\r\n\t\t\t\t\treturn dataItem;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (series.yAxis == this) {\r\n\t\t\t\tif (dataItem.categoryY == category) {\r\n\t\t\t\t\treturn dataItem;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Finds and returns last series data item with specific category.\r\n\t * @param series    Target series\r\n\t * @param category  Category\r\n\t * @return XYSeriesDataItem data item\r\n\t */\r\n\tpublic getLastSeriesDataItem(series: XYSeries, category: string): XYSeriesDataItem {\r\n\r\n\t\tfor (let i = series.dataItems.length - 1; i >= 0; i--) {\r\n\t\t\tlet dataItem = series.dataItems.getIndex(i);\r\n\t\t\tif (series.xAxis == this) {\r\n\t\t\t\tif (dataItem.categoryX == category) {\r\n\t\t\t\t\treturn dataItem;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (series.yAxis == this) {\r\n\t\t\t\tif (dataItem.categoryY == category) {\r\n\t\t\t\t\treturn dataItem;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// todo: optimize\r\n\tpublic getSeriesDataItemByCategory(category: string, series: XYSeries): XYSeriesDataItem {\r\n\t\tlet seriesDataItem: XYSeriesDataItem;\r\n\t\tseries.dataItems.each((dataItem) => {\r\n\t\t\tif (series.xAxis == this) {\r\n\t\t\t\tif (dataItem.categoryX == category) {\r\n\t\t\t\t\tseriesDataItem = dataItem;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (series.yAxis == this) {\r\n\t\t\t\tif (dataItem.categoryY == category) {\r\n\t\t\t\t\tseriesDataItem = dataItem;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\treturn seriesDataItem;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Returns a data item from Series that corresponds to a specific absolute\r\n\t * position on the Axis.\r\n\t *\r\n\t * @param series    Target series\r\n\t * @param position  Position (px)\r\n\t * @return XYSeriesDataItem data item\r\n\t */\r\n\tpublic getSeriesDataItem(series: XYSeries, position: number, findNearest?: boolean): XYSeriesDataItem {\r\n\r\n\t\tif ($type.isNumber(position)) {\r\n\r\n\t\t\tlet index = this.positionToIndex(position);\r\n\r\n\t\t\tif (index >= this.dataItems.length) {\r\n\t\t\t\tindex--;\r\n\t\t\t}\r\n\r\n\t\t\tlet dataItem = this.dataItems.getIndex(index);\r\n\r\n\t\t\tif (dataItem) {\r\n\t\t\t\tlet category = dataItem.category;\r\n\t\t\t\tlet sdi: XYSeriesDataItem;\r\n\r\n\t\t\t\tlet seriesDataItem = series.dataItems.getIndex(index);\r\n\t\t\t\tif (seriesDataItem) {\r\n\t\t\t\t\tif (series.xAxis == this) {\r\n\t\t\t\t\t\tif (seriesDataItem.categoryX == category) {\r\n\t\t\t\t\t\t\treturn seriesDataItem;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (series.yAxis == this) {\r\n\t\t\t\t\t\tif (seriesDataItem.categoryY == category) {\r\n\t\t\t\t\t\t\treturn seriesDataItem;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tseries.dataItems.each((dataItem) => {\r\n\t\t\t\t\tif (series.xAxis == this) {\r\n\t\t\t\t\t\tif (dataItem.categoryX == category) {\r\n\t\t\t\t\t\t\tif (!sdi) {\r\n\t\t\t\t\t\t\t\tsdi = dataItem;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (Math.abs(index - sdi.index) > Math.abs(index - dataItem.index)) {\r\n\t\t\t\t\t\t\t\tsdi = dataItem;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (series.yAxis == this) {\r\n\t\t\t\t\t\tif (dataItem.categoryY == category) {\r\n\t\t\t\t\t\t\tif (!sdi) {\r\n\t\t\t\t\t\t\t\tsdi = dataItem;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (Math.abs(index - sdi.index) > Math.abs(index - dataItem.index)) {\r\n\t\t\t\t\t\t\t\tsdi = dataItem;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\r\n\t\t\t\t//@todo\r\n\t\t\t\tif (findNearest) {\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn sdi;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Returns the X coordinate for series' data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t * @param dataItem  Data item\r\n\t * @param key       Category\r\n\t * @param location  Location (0-1)\r\n\t * @return X coordinate (px)\r\n\t */\r\n\tpublic getX(dataItem: XYSeriesDataItem, key?: string, location?: number, stackKey?: string, range?: IRange): number {\r\n\t\tlet position = this.getPositionX(dataItem, key, location, stackKey, range);\r\n\r\n\t\tif ($type.isNaN(position)) {\r\n\t\t\treturn this.basePoint.x;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn this.renderer.positionToPoint(position).x;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns relative position on axis for series' data item.\r\n\t *\r\n\t * @since 4.5.14\r\n\t * @param  dataItem  Data item\r\n\t * @param  key       Category\r\n\t * @param  location  Location (0-1)\r\n\t * @return           Relative position\r\n\t */\r\n\tpublic getPositionX(dataItem: XYSeriesDataItem, key?: string, location?: number, stackKey?: string, range?: IRange): number {\r\n\t\tlet position;\r\n\t\tif ($type.hasValue(key)) {\r\n\t\t\tposition = this.categoryToPosition(dataItem.categories[key], location);\r\n\t\t}\r\n\r\n\t\tif (range) {\r\n\t\t\tposition = $math.fitToRange(position, range.start, range.end);\r\n\t\t}\r\n\r\n\t\treturn position;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the Y coordinate for series' data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t * @param dataItem  Data item\r\n\t * @param key       Category\r\n\t * @param location  Location (0-1)\r\n\t * @return Y coordinate (px)\r\n\t */\r\n\tpublic getY(dataItem: XYSeriesDataItem, key?: string, location?: number, stackKey?: string, range?: IRange): number {\r\n\r\n\t\tlet position = this.getPositionY(dataItem, key, location, stackKey, range);\r\n\r\n\t\tif ($type.isNaN(position)) {\r\n\t\t\treturn this.basePoint.y;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn this.renderer.positionToPoint(position).y;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns relative position on axis for series' data item.\r\n\t *\r\n\t * @since 4.5.14\r\n\t * @param  dataItem  Data item\r\n\t * @param  key       Category\r\n\t * @param  location  Location (0-1)\r\n\t * @return           Relative position\r\n\t */\r\n\tpublic getPositionY(dataItem: XYSeriesDataItem, key?: string, location?: number, stackKey?: string, range?: IRange): number {\r\n\t\tlet position;\r\n\t\tif ($type.hasValue(key)) {\r\n\t\t\tposition = this.categoryToPosition(dataItem.categories[key], location);\r\n\t\t}\r\n\r\n\t\tif (range) {\r\n\t\t\tposition = $math.fitToRange(position, range.start, range.end);\r\n\t\t}\r\n\r\n\t\treturn position;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an angle for series data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t * @param dataItem  Data item\r\n\t * @param key       Category\r\n\t * @param location  Location (0-1)\r\n\t * @param stackKey  Stack key (?)\r\n\t * @param range Range to fit in\r\n\t * @return Angle\r\n\t */\r\n\tpublic getAngle(dataItem: XYSeriesDataItem, key: string, location?: number, stackKey?: string, range?: IRange): number {\r\n\t\tlet position = this.categoryToPosition(dataItem.categories[key], location);\r\n\r\n\t\tif (range) {\r\n\t\t\tposition = $math.fitToRange(position, range.start, range.end);\r\n\t\t}\r\n\r\n\t\treturn this.positionToAngle(position);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an absolute pixel coordinate of the start of the cell (category),\r\n\t * that specific position value falls into.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t * @param position  Position (px)\r\n\t * @return Cell start position (px)\r\n\t */\r\n\tpublic getCellStartPosition(position: number): number {\r\n\t\treturn this.roundPosition(position, 0);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an absolute pixel coordinate of the end of the cell (category),\r\n\t * that specific position value falls into.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t * @param position  Position (px)\r\n\t * @return Cell end position (px)\r\n\t */\r\n\tpublic getCellEndPosition(position: number): number {\r\n\t\treturn this.roundPosition(position, 1);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns text to show in a category tooltip, based on specific position\r\n\t * within axis.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param position  Position (px)\r\n\t * @return Label (category)\r\n\t */\r\n\tpublic getTooltipText(position: number): string {\r\n\t\tlet dataItem: this[\"_dataItem\"] = this.dataItems.getIndex(this.positionToIndex(position));\r\n\r\n\t\tif (dataItem) {\r\n\t\t\tthis.tooltipDataItem = dataItem;\r\n\t\t\tthis.tooltip.dataItem = dataItem;\r\n\t\t\tif (this.tooltipText) {\r\n\t\t\t\treturn this.tooltipText;\r\n\t\t\t}\r\n\r\n\t\t\tif (!this._adapterO) {\r\n\t\t\t\treturn dataItem.category;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\treturn this._adapterO.apply(\"getTooltipText\", dataItem.category);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an index of the category that corresponds to specific pixel\r\n\t * position within axis.\r\n\t *\r\n\t * @param position  Position (px)\r\n\t * @return Category index\r\n\t */\r\n\tpublic positionToIndex(position: number): number {\r\n\t\tposition = $math.round(position, 10);\r\n\t\tif (position < 0) {\r\n\t\t\tposition = 0;\r\n\t\t}\r\n\r\n\t\tif (position > 1) {\r\n\t\t\tposition = 1;\r\n\t\t}\r\n\r\n\t\tlet startIndex: number = this.startIndex;\r\n\t\tlet endIndex: number = this.endIndex;\r\n\t\tlet difference: number = endIndex - startIndex - this.startLocation - (1 - this.endLocation);\r\n\r\n\t\tposition += 1 / difference * this.startLocation;\r\n\t\tlet index: number = null;\r\n\r\n\t\tif (this._axisBreaks) {\r\n\t\t\tlet axisBreaks = this._axisBreaks;\r\n\r\n\t\t\t// in case we have some axis breaks\r\n\t\t\t$iter.eachContinue(axisBreaks.iterator(), (axisBreak) => {\r\n\t\t\t\tlet breakStartPosition: number = axisBreak.startPosition;\r\n\t\t\t\tlet breakEndPosition: number = axisBreak.endPosition;\r\n\r\n\t\t\t\tlet breakStartIndex: number = axisBreak.adjustedStartValue;\r\n\t\t\t\tlet breakEndIndex: number = axisBreak.adjustedEndValue;\r\n\r\n\t\t\t\tbreakStartIndex = $math.max(breakStartIndex, startIndex);\r\n\t\t\t\tbreakEndIndex = $math.min(breakEndIndex, endIndex);\r\n\r\n\t\t\t\tlet breakSize: number = axisBreak.breakSize;\r\n\r\n\t\t\t\tdifference -= (breakEndIndex - breakStartIndex) * (1 - breakSize);\r\n\r\n\t\t\t\t// position to the right of break end\r\n\t\t\t\tif (position > breakEndPosition) {\r\n\t\t\t\t\tstartIndex += (breakEndIndex - breakStartIndex) * (1 - breakSize);\r\n\t\t\t\t}\r\n\t\t\t\t// position to the left of break start\r\n\t\t\t\telse if (position < breakStartPosition) {\r\n\r\n\t\t\t\t}\r\n\t\t\t\t// value within break\r\n\t\t\t\telse {\r\n\t\t\t\t\tlet breakPosition = (position - breakStartPosition) / (breakEndPosition - breakStartPosition);\r\n\t\t\t\t\tindex = breakStartIndex + Math.round(breakPosition * (breakEndIndex - breakStartIndex));\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn true;\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tif (!$type.isNumber(index)) {\r\n\t\t\tindex = Math.floor(position * difference + startIndex);\r\n\t\t}\r\n\t\tif (index >= this.dataItems.length) {\r\n\t\t\tindex = this.dataItems.length - 1;\r\n\t\t}\r\n\t\t// not good, when panning out of bounds, each time one less item gets selected\r\n\t\t//if (index >= endIndex) {\r\n\t\t//\tindex--;\r\n\t\t//}\r\n\r\n\t\treturn index;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns category based on position.\r\n\t *\r\n\t * Please note that `position` represents position within axis which may be\r\n\t * zoomed and not correspond to Cursor's `position`.\r\n\t *\r\n\t * To convert Cursor's `position` to Axis' `position` use `toAxisPosition()` method.\r\n\t *\r\n\t * This is a synonim of `getPositionLabel()` implemented here for consistentcy.\r\n\t *\r\n\t * @since 4.3.8\r\n\t * @see {@link https://www.amcharts.com/docs/v4/tutorials/tracking-cursors-position-via-api/#Tracking_Cursor_s_position} For more information about cursor tracking.\r\n\t * @param position  Relative position on axis (0-1)\r\n\t * @return Position label\r\n\t */\r\n\tpublic positionToCategory(position: number): string {\r\n\t\treturn this.getPositionLabel(position);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns category based on position.\r\n\t *\r\n\t * Please note that `position` represents position within axis which may be\r\n\t * zoomed and not correspond to Cursor's `position`.\r\n\t *\r\n\t * To convert Cursor's `position` to Axis' `position` use `toAxisPosition()` method.\r\n\t *\r\n\t * @see {@link https://www.amcharts.com/docs/v4/tutorials/tracking-cursors-position-via-api/#Tracking_Cursor_s_position} For more information about cursor tracking.\r\n\t * @param position  Relative position on axis (0-1)\r\n\t * @return Position label\r\n\t */\r\n\tpublic getPositionLabel(position: number): string {\r\n\t\tlet dataItem: this[\"_dataItem\"] = this.dataItems.getIndex(this.positionToIndex(position));\r\n\t\tif (dataItem) {\r\n\t\t\treturn dataItem.category;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Coordinates of the actual axis start.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @return Base point\r\n\t */\r\n\tpublic get basePoint(): IPoint {\r\n\t\t// This makes base grid to be drawn at the end of the axis and adds extra\r\n\t\t// grid which we need to nicely close the chart.\r\n\t\treturn this.renderer.positionToPoint(1);\r\n\t}\r\n\r\n\t/**\r\n\t * Initializes Axis' renderer.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic initRenderer(): void {\r\n\t\tsuper.initRenderer();\r\n\r\n\t\tlet renderer = this.renderer;\r\n\t\trenderer.baseGrid.disabled = true;\r\n\t}\r\n\r\n\t/**\r\n\t * Current frequency of labels of the axis.\r\n\t *\r\n\t * Normally it would be 1, but when labels start to be hidden due\r\n\t * to `minGridDistance` this read-only property will increase.\r\n\t *\r\n\t * @readonly\r\n\t * @since 4.2.0\r\n\t * @return Label frequency\r\n\t */\r\n\tpublic get frequency(): number {\r\n\t\treturn this._frequency;\r\n\t}\r\n\r\n\t/**\r\n\t * If set to a reference of [[ColumnSeries]] the categories will be sorted\r\n\t * by actual values.\r\n\t *\r\n\t * The categories are ordered in descending order (from highest values to\r\n\t * lowest). To reverse the order, use axis renderer's `inversed` setting.\r\n\t * E.g.:\r\n\t *\r\n\t * ```TypeScript\r\n\t * categoryAxis.sortBySeries = series;\r\n\t * categoryAxis.renderer.inversed = true;\r\n\t * ```\r\n\t * ```JavaScript\r\n\t * categoryAxis.sortBySeries = series;\r\n\t * categoryAxis.renderer.inversed = true;\r\n\t * ```\r\n\t * ```JSON\r\n\t * {\r\n\t *   // ...\r\n\t *   \"xAxes\": [{\r\n\t *     // ...\r\n\t *     \"sortBySeries\": \"s1\",\r\n\t *     \"renderer\": {\r\n\t *       // ...\r\n\t *       \"inversed\": true\r\n\t *     }\r\n\t *   }]\r\n\t * }\r\n\t * ```\r\n\t *\r\n\t * @since 4.8.7\r\n\t * @param  value  Sort categories?\r\n\t */\r\n\tpublic set sortBySeries(value: ColumnSeries) {\r\n\t\tthis.setPropertyValue(\"sortBySeries\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Sort categories?\r\n\t */\r\n\tpublic get sortBySeries(): ColumnSeries {\r\n\t\treturn this.getPropertyValue(\"sortBySeries\");\r\n\t}\r\n\r\n\t/**\r\n\t * Processes JSON-based config before it is applied to the object.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param config  Config\r\n\t */\r\n\tpublic processConfig(config?: { [index: string]: any }): void {\r\n\r\n\t\tif (config) {\r\n\r\n\t\t\tif ($type.hasValue(config.sortBySeries) && $type.isString(config.sortBySeries)) {\r\n\t\t\t\tif (this.map.hasKey(config.sortBySeries)) {\r\n\t\t\t\t\tconfig.sortBySeries = this.map.getKey(config.sortBySeries);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthis.addDelayedMap(\"sortBySeries\", config.sortBySeries);\r\n\t\t\t\t\tdelete config.sortBySeries;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tsuper.processConfig(config);\r\n\r\n\t}\r\n}\r\n\r\n/**\r\n * Register class, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"CategoryAxis\"] = CategoryAxis;\r\nregistry.registeredClasses[\"CategoryAxisDataItem\"] = CategoryAxisDataItem;\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}