{"ast":null,"code":"/**\r\n * Animation module.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\nimport { BaseObjectEvents } from \"../Base\";\nimport { SVGDefaults } from \"../defs/SVGDefaults\";\nimport { Disposer } from \"../utils/Disposer\";\nimport { Color } from \"../utils/Color\";\nimport { Percent, percent } from \"../utils/Percent\";\nimport * as $async from \"../utils/AsyncPending\";\nimport * as $ease from \"../utils/Ease\";\nimport * as $colors from \"../utils/Colors\";\nimport * as $math from \"../utils/Math\";\nimport * as $array from \"../utils/Array\";\nimport * as $type from \"../utils/Type\";\nimport { system } from \"../System\";\nimport { options } from \"../Options\";\n/**\r\n * Calls a `callback` function for the `duration` of milliseconds.\r\n *\r\n * @todo Needed?\r\n * @deprecated Not used anywhere\r\n * @ignore Exclude from docs\r\n * @param duration  Duration (ms)\r\n * @param callback  Callback function\r\n * @return Disposer\r\n */\nexport function animate(duration, callback) {\n  var disposed = false;\n  // TODO use performance.now() ?\n  var startTime = Date.now();\n  function loop(now) {\n    if (!disposed) {\n      var diff = now - startTime;\n      if (diff >= duration) {\n        callback(1);\n      } else {\n        $async.nextFrame(loop);\n        callback(diff / duration);\n      }\n    }\n  }\n  $async.nextFrame(loop);\n  return new Disposer(function () {\n    disposed = true;\n  });\n}\n/**\r\n * Returns numeric value accoring to progress between start and end values.\r\n *\r\n * @param progress  Progress (0-1)\r\n * @param from\r\n * @param to\r\n * @return Value according to progress\r\n */\nfunction getProgressNumber(progress, from, to) {\n  return from + (to - from) * progress;\n}\n/**\r\n * Returns [[Percent]] value accoring to progress between start and end\r\n * values.\r\n *\r\n * @param progress  Progress (0-1)\r\n * @param from\r\n * @param to\r\n * @return Value according to progress\r\n */\nfunction getProgressPercent(progress, from, to) {\n  return new Percent(getProgressNumber(progress, from.percent, to.percent));\n}\n/**\r\n * Returns color value accoring to progress between start and end values.\r\n *\r\n * @param progress  Progress (0-1)\r\n * @param from\r\n * @param to\r\n * @return Color according to progress\r\n */\nfunction getProgressColor(progress, from, to) {\n  var color = new Color($colors.interpolate(from.rgb, to.rgb, progress));\n  if (from.alpha != to.alpha) {\n    color.alpha = from.alpha + (to.alpha - from.alpha) * progress;\n  }\n  return color;\n}\n/**\r\n * [getHybridProperty description]\r\n *\r\n * @todo Description\r\n * @param property [description]\r\n * @param type [description]\r\n * @return [description]\r\n */\nfunction getHybridProperty(property, type) {\n  return type + property.charAt(0).toUpperCase() + property.substr(1);\n}\nvar AnimationDisposer = /** @class */function () {\n  function AnimationDisposer(array) {\n    this._disposer = new Disposer(function () {\n      while (array.length !== 0) {\n        array[0].dispose();\n      }\n    });\n  }\n  AnimationDisposer.prototype.isDisposed = function () {\n    return this._disposer.isDisposed();\n  };\n  AnimationDisposer.prototype.dispose = function () {\n    this._disposer.dispose();\n  };\n  return AnimationDisposer;\n}();\nexport { AnimationDisposer };\n/**\r\n * Animation can be used to transition certain properties on an object that\r\n * implements [[IAnimatable]] interface.\r\n *\r\n * @see {@link IAnimationEvents} for a list of available events\r\n */\nvar Animation = /** @class */function (_super) {\n  __extends(Animation, _super);\n  /**\r\n   * Constructor\r\n   *\r\n   * @param object            An object animation should run on\r\n   * @param animationOptions  One or several (array) of animation options\r\n   * @param duration          Duration (ms)\r\n   * @param easing            Easing function\r\n   */\n  function Animation(object, animationOptions, duration, easing) {\n    var _this =\n    // Init\n    _super.call(this) || this;\n    /**\r\n     * Duration of the animation in milliseconds.\r\n     */\n    _this.duration = 0;\n    /**\r\n     * Easing function to use.\r\n     *\r\n     * @see {@link Ease}\r\n     */\n    _this.easing = $ease.linear;\n    /**\r\n     * Contains progress of the current animation: 0 (start) to 1 (end).\r\n     */\n    _this.progress = 0;\n    /**\r\n     * Indicated how many times animation should loop.\r\n     */\n    _this._loop = 0;\n    /**\r\n     * Animation is paused.\r\n     */\n    _this._pause = false;\n    /**\r\n     * Holds reference to timeout for delayed play.\r\n     */\n    _this._delayTimeout = null;\n    /**\r\n     * Elapsed time in currently playing animation.\r\n     */\n    _this._time = 0;\n    _this._isFinished = false;\n    _this.className = \"Animation\";\n    // Override duration if animations disabled system-wide\n    if (options.animationsEnabled === false) {\n      duration = 0;\n    }\n    // Set parameters\n    _this.object = object;\n    _this.animationOptions = $array.toArray(animationOptions);\n    _this.duration = duration;\n    if (easing) {\n      _this.easing = easing;\n    }\n    // Run check if there are already animations playing on the same properties\n    // and stop them - the last animation takes precedence\n    //this.stopSameAnimations();\n    /*if ($type.hasValue(callback)) {\r\n        // TODO don't use .call\r\n        this.events.on(\"animationended\", callback, object);\r\n    }*/\n    // Apply theme\n    _this.applyTheme();\n    return _this;\n  }\n  // TODO verify that this is correct\n  Animation.prototype.debug = function () {};\n  /**\r\n   * Disposes this object, clears up after itself.\r\n   */\n  Animation.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n    this.pause();\n  };\n  /**\r\n   * Delays animation start by X milliseconds.\r\n   *\r\n   * @param delay  Delay (ms)\r\n   * @return Animation\r\n   */\n  Animation.prototype.delay = function (delay) {\n    var _this = this;\n    //@todo Maybe not use `bind()`\n    if (delay > 0) {\n      this.pause();\n      // This is so that it will get disposed if `this.object` is disposed\n      // TODO hacky, figure out a better way\n      $array.move(this.object.animations, this);\n      var id_1 = setTimeout(function () {\n        _this._delayTimeout = null;\n        _this.start();\n      }, delay);\n      this._delayTimeout = new Disposer(function () {\n        clearTimeout(id_1);\n      });\n    }\n    return this;\n  };\n  Animation.prototype._start = function () {\n    this._isFinished = false;\n    // Clear delay timeout if there was one\n    if (this._delayTimeout) {\n      this.removeDispose(this._delayTimeout);\n      this._delayTimeout = null;\n    }\n    // Run check if there are already animations playing on the same properties\n    // and stop them - the last animation takes precedence\n    this.stopSameAnimations();\n    // Reset counters\n    this._pause = false;\n    // Register animation\n    $array.move(system.animations, this);\n    // Register this animation in object's `animations` list\n    $array.move(this.object.animations, this);\n    system.requestFrame();\n  };\n  /**\r\n   * Starts animation.\r\n   *\r\n   * @return Animation\r\n   */\n  Animation.prototype.start = function () {\n    this._start();\n    this._startTime = Date.now();\n    this._time = 0;\n    this.staticOptions = [];\n    // Process initial property values\n    for (var i = this.animationOptions.length - 1; i >= 0; i--) {\n      var options_1 = this.animationOptions[i];\n      if (!$type.hasValue(options_1.from)) {\n        if (options_1.childObject) {\n          options_1.from = options_1.childObject[options_1.property];\n        } else {\n          options_1.from = this.object[options_1.property];\n          if (!$type.hasValue(options_1.from)) {\n            options_1.from = SVGDefaults[options_1.property];\n          }\n        }\n        /*if (!$type.hasValue(options.from)) {\r\n            throw Error(\"Could not get initial transition value.\");\r\n        }*/\n      }\n\n      if (options_1.from == options_1.to) {\n        // || options.to == (<any>this.object)[options.property]){ this is not good, as dataItem.value is set to final at once, and we animate workingValue\n        $array.remove(this.animationOptions, options_1);\n      } else if (!$type.hasValue(options_1.from) || !(options_1.from instanceof Percent) && options_1.to instanceof Percent || options_1.from instanceof Percent && !(options_1.to instanceof Percent)) {\n        // Initial value is undefined, treat it as static\n        this.staticOptions.push(options_1);\n        $array.remove(this.animationOptions, options_1);\n      } else {\n        // Use different update methods for different value types\n        if ($type.isNumber(options_1.to)) {\n          // Numeric value\n          options_1.updateMethod = getProgressNumber;\n          // Check if initial value is not Percent\n          if (options_1.from instanceof Percent) {\n            // It is. Let's convert it to pixel value\n            // @todo Check if we can do this in a less hacky way\n            var convertedFrom = this.object[getHybridProperty(options_1.property, \"pixel\")];\n            if (!isNaN(convertedFrom)) {\n              options_1.from = convertedFrom;\n            } else {\n              this.staticOptions.push(options_1);\n              $array.remove(this.animationOptions, options_1);\n            }\n          } else if (isNaN(options_1.from)) {\n            // Static value\n            this.staticOptions.push(options_1);\n            $array.remove(this.animationOptions, options_1);\n          }\n        } else {\n          // Check if maybe we have a color or percent value\n          if (options_1.to instanceof Color) {\n            // Yup - set resolved named color\n            //options.from = $colors.stringToColor(<string>options.from);\n            if (options_1.from) {\n              options_1.updateMethod = getProgressColor;\n            } else {\n              // Static value\n              this.staticOptions.push(options_1);\n              $array.remove(this.animationOptions, options_1);\n            }\n          } else if (options_1.to instanceof Percent) {\n            // Percent\n            options_1.updateMethod = getProgressPercent;\n            // Check if the initial value is maybe in pixels\n            if (!isNaN(options_1.from)) {\n              // It is. Let's convert it\n              // @todo Check if we can do this in a less hacky way\n              var convertedFrom = this.object[getHybridProperty(options_1.property, \"relative\")];\n              if (!isNaN(convertedFrom)) {\n                options_1.from = percent(convertedFrom * 100);\n              }\n            }\n          } else {\n            // Static value\n            this.staticOptions.push(options_1);\n            $array.remove(this.animationOptions, options_1);\n          }\n        }\n      }\n    }\n    // Apply static options (just in case they were reset by previous\n    // animation loop)\n    this.applyStaticOptions();\n    if (this.events.isEnabled(\"animationstarted\")) {\n      var event_1 = {\n        type: \"animationstarted\",\n        target: this,\n        progress: this.progress\n      };\n      this.events.dispatchImmediately(\"animationstarted\", event_1);\n    }\n    this.update();\n    // If duration is 0, just end animation\n    if (this.duration === 0) {\n      this.end();\n    }\n    return this;\n  };\n  /**\r\n   * Sets loop count for the animation. If parameter is not a valid number the\r\n   * animation will keep on looping indefinitely.\r\n   *\r\n   * @param count  Number of times to loop animation\r\n   * @return Animation\r\n   */\n  Animation.prototype.loop = function (count) {\n    if (!$type.isNumber(count)) {\n      count = Infinity;\n    }\n    this._loop = count;\n    return this;\n  };\n  /**\r\n   * Pauses animation.\r\n   *\r\n   * @return Animation\r\n   */\n  Animation.prototype.pause = function () {\n    this._pause = true;\n    if (this._delayTimeout) {\n      this.removeDispose(this._delayTimeout);\n      this._delayTimeout = null;\n    }\n    $array.remove(system.animations, this);\n    $array.remove(this.object.animations, this);\n    return this;\n  };\n  /**\r\n   * Resumes paused animation.\r\n   *\r\n   * @return Animation\r\n   */\n  Animation.prototype.resume = function () {\n    this._start();\n    this._startTime = Date.now() - this._time;\n    return this;\n  };\n  /**\r\n   * Jumps to animation end. If animation is set to loop, this will start\r\n   * another round of animation from start.\r\n   *\r\n   * @return Animation\r\n   */\n  Animation.prototype.end = function () {\n    // Pause and complete the progress\n    if (this._loop == 0) {\n      this.pause();\n    }\n    this.setProgress(1);\n    // Apply static options\n    this.applyStaticOptions();\n    if (this.events.isEnabled(\"animationended\")) {\n      var event_2 = {\n        type: \"animationended\",\n        target: this,\n        progress: this.progress\n      };\n      this.events.dispatchImmediately(\"animationended\", event_2);\n    }\n    // Check if we should loop\n    if (this._loop > 0) {\n      this._loop--;\n      this.start();\n    } else {\n      this.stop();\n      this._isFinished = true;\n    }\n    return this;\n  };\n  /**\r\n   * Stops animation immediately leaving properties in their current values.\r\n   */\n  Animation.prototype.kill = function () {\n    this.pause();\n    this._isFinished = true;\n  };\n  /**\r\n   * Returns indicator if this animation is finished or not\r\n   *\r\n   * @return Is finished?\r\n   */\n  Animation.prototype.isFinished = function () {\n    return this._isFinished;\n  };\n  /**\r\n   * Applies static options that can't be animated.\r\n   */\n  Animation.prototype.applyStaticOptions = function () {\n    var _this = this;\n    $array.each(this.staticOptions, function (options) {\n      if (options.childObject) {\n        options.childObject[options.property] = _this.progress == 1 ? options.to : options.from;\n      } else {\n        _this.object[options.property] = _this.progress == 1 ? options.to : options.from;\n      }\n    });\n  };\n  /**\r\n   * Stops animation.\r\n   *\r\n   * When animation is stopped, the properties of the target object will remain\r\n   * where they were at the moment when `stop()` was called.\r\n   *\r\n   * @param skipEvent  Do not trigger `animationstopped` event\r\n   * @return Animation\r\n   */\n  Animation.prototype.stop = function (skipEvent) {\n    this.pause();\n    if (!skipEvent) {\n      if (this.events.isEnabled(\"animationstopped\")) {\n        var event_3 = {\n          type: \"animationstopped\",\n          target: this,\n          progress: this.progress\n        };\n        this.events.dispatchImmediately(\"animationstopped\", event_3);\n      }\n    }\n    return this;\n  };\n  /**\r\n   * Sets current progress and updates object's numeric and color values.\r\n   *\r\n   * @param progress Progress (0-1)\r\n   */\n  Animation.prototype.setProgress = function (progress) {\n    var _this = this;\n    this._time = this.duration * progress; // just in case we call this from outside\n    $array.each(this.animationOptions, function (options) {\n      if (options.updateMethod && $type.hasValue(options.from)) {\n        var value = options.updateMethod(progress, options.from, options.to);\n        if (options.childObject) {\n          options.childObject[options.property] = value;\n        } else {\n          _this.object[options.property] = value;\n        }\n      }\n    });\n    this.progress = progress;\n    if (this.events.isEnabled(\"animationprogress\")) {\n      var event_4 = {\n        type: \"animationprogress\",\n        target: this,\n        progress: this.progress\n      };\n      this.events.dispatchImmediately(\"animationprogress\", event_4);\n    }\n    system.requestFrame();\n  };\n  /**\r\n   * Tracks and sets progress according to time or frames.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @return Animation\r\n   */\n  Animation.prototype.update = function () {\n    if (!this._pause) {\n      var progress = void 0;\n      this._time = $math.fitToRange(Date.now() - this._startTime, 0, this.duration);\n      var timeProgress = this._time / this.duration;\n      progress = this.easing(timeProgress);\n      if (this.duration == 0 || !$type.isNumber(progress) || timeProgress >= 1) {\n        progress = 1;\n      }\n      this.setProgress(progress);\n      if ($math.round(this._time / this.duration, 6) == 1) {\n        this.end();\n      }\n    }\n    return this;\n  };\n  Object.defineProperty(Animation.prototype, \"delayed\", {\n    /**\r\n     * Returns `true` if this animation is delayed.\r\n     *\r\n     * @readonly\r\n     * @return [description]\r\n     */\n    get: function () {\n      return this._delayTimeout ? true : false;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Checks other animations currently running on the same object and removes\r\n   * overlapping options from those other animations that are contained in\r\n   * this animation.\r\n   *\r\n   * This is needed to ensure that no two confurent animations step on each\r\n   * other's toes by trying to animate the same property.\r\n   */\n  Animation.prototype.stopSameAnimations = function () {\n    var _this = this;\n    // stop animation of the same property\n    // TODO make this more efficient\n    // TODO don't copy the array\n    $array.each($array.copy(this.object.animations), function (animation) {\n      if (animation !== _this && !animation.delayed) {\n        var killed_1 = [];\n        $array.each(_this.animationOptions, function (newOptions) {\n          $array.each(animation.animationOptions, function (oldOptions) {\n            if (newOptions.property == oldOptions.property && newOptions.childObject == oldOptions.childObject) {\n              killed_1.push(oldOptions);\n              if (animation.animationOptions.length == 0) {\n                animation.kill();\n              }\n            }\n          });\n        });\n        $array.each(killed_1, function (oldOptions) {\n          $array.remove(animation.animationOptions, oldOptions);\n        });\n      }\n    });\n  };\n  /**\r\n   * Adds easing functions to \"function\" fields.\r\n   *\r\n   * @param field  Field name\r\n   * @return Assign as function?\r\n   */\n  Animation.prototype.asFunction = function (field) {\n    return field == \"easing\" || _super.prototype.asIs.call(this, field);\n  };\n  return Animation;\n}(BaseObjectEvents);\nexport { Animation };","map":{"version":3,"mappings":"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","names":["BaseObjectEvents","SVGDefaults","Disposer","Color","Percent","percent","$async","$ease","$colors","$math","$array","$type","system","options","animate","duration","callback","disposed","startTime","Date","now","loop","diff","nextFrame","getProgressNumber","progress","from","to","getProgressPercent","getProgressColor","color","interpolate","rgb","alpha","getHybridProperty","property","type","charAt","toUpperCase","substr","array","_disposer","length","dispose","AnimationDisposer","isDisposed","__extends","object","animationOptions","easing","_super","_this","linear","className","animationsEnabled","toArray","applyTheme","Animation","pause","delay","move","animations","id_1","setTimeout","_delayTimeout","start","clearTimeout","_isFinished","removeDispose","stopSameAnimations","_pause","requestFrame","_start","_startTime","_time","staticOptions","i","options_1","hasValue","childObject","remove","push","isNumber","updateMethod","convertedFrom","isNaN","applyStaticOptions","events","isEnabled","event_1","target","dispatchImmediately","update","end","count","Infinity","_loop","setProgress","event_2","stop","each","skipEvent","event_3","value","event_4","fitToRange","timeProgress","round","Object","copy","animation","delayed","killed_1","newOptions","oldOptions","kill","field","asIs"],"sources":["C:\\Users\\Lucian\\Documents\\DEV\\nodejs\\stock-market-api\\dev\\static\\node_modules\\src\\.internal\\core\\utils\\Animation.ts"],"sourcesContent":["/**\r\n * Animation module.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { BaseObjectEvents, IBaseObjectEvents } from \"../Base\";\r\nimport { AMEvent } from \"../utils/EventDispatcher\";\r\nimport { SVGDefaults } from \"../defs/SVGDefaults\";\r\nimport { Disposer, IDisposer } from \"../utils/Disposer\";\r\nimport { Color } from \"../utils/Color\";\r\nimport { Percent, percent } from \"../utils/Percent\";\r\nimport * as $async from \"../utils/AsyncPending\";\r\nimport * as $ease from \"../utils/Ease\";\r\nimport * as $colors from \"../utils/Colors\";\r\nimport * as $math from \"../utils/Math\";\r\nimport * as $array from \"../utils/Array\";\r\nimport * as $type from \"../utils/Type\";\r\nimport { system } from \"../System\";\r\nimport { options } from \"../Options\";\r\n\r\n\r\n/**\r\n * Defines interface for animation objects.\r\n *\r\n * Should at least contain `update()` method.\r\n */\r\nexport interface IAnimationObject {\r\n\tupdate: () => void\r\n}\r\n\r\n/**\r\n * Defines interface for objects that can be animated\r\n */\r\nexport interface IAnimatable {\r\n\tanimations: Array<Animation>;\r\n}\r\n\r\n\r\nexport type IAnimationOption = Color | Percent | number | string | boolean;\r\n\r\n/**\r\n * Defines interface for animation options.\r\n */\r\nexport interface IAnimationOptions {\r\n\r\n\t/**\r\n\t * An initial value to animate from.\r\n\t *\r\n\t * If omitted, the source value will be current value.\r\n\t */\r\n\tfrom?: IAnimationOption;\r\n\r\n\t/**\r\n\t * A target value to animate from.\r\n\t */\r\n\tto: IAnimationOption;\r\n\r\n\t/**\r\n\t * Property name to animate.\r\n\t */\r\n\tproperty?: any;\r\n\r\n\t/**\r\n\t * If current values should be taken from different object than the target\r\n\t * element of the animation, this property should be set to that object.\r\n\t */\r\n\tchildObject?: { [index: string]: any };\r\n\r\n\t/**\r\n\t * A method/function reference that will be called to for updating the\r\n\t * property value.\r\n\t */\r\n\tupdateMethod?(progress: number, from: IAnimationOption, to: IAnimationOption): IAnimationOption;\r\n\r\n\r\n\t/**\r\n\t * sometimes we need to pass some dummy data in animationOptions\r\n\t */\r\n\tdummyData?: any;\r\n\r\n}\r\n\r\n/**\r\n * An interface for an object defining [[Percent]] animation.\r\n */\r\nexport interface IPercentAnimationOptions extends IAnimationOptions {\r\n\r\n\t/**\r\n\t * Initial value.\r\n\t */\r\n\tfrom?: Percent;\r\n\r\n\t/**\r\n\t * Target value.\r\n\t */\r\n\tto: Percent;\r\n\r\n}\r\n\r\n/**\r\n * An interface for an object defining [[Color]] animation.\r\n */\r\nexport interface IColorAnimationOptions extends IAnimationOptions {\r\n\r\n\t/**\r\n\t * Initial value.\r\n\t */\r\n\tfrom?: Color;\r\n\r\n\t/**\r\n\t * Target value.\r\n\t */\r\n\tto: Color;\r\n\r\n}\r\n\r\n\r\n/**\r\n * Calls a `callback` function for the `duration` of milliseconds.\r\n *\r\n * @todo Needed?\r\n * @deprecated Not used anywhere\r\n * @ignore Exclude from docs\r\n * @param duration  Duration (ms)\r\n * @param callback  Callback function\r\n * @return Disposer\r\n */\r\nexport function animate(duration: number, callback: (time: number) => void): IDisposer {\r\n\tlet disposed = false;\r\n\r\n\t// TODO use performance.now() ?\r\n\tconst startTime = Date.now();\r\n\r\n\tfunction loop(now: number): void {\r\n\t\tif (!disposed) {\r\n\t\t\tconst diff = now - startTime;\r\n\r\n\t\t\tif (diff >= duration) {\r\n\t\t\t\tcallback(1);\r\n\r\n\t\t\t} else {\r\n\t\t\t\t$async.nextFrame(loop);\r\n\t\t\t\tcallback(diff / duration);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t$async.nextFrame(loop);\r\n\r\n\treturn new Disposer(() => {\r\n\t\tdisposed = true;\r\n\t});\r\n}\r\n\r\n\r\n/**\r\n * Defines events for [[Animation]].\r\n */\r\nexport interface IAnimationEvents extends IBaseObjectEvents {\r\n\r\n\t/**\r\n\t * Invoked when animation starts playing.\r\n\t */\r\n\tanimationstarted: {\r\n\t\tprogress: number;\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when animation finishes playing.\r\n\t */\r\n\tanimationended: {\r\n\t\tprogress: number;\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when animation makes progress.\r\n\t */\r\n\tanimationprogress: {\r\n\t\tprogress: number;\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when animation is stopped by some other process, before it had\r\n\t * a chance to finish.\r\n\t */\r\n\tanimationstopped: {\r\n\t\tprogress: number;\r\n\t};\r\n\r\n}\r\n\r\n\r\n/**\r\n * Returns numeric value accoring to progress between start and end values.\r\n *\r\n * @param progress  Progress (0-1)\r\n * @param from\r\n * @param to\r\n * @return Value according to progress\r\n */\r\nfunction getProgressNumber(progress: number, from: number, to: number): number {\r\n\treturn from + ((to - from) * progress);\r\n}\r\n\r\n/**\r\n * Returns [[Percent]] value accoring to progress between start and end\r\n * values.\r\n *\r\n * @param progress  Progress (0-1)\r\n * @param from\r\n * @param to\r\n * @return Value according to progress\r\n */\r\nfunction getProgressPercent(progress: number, from: Percent, to: Percent): Percent {\r\n\treturn new Percent(getProgressNumber(progress, from.percent, to.percent));\r\n}\r\n\r\n/**\r\n * Returns color value accoring to progress between start and end values.\r\n *\r\n * @param progress  Progress (0-1)\r\n * @param from\r\n * @param to\r\n * @return Color according to progress\r\n */\r\nfunction getProgressColor(progress: number, from: Color, to: Color): Color {\r\n\tconst color = new Color($colors.interpolate(from.rgb, to.rgb, progress));\r\n\tif (from.alpha != to.alpha) {\r\n\t\tcolor.alpha = from.alpha + (to.alpha - from.alpha) * progress;\r\n\t}\r\n\treturn color;\r\n}\r\n\r\n/**\r\n * [getHybridProperty description]\r\n *\r\n * @todo Description\r\n * @param property [description]\r\n * @param type [description]\r\n * @return [description]\r\n */\r\nfunction getHybridProperty(property: string, type: \"pixel\" | \"relative\"): string {\r\n\treturn type + property.charAt(0).toUpperCase() + property.substr(1);\r\n}\r\n\r\n\r\nexport class AnimationDisposer implements IDisposer {\r\n\tprivate _disposer: Disposer;\r\n\r\n\tconstructor(array: Array<Animation>) {\r\n\t\tthis._disposer = new Disposer(() => {\r\n\t\t\twhile (array.length !== 0) {\r\n\t\t\t\tarray[0].dispose();\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tisDisposed(): boolean {\r\n\t\treturn this._disposer.isDisposed();\r\n\t}\r\n\r\n\tdispose(): void {\r\n\t\tthis._disposer.dispose();\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * Animation can be used to transition certain properties on an object that\r\n * implements [[IAnimatable]] interface.\r\n *\r\n * @see {@link IAnimationEvents} for a list of available events\r\n */\r\nexport class Animation extends BaseObjectEvents implements IAnimationObject {\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: IAnimationEvents;\r\n\r\n\t/**\r\n\t * An animation target object. [[Animation]] will update properties of\r\n\t * this object.\r\n\t */\r\n\tpublic object: IAnimatable;\r\n\r\n\t/**\r\n\t * An array of animation option objects. Each animation object represent\r\n\t * one property. Animation can animate any number of properties\r\n\t * simultaneously.\r\n\t */\r\n\tpublic animationOptions: IAnimationOptions[];\r\n\r\n\t/**\r\n\t * Duration of the animation in milliseconds.\r\n\t */\r\n\tpublic duration: number = 0;\r\n\r\n\t/**\r\n\t * Easing function to use.\r\n\t *\r\n\t * @see {@link Ease}\r\n\t */\r\n\tpublic easing: (value: number) => number = $ease.linear;\r\n\r\n\t/**\r\n\t * Contains progress of the current animation: 0 (start) to 1 (end).\r\n\t */\r\n\tpublic progress: number = 0;\r\n\r\n\t/**\r\n\t * A list of options that cannot be animated. Those will be applied when\r\n\t * Animation ends.\r\n\t */\r\n\tprotected staticOptions!: IAnimationOptions[];\r\n\r\n\t/**\r\n\t * Indicated how many times animation should loop.\r\n\t */\r\n\tprotected _loop: number = 0;\r\n\r\n\t/**\r\n\t * Animation is paused.\r\n\t */\r\n\tprotected _pause: boolean = false;\r\n\r\n\t/**\r\n\t * Holds reference to timeout for delayed play.\r\n\t */\r\n\tprotected _delayTimeout: IDisposer | null = null;\r\n\r\n\t/**\r\n\t * A timestamp of when animation started playing.\r\n\t */\r\n\tprotected _startTime: $type.Optional<number>;\r\n\r\n\t/**\r\n\t * Elapsed time in currently playing animation.\r\n\t */\r\n\tprotected _time: number = 0;\r\n\r\n\t// TODO verify that this is correct\r\n\tprotected debug(): void { }\r\n\r\n\tprotected _isFinished: boolean = false;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t *\r\n\t * @param object            An object animation should run on\r\n\t * @param animationOptions  One or several (array) of animation options\r\n\t * @param duration          Duration (ms)\r\n\t * @param easing            Easing function\r\n\t */\r\n\tconstructor(object: IAnimatable, animationOptions: IAnimationOptions[] | IAnimationOptions, duration: number, easing?: (value: number) => number) {\r\n\r\n\t\t// Init\r\n\t\tsuper();\r\n\t\tthis.className = \"Animation\";\r\n\r\n\t\t// Override duration if animations disabled system-wide\r\n\t\tif (options.animationsEnabled === false) {\r\n\t\t\tduration = 0;\r\n\t\t}\r\n\r\n\t\t// Set parameters\r\n\t\tthis.object = object;\r\n\t\tthis.animationOptions = $array.toArray(animationOptions);\r\n\t\tthis.duration = duration;\r\n\t\tif (easing) {\r\n\t\t\tthis.easing = easing;\r\n\t\t}\r\n\r\n\t\t// Run check if there are already animations playing on the same properties\r\n\t\t// and stop them - the last animation takes precedence\r\n\t\t//this.stopSameAnimations();\r\n\r\n\t\t/*if ($type.hasValue(callback)) {\r\n\t\t\t// TODO don't use .call\r\n\t\t\tthis.events.on(\"animationended\", callback, object);\r\n\t\t}*/\r\n\r\n\t\t// Apply theme\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * Disposes this object, clears up after itself.\r\n\t */\r\n\tpublic dispose(): void {\r\n\t\tsuper.dispose();\r\n\t\tthis.pause();\r\n\t}\r\n\r\n\t/**\r\n\t * Delays animation start by X milliseconds.\r\n\t *\r\n\t * @param delay  Delay (ms)\r\n\t * @return Animation\r\n\t */\r\n\tpublic delay(delay: number): Animation {\r\n\t\t//@todo Maybe not use `bind()`\r\n\t\tif (delay > 0) {\r\n\t\t\tthis.pause();\r\n\r\n\t\t\t// This is so that it will get disposed if `this.object` is disposed\r\n\t\t\t// TODO hacky, figure out a better way\r\n\t\t\t$array.move(this.object.animations, this);\r\n\r\n\t\t\tlet id = setTimeout(() => {\r\n\t\t\t\tthis._delayTimeout = null;\r\n\t\t\t\tthis.start();\r\n\t\t\t}, delay);\r\n\r\n\t\t\tthis._delayTimeout = new Disposer(() => {\r\n\t\t\t\tclearTimeout(id);\r\n\t\t\t});\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\r\n\tprivate _start() {\r\n\t\tthis._isFinished = false;\r\n\t\t// Clear delay timeout if there was one\r\n\t\tif (this._delayTimeout) {\r\n\t\t\tthis.removeDispose(this._delayTimeout);\r\n\t\t\tthis._delayTimeout = null;\r\n\t\t}\r\n\r\n\t\t// Run check if there are already animations playing on the same properties\r\n\t\t// and stop them - the last animation takes precedence\r\n\t\tthis.stopSameAnimations();\r\n\r\n\t\t// Reset counters\r\n\t\tthis._pause = false;\r\n\r\n\t\t// Register animation\r\n\t\t$array.move(system.animations, this);\r\n\r\n\t\t// Register this animation in object's `animations` list\r\n\t\t$array.move(this.object.animations, this);\r\n\r\n\t\tsystem.requestFrame();\r\n\t}\r\n\r\n\t/**\r\n\t * Starts animation.\r\n\t *\r\n\t * @return Animation\r\n\t */\r\n\tpublic start(): Animation {\r\n\t\tthis._start();\r\n\t\tthis._startTime = Date.now();\r\n\t\tthis._time = 0;\r\n\t\tthis.staticOptions = [];\r\n\r\n\t\t// Process initial property values\r\n\t\tfor (let i: number = this.animationOptions.length - 1; i >= 0; i--) {\r\n\t\t\tlet options: IAnimationOptions = this.animationOptions[i];\r\n\t\t\tif (!$type.hasValue(options.from)) {\r\n\t\t\t\tif (options.childObject) {\r\n\t\t\t\t\toptions.from = options.childObject[options.property];\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\toptions.from = (<any>this.object)[options.property];\r\n\r\n\t\t\t\t\tif (!$type.hasValue(options.from)) {\r\n\t\t\t\t\t\toptions.from = (<any>SVGDefaults)[options.property];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/*if (!$type.hasValue(options.from)) {\r\n\t\t\t\t\tthrow Error(\"Could not get initial transition value.\");\r\n\t\t\t\t}*/\r\n\t\t\t}\r\n\r\n\t\t\tif (options.from == options.to) { // || options.to == (<any>this.object)[options.property]){ this is not good, as dataItem.value is set to final at once, and we animate workingValue\r\n\t\t\t\t$array.remove(this.animationOptions, options);\r\n\t\t\t}\r\n\t\t\telse if (!$type.hasValue(options.from) || (!(options.from instanceof Percent) && (options.to instanceof Percent)) || ((options.from instanceof Percent) && !(options.to instanceof Percent))) {\r\n\t\t\t\t// Initial value is undefined, treat it as static\r\n\t\t\t\tthis.staticOptions.push(options);\r\n\t\t\t\t$array.remove(this.animationOptions, options);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Use different update methods for different value types\r\n\t\t\t\tif ($type.isNumber(<number>options.to)) {\r\n\r\n\t\t\t\t\t// Numeric value\r\n\t\t\t\t\toptions.updateMethod = getProgressNumber;\r\n\r\n\t\t\t\t\t// Check if initial value is not Percent\r\n\t\t\t\t\tif (options.from instanceof Percent) {\r\n\t\t\t\t\t\t// It is. Let's convert it to pixel value\r\n\t\t\t\t\t\t// @todo Check if we can do this in a less hacky way\r\n\t\t\t\t\t\tlet convertedFrom: number = (<any>this.object)[getHybridProperty(options.property, \"pixel\")];\r\n\t\t\t\t\t\tif (!isNaN(convertedFrom)) {\r\n\t\t\t\t\t\t\toptions.from = convertedFrom;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tthis.staticOptions.push(options);\r\n\t\t\t\t\t\t\t$array.remove(this.animationOptions, options);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (isNaN(<number>options.from)) {\r\n\t\t\t\t\t\t// Static value\r\n\t\t\t\t\t\tthis.staticOptions.push(options);\r\n\t\t\t\t\t\t$array.remove(this.animationOptions, options);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t// Check if maybe we have a color or percent value\r\n\t\t\t\t\tif (options.to instanceof Color) {\r\n\t\t\t\t\t\t// Yup - set resolved named color\r\n\t\t\t\t\t\t//options.from = $colors.stringToColor(<string>options.from);\r\n\t\t\t\t\t\tif (options.from) {\r\n\t\t\t\t\t\t\toptions.updateMethod = getProgressColor;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t// Static value\r\n\t\t\t\t\t\t\tthis.staticOptions.push(options);\r\n\t\t\t\t\t\t\t$array.remove(this.animationOptions, options);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (options.to instanceof Percent) {\r\n\t\t\t\t\t\t// Percent\r\n\t\t\t\t\t\toptions.updateMethod = getProgressPercent;\r\n\r\n\t\t\t\t\t\t// Check if the initial value is maybe in pixels\r\n\t\t\t\t\t\tif (!isNaN(<number>options.from)) {\r\n\t\t\t\t\t\t\t// It is. Let's convert it\r\n\t\t\t\t\t\t\t// @todo Check if we can do this in a less hacky way\r\n\t\t\t\t\t\t\tlet convertedFrom: number = (<any>this.object)[getHybridProperty(options.property, \"relative\")];\r\n\t\t\t\t\t\t\tif (!isNaN(convertedFrom)) {\r\n\t\t\t\t\t\t\t\toptions.from = percent(convertedFrom * 100);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\t// Static value\r\n\t\t\t\t\t\tthis.staticOptions.push(options);\r\n\t\t\t\t\t\t$array.remove(this.animationOptions, options);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Apply static options (just in case they were reset by previous\r\n\t\t// animation loop)\r\n\t\tthis.applyStaticOptions();\r\n\r\n\t\tif (this.events.isEnabled(\"animationstarted\")) {\r\n\t\t\tconst event: AMEvent<this, IAnimationEvents>[\"animationstarted\"] = {\r\n\t\t\t\ttype: \"animationstarted\",\r\n\t\t\t\ttarget: this,\r\n\t\t\t\tprogress: this.progress\r\n\t\t\t};\r\n\t\t\tthis.events.dispatchImmediately(\"animationstarted\", event);\r\n\t\t}\r\n\r\n\t\tthis.update();\r\n\r\n\t\t// If duration is 0, just end animation\r\n\t\tif (this.duration === 0) {\r\n\t\t\tthis.end();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets loop count for the animation. If parameter is not a valid number the\r\n\t * animation will keep on looping indefinitely.\r\n\t *\r\n\t * @param count  Number of times to loop animation\r\n\t * @return Animation\r\n\t */\r\n\tpublic loop(count?: number): Animation {\r\n\t\tif (!$type.isNumber(count)) {\r\n\t\t\tcount = Infinity;\r\n\t\t}\r\n\t\tthis._loop = count;\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Pauses animation.\r\n\t *\r\n\t * @return Animation\r\n\t */\r\n\tpublic pause(): Animation {\r\n\t\tthis._pause = true;\r\n\r\n\t\tif (this._delayTimeout) {\r\n\t\t\tthis.removeDispose(this._delayTimeout);\r\n\t\t\tthis._delayTimeout = null;\r\n\t\t}\r\n\r\n\t\t$array.remove(system.animations, this);\r\n\t\t$array.remove(this.object.animations, this);\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Resumes paused animation.\r\n\t *\r\n\t * @return Animation\r\n\t */\r\n\tpublic resume(): Animation {\r\n\t\tthis._start();\r\n\t\tthis._startTime = Date.now() - this._time;\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Jumps to animation end. If animation is set to loop, this will start\r\n\t * another round of animation from start.\r\n\t *\r\n\t * @return Animation\r\n\t */\r\n\tpublic end(): Animation {\r\n\r\n\t\t// Pause and complete the progress\r\n\t\tif (this._loop == 0) {\r\n\t\t\tthis.pause();\r\n\t\t}\r\n\t\tthis.setProgress(1);\r\n\r\n\t\t// Apply static options\r\n\t\tthis.applyStaticOptions();\r\n\r\n\t\tif (this.events.isEnabled(\"animationended\")) {\r\n\t\t\tconst event: AMEvent<this, IAnimationEvents>[\"animationended\"] = {\r\n\t\t\t\ttype: \"animationended\",\r\n\t\t\t\ttarget: this,\r\n\t\t\t\tprogress: this.progress\r\n\t\t\t};\r\n\t\t\tthis.events.dispatchImmediately(\"animationended\", event);\r\n\t\t}\r\n\r\n\t\t// Check if we should loop\r\n\t\tif (this._loop > 0) {\r\n\t\t\tthis._loop--;\r\n\t\t\tthis.start();\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.stop();\r\n\t\t\tthis._isFinished = true;\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Stops animation immediately leaving properties in their current values.\r\n\t */\r\n\tpublic kill() {\r\n\t\tthis.pause();\r\n\t\tthis._isFinished = true;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns indicator if this animation is finished or not\r\n\t *\r\n\t * @return Is finished?\r\n\t */\r\n\tpublic isFinished(): boolean {\r\n\t\treturn this._isFinished;\r\n\t}\r\n\r\n\t/**\r\n\t * Applies static options that can't be animated.\r\n\t */\r\n\tprotected applyStaticOptions(): void {\r\n\t\t$array.each(this.staticOptions, (options) => {\r\n\t\t\tif (options.childObject) {\r\n\t\t\t\toptions.childObject[options.property] = this.progress == 1 ? options.to : options.from;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t(<any>this.object)[options.property] = this.progress == 1 ? options.to : options.from;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Stops animation.\r\n\t *\r\n\t * When animation is stopped, the properties of the target object will remain\r\n\t * where they were at the moment when `stop()` was called.\r\n\t *\r\n\t * @param skipEvent  Do not trigger `animationstopped` event\r\n\t * @return Animation\r\n\t */\r\n\tpublic stop(skipEvent?: boolean): Animation {\r\n\t\tthis.pause();\r\n\t\tif (!skipEvent) {\r\n\t\t\tif (this.events.isEnabled(\"animationstopped\")) {\r\n\t\t\t\tconst event: AMEvent<this, IAnimationEvents>[\"animationstopped\"] = {\r\n\t\t\t\t\ttype: \"animationstopped\",\r\n\t\t\t\t\ttarget: this,\r\n\t\t\t\t\tprogress: this.progress\r\n\t\t\t\t};\r\n\t\t\t\tthis.events.dispatchImmediately(\"animationstopped\", event);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets current progress and updates object's numeric and color values.\r\n\t *\r\n\t * @param progress Progress (0-1)\r\n\t */\r\n\tpublic setProgress(progress: number): void {\r\n\t\tthis._time = this.duration * progress; // just in case we call this from outside\r\n\t\t$array.each(this.animationOptions, (options) => {\r\n\t\t\tif (options.updateMethod && $type.hasValue(options.from)) {\r\n\t\t\t\tlet value = options.updateMethod(progress, options.from, options.to);\r\n\r\n\t\t\t\tif (options.childObject) {\r\n\t\t\t\t\toptions.childObject[options.property] = value;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t(<any>this.object)[options.property] = value;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tthis.progress = progress;\r\n\t\tif (this.events.isEnabled(\"animationprogress\")) {\r\n\t\t\tconst event: AMEvent<this, IAnimationEvents>[\"animationprogress\"] = {\r\n\t\t\t\ttype: \"animationprogress\",\r\n\t\t\t\ttarget: this,\r\n\t\t\t\tprogress: this.progress\r\n\t\t\t};\r\n\t\t\tthis.events.dispatchImmediately(\"animationprogress\", event);\r\n\t\t}\r\n\r\n\t\tsystem.requestFrame();\r\n\t}\r\n\r\n\t/**\r\n\t * Tracks and sets progress according to time or frames.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @return Animation\r\n\t */\r\n\tpublic update(): Animation {\r\n\t\tif (!this._pause) {\r\n\r\n\t\t\tlet progress;\r\n\t\t\tthis._time = $math.fitToRange(Date.now() - this._startTime!, 0, this.duration);\r\n\t\t\tlet timeProgress = this._time / this.duration;\r\n\t\t\tprogress = this.easing(timeProgress);\r\n\t\t\tif (this.duration == 0 || !$type.isNumber(progress) || timeProgress >= 1) {\r\n\t\t\t\tprogress = 1;\r\n\t\t\t}\r\n\r\n\t\t\tthis.setProgress(progress);\r\n\r\n\t\t\tif ($math.round(this._time / this.duration, 6) == 1) {\r\n\t\t\t\tthis.end();\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns `true` if this animation is delayed.\r\n\t *\r\n\t * @readonly\r\n\t * @return [description]\r\n\t */\r\n\tpublic get delayed(): boolean {\r\n\t\treturn this._delayTimeout ? true : false;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks other animations currently running on the same object and removes\r\n\t * overlapping options from those other animations that are contained in\r\n\t * this animation.\r\n\t *\r\n\t * This is needed to ensure that no two confurent animations step on each\r\n\t * other's toes by trying to animate the same property.\r\n\t */\r\n\tprivate stopSameAnimations(): void {\r\n\t\t// stop animation of the same property\r\n\t\t// TODO make this more efficient\r\n\t\t// TODO don't copy the array\r\n\t\t$array.each($array.copy(this.object.animations), (animation) => {\r\n\t\t\tif (animation !== this && !animation.delayed) {\r\n\t\t\t\tconst killed: Array<IAnimationOptions> = [];\r\n\r\n\t\t\t\t$array.each(this.animationOptions, (newOptions) => {\r\n\t\t\t\t\t$array.each(animation.animationOptions, (oldOptions) => {\r\n\t\t\t\t\t\tif (newOptions.property == oldOptions.property && newOptions.childObject == oldOptions.childObject) {\r\n\t\t\t\t\t\t\tkilled.push(oldOptions);\r\n\r\n\t\t\t\t\t\t\tif (animation.animationOptions.length == 0) {\r\n\t\t\t\t\t\t\t\tanimation.kill();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\r\n\t\t\t\t$array.each(killed, (oldOptions) => {\r\n\t\t\t\t\t$array.remove(animation.animationOptions, oldOptions);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Adds easing functions to \"function\" fields.\r\n\t *\r\n\t * @param field  Field name\r\n\t * @return Assign as function?\r\n\t */\r\n\tprotected asFunction(field: string): boolean {\r\n\t\treturn field == \"easing\" || super.asIs(field);\r\n\t}\r\n\r\n}"]},"metadata":{},"sourceType":"module","externalDependencies":[]}