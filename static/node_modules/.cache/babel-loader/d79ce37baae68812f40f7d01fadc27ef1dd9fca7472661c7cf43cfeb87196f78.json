{"ast":null,"code":"import 'web-component-essentials';\nexport class Candlestick {\n  // timestamp: number;\n  // close: number;\n  // high: number;\n  // low: number;\n  // open: number;\n\n  constructor(_ref /*: TCandleStick*/) {\n    let {\n      timestamp,\n      open,\n      close,\n      high,\n      low\n    } = _ref;\n    this.timestamp = parseInt(timestamp.toString());\n    this.open = parseFloat(open.toString());\n    this.close = parseFloat(close.toString());\n    this.high = parseFloat(high.toString());\n    this.low = parseFloat(low.toString());\n  }\n}\nexport class VolumeBar {\n  // timestamp: number;\n  // volume: number;\n\n  constructor(_ref2 /*: TVolume*/) {\n    let {\n      timestamp,\n      volume\n    } = _ref2;\n    this.timestamp = parseInt(timestamp.toString());\n    this.volume = parseFloat(volume.toString());\n  }\n}\nexport class CandlestickChart extends HTMLCanvasElement {\n  // private candlesticks: Candlestick[];\n  // gridColor: string;\n  // gridTextColor: string;\n  // mouseHoverBackgroundColor: string;\n  // mouseHoverTextColor: string;\n  // greenColor: string;\n  // redHoverColor: string;\n  // candleWidth: number;\n  // marginLeft: number;\n  // marginRight: number;\n  // marginTop: number;\n  // marginBottom: number;\n  // yStart: number;\n  // yEnd: number;\n  // yRange: number;\n  // yPixelRange: number;\n  // xEnd: number;\n  // xGridCells: number;\n  // drawMouseOverlay: boolean;\n  // mousePosition: { x: number; y: number; };\n  // xMouseHover: number;\n  // yMouseHover: number;\n  // hoveredCandlestickID: number;\n  // xPixelRange: number;\n  // xStart: number;\n  // xRange: number;\n  // redColor: string;\n  // greenHoverColor: string;\n  // yGridCells: number;\n\n  // Returns an array of attributes that the browser will observe.\n  static observedAttributes() {\n    return [];\n  }\n\n  // It’s called when the component is first initialized.\n  // It must call super() and can set any defaults or perform other pre-rendering processes.\n  constructor() {\n    super();\n    const context = this.getContext('2d'); // as CanvasRenderingContext2D;\n\n    context.font = '12px sans-serif';\n    context.lineWidth = 1;\n    this.attachShadow({\n      mode: 'open'\n    });\n    this.addEventListener('mousemove', this.mouseMoveHandler.bind(this));\n    this.addEventListener('mouseout', this.mouseOutHandler.bind(this));\n    this.style.backgroundColor = '#252525';\n    this.gridColor = '#444444';\n    this.gridTextColor = '#aaaaaa';\n    this.mouseHoverBackgroundColor = '#eeeeee';\n    this.mouseHoverTextColor = '#000000';\n    this.greenColor = '#00cc00';\n    this.redColor = '#cc0000';\n    this.greenHoverColor = '#00ff00';\n    this.redHoverColor = '#ff0000';\n    this.candleWidth = 5;\n    this.marginLeft = 10;\n    this.marginRight = 100;\n    this.marginTop = 10;\n    this.marginBottom = 30;\n    this.yStart = 0;\n    this.yEnd = 0;\n    this.yRange = 0;\n    this.yPixelRange = this.height - this.marginTop - this.marginBottom;\n    this.xStart = 0;\n    this.xEnd = 0;\n    this.xRange = 0;\n    this.xPixelRange = this.width - this.marginLeft - this.marginRight;\n\n    // these are only approximations, the grid will be divided in a way so the numbers are nice\n    this.xGridCells = 16;\n    this.yGridCells = 16;\n    this.drawMouseOverlay = false;\n    this.mousePosition = {\n      x: 0,\n      y: 0\n    };\n    this.xMouseHover = 0;\n    this.yMouseHover = 0;\n    this.hoveredCandlestickID = 0;\n    this.candlesticks = [];\n  }\n\n  // // Called whenever an observed attribute is changed.\n  // // Those defined in HTML are passed immediately, but JavaScript can modify them:\n  // attributeChangedCallback(propertyName: string, oldValue: any, newValue: any) {\n  //   // document.querySelector('hello-world').setAttribute('name', 'Everyone');\n  //   // The method may need to trigger a re-render when this occurs.\n  // }\n\n  // This function is called when the Web Component is appended to a Document Object Model.\n  // It should run any required rendering.\n  connectedCallback() {}\n\n  // It’s called when the Web Component is removed from a Document Object Model.\n  // This may be useful if you need to clean up, such as removing stored state or\n  // aborting Ajax requests.\n  disconnectedCallback() {}\n\n  // This function is called when a Web Component is moved from one document to another.\n  // You may find a use for this, although I’ve struggled to think of any cases!\n  adoptedCallback() {}\n  addCandlestick(candlestick /*: Candlestick*/) {\n    this.candlesticks.push(candlestick);\n  }\n  mouseMoveHandler(event /* : MouseEvent */) {\n    this.mousePosition = this.getMousePos(event);\n    this.mousePosition.x += this.candleWidth / 2;\n    this.drawMouseOverlay = true;\n    if (this.mousePosition.x < this.marginLeft) this.drawMouseOverlay = false;\n    if (this.mousePosition.x > this.width - this.marginRight + this.candleWidth) this.drawMouseOverlay = false;\n    if (this.mousePosition.y > this.height - this.marginBottom) this.drawMouseOverlay = false;\n    if (this.drawMouseOverlay) {\n      this.yMouseHover = this.yToValueCoords(this.mousePosition.y);\n      this.xMouseHover = this.xToValueCoords(this.mousePosition.x);\n      // snap to candlesticks\n      const candlestickDelta = this.candlesticks[1].timestamp - this.candlesticks[0].timestamp;\n      this.hoveredCandlestickID = Math.floor((this.xMouseHover - this.candlesticks[0].timestamp) / candlestickDelta);\n      this.xMouseHover = Math.floor(this.xMouseHover / candlestickDelta) * candlestickDelta;\n      this.mousePosition.x = this.xToPixelCoords(this.xMouseHover);\n      this.draw();\n    } else this.draw();\n  }\n  mouseOutHandler(event /*: MouseEvent*/) {\n    this.drawMouseOverlay = false;\n    this.draw();\n  }\n  getMousePos(event /*: MouseEvent*/) {\n    const rect = this.getBoundingClientRect();\n    return {\n      x: event.clientX - rect.left,\n      y: event.clientY - rect.top\n    };\n  }\n  draw() {\n    const context = this.getContext('2d'); // as CanvasRenderingContext2D;\n\n    // clear background\n    context.clearRect(0, 0, this.width, this.height);\n    this.calculateYRange();\n    this.calculateXRange();\n    this.drawGrid();\n    this.candleWidth = this.xPixelRange / this.candlesticks.length;\n    this.candleWidth--;\n    if (this.candleWidth % 2 === 0) this.candleWidth--;\n    for (let color, candlestick, i = 0; i < this.candlesticks.length; ++i) {\n      candlestick = this.candlesticks[i];\n      color = candlestick.close > candlestick.open ? this.greenColor : this.redColor;\n      if (i === this.hoveredCandlestickID) {\n        if (color === this.greenColor) color = this.greenHoverColor;else if (color === this.redColor) color = this.redHoverColor;\n      }\n\n      // draw the wick\n      this.drawLine(this.xToPixelCoords(candlestick.timestamp), this.yToPixelCoords(candlestick.low), this.xToPixelCoords(candlestick.timestamp), this.yToPixelCoords(candlestick.high), color);\n\n      // draw the candle\n      this.fillRect(this.xToPixelCoords(candlestick.timestamp) - Math.floor(this.candleWidth / 2), this.yToPixelCoords(candlestick.open), this.candleWidth, this.yToPixelCoords(candlestick.close) - this.yToPixelCoords(candlestick.open), color);\n    }\n\n    // draw mouse hover\n    if (this.drawMouseOverlay && context) {\n      // price line\n      context.setLineDash([5, 5]);\n      this.drawLine(0, this.mousePosition.y, this.width, this.mousePosition.y, this.mouseHoverBackgroundColor);\n      context.setLineDash([]);\n      let str = this.roundPriceValue(this.yMouseHover).toString();\n      let textWidth = context.measureText(str).width;\n      this.fillRect(this.width - 70, this.mousePosition.y - 10, 70, 20, this.mouseHoverBackgroundColor);\n      context.fillStyle = this.mouseHoverTextColor;\n      context.fillText(str, this.width - textWidth - 5, this.mousePosition.y + 5);\n\n      // time line\n      context.setLineDash([5, 5]);\n      this.drawLine(this.mousePosition.x, 0, this.mousePosition.x, this.height, this.mouseHoverBackgroundColor);\n      context.setLineDash([]);\n      str = this.formatDate(new Date(this.xMouseHover)).toString();\n      textWidth = context.measureText(str).width;\n      this.fillRect(this.mousePosition.x - textWidth / 2 - 5, this.height - 20, textWidth + 10, 20, this.mouseHoverBackgroundColor);\n      context.fillStyle = this.mouseHoverTextColor;\n      context.fillText(str, this.mousePosition.x - textWidth / 2, this.height - 5);\n\n      // data\n      let yPos = this.mousePosition.y - 95;\n      if (yPos < 0) {\n        yPos = this.mousePosition.y + 15;\n      }\n      this.fillRect(this.mousePosition.x + 15, yPos, 100, 80, this.mouseHoverBackgroundColor);\n      const color = this.candlesticks[this.hoveredCandlestickID].close > this.candlesticks[this.hoveredCandlestickID].open ? this.greenColor : this.redColor;\n      this.fillRect(this.mousePosition.x + 15, yPos, 10, 80, color);\n      context.lineWidth = 2;\n      this.drawRect(this.mousePosition.x + 15, yPos, 100, 80, color);\n      context.lineWidth = 1;\n      context.fillStyle = this.mouseHoverTextColor;\n      context.fillText('O: ' + this.candlesticks[this.hoveredCandlestickID].open, this.mousePosition.x + 30, yPos + 15);\n      context.fillText('C: ' + this.candlesticks[this.hoveredCandlestickID].close, this.mousePosition.x + 30, yPos + 35);\n      context.fillText('H: ' + this.candlesticks[this.hoveredCandlestickID].high, this.mousePosition.x + 30, yPos + 55);\n      context.fillText('L: ' + this.candlesticks[this.hoveredCandlestickID].low, this.mousePosition.x + 30, yPos + 75);\n    }\n  }\n  drawGrid() {\n    const context = this.getContext('2d'); // as CanvasRenderingContext2D ;\n\n    // roughly divide the yRange into cells\n    const yGridSize = this.yRange / this.yGridCells;\n\n    // try to find a nice number to round to\n    let niceNumber = Math.pow(10, Math.ceil(Math.log10(yGridSize)));\n    if (yGridSize < 0.25 * niceNumber) niceNumber = 0.25 * niceNumber;else if (yGridSize < 0.5 * niceNumber) niceNumber = 0.5 * niceNumber;\n\n    // find next largest nice number above yStart\n    const yStartRoundNumber = Math.ceil(this.yStart / niceNumber) * niceNumber;\n    // find next lowest nice number below yEnd\n    const yEndRoundNumber = Math.floor(this.yEnd / niceNumber) * niceNumber;\n    for (let textWidth, y = yStartRoundNumber; y <= yEndRoundNumber; y += niceNumber) {\n      this.drawLine(0, this.yToPixelCoords(y), this.width, this.yToPixelCoords(y), this.gridColor);\n      textWidth = context.measureText(this.roundPriceValue(y).toString()).width;\n      context.fillStyle = this.gridTextColor;\n      context.fillText(this.roundPriceValue(y).toString(), this.width - textWidth - 5, this.yToPixelCoords(y) - 5);\n    }\n\n    // roughly divide the xRange into cells\n    const xGridSize = this.xRange / this.xGridCells;\n\n    // try to find a nice number to round to\n    niceNumber = Math.pow(10, Math.ceil(Math.log10(xGridSize)));\n    if (xGridSize < 0.25 * niceNumber) {\n      niceNumber = 0.25 * niceNumber;\n    } else if (xGridSize < 0.5 * niceNumber) {\n      niceNumber = 0.5 * niceNumber;\n    }\n\n    // find next largest nice number above yStart\n    const xStartRoundNumber = Math.ceil(this.xStart / niceNumber) * niceNumber;\n    // find next lowest nice number below yEnd\n    const xEndRoundNumber = Math.floor(this.xEnd / niceNumber) * niceNumber;\n\n    // if the total x range is more than 5 days, format the timestamp as date instead of hours\n    let formatAsDate = this.xRange > 60 * 60 * 24 * 1000 * 5;\n    for (let day, month, minutes, date, dateStr, x = xStartRoundNumber; x <= xEndRoundNumber; x += niceNumber) {\n      this.drawLine(this.xToPixelCoords(x), 0, this.xToPixelCoords(x), this.height, this.gridColor);\n      date = new Date(x);\n      dateStr = '';\n      if (formatAsDate) {\n        day = date.getDate();\n        // if (day < 10) day = '0' + day;\n        month = date.getMonth() + 1;\n        // if (month < 10) month = '0' + month;\n        dateStr = `${day < 10 ? '0' + day : day}.${month < 10 ? '0' + month : month}`;\n      } else {\n        minutes = date.getMinutes();\n        if (minutes < 10) {\n          minutes = '0' + minutes;\n        }\n        dateStr = date.getHours() + ':' + minutes;\n      }\n      context.fillStyle = this.gridTextColor;\n      context.fillText(dateStr, this.xToPixelCoords(x) + 5, this.height - 5);\n    }\n  }\n  calculateYRange() {\n    for (let i = 0; i < this.candlesticks.length; ++i) {\n      if (i === 0) {\n        this.yStart = this.candlesticks[i].low;\n        this.yEnd = this.candlesticks[i].high;\n      } else {\n        if (this.candlesticks[i].low < this.yStart) {\n          this.yStart = this.candlesticks[i].low;\n        }\n        if (this.candlesticks[i].high > this.yEnd) {\n          this.yEnd = this.candlesticks[i].high;\n        }\n      }\n    }\n    this.yRange = this.yEnd - this.yStart;\n  }\n  calculateXRange() {\n    this.xStart = this.candlesticks[0].timestamp;\n    this.xEnd = this.candlesticks[this.candlesticks.length - 1].timestamp;\n    this.xRange = this.xEnd - this.xStart;\n  }\n  yToPixelCoords(y /* : number */) {\n    return this.height - this.marginBottom - (y - this.yStart) * this.yPixelRange / this.yRange;\n  }\n  xToPixelCoords(x /* : number */) {\n    return this.marginLeft + (x - this.xStart) * this.xPixelRange / this.xRange;\n  }\n  yToValueCoords(y /* : number */) {\n    return this.yStart + (this.height - this.marginBottom - y) * this.yRange / this.yPixelRange;\n  }\n  xToValueCoords(x /* : number */) {\n    return this.xStart + (x - this.marginLeft) * this.xRange / this.xPixelRange;\n  }\n  drawLine(xStart /* : number */, yStart /* : number */, xEnd /* : number */, yEnd /* : number */, color /*: string | CanvasGradient | CanvasPattern */) {\n    const context = this.getContext('2d'); // as CanvasRenderingContext2D ;\n    context.beginPath();\n    // to get a crisp 1 pixel wide line, we need to add 0.5 to the coords\n    context.moveTo(xStart + 0.5, yStart + 0.5);\n    context.lineTo(xEnd + 0.5, yEnd + 0.5);\n    context.strokeStyle = color;\n    context.stroke();\n  }\n  fillRect(x /* : number */, y /* : number */, width /* : number */, height /* : number */, color /*: string | CanvasGradient | CanvasPattern */) {\n    const context = this.getContext('2d'); // as CanvasRenderingContext2D ;\n    context.beginPath();\n    context.fillStyle = color;\n    context.rect(x, y, width, height);\n    context.fill();\n  }\n  drawRect(x /* : number */, y /* : number */, width /* : number */, height /* : number */, color /*: string | CanvasGradient | CanvasPattern */) {\n    const context = this.getContext('2d'); // as CanvasRenderingContext2D ;\n    context.beginPath();\n    context.strokeStyle = color;\n    context.rect(x, y, width, height);\n    context.stroke();\n  }\n  formatDate(date /*: Date */) {\n    const day = date.getDate();\n    const month = date.getMonth() + 1;\n    const hours = date.getHours();\n    const minutes = date.getMinutes();\n    const year = date.getFullYear();\n    return `${day < 10 ? '0' + day : day}/${month < 10 ? '0' + month : month}/${year} - ${hours < 10 ? '0' + hours : hours}:${minutes < 10 ? '0' + minutes : minutes}`;\n  }\n  roundPriceValue(value /* : number */) {\n    if (value > 1.0) return Math.round(value * 100) / 100;\n    if (value > 0.001) return Math.round(value * 1000) / 1000;\n    if (value > 0.00001) return Math.round(value * 100000) / 100000;\n    if (value > 0.0000001) return Math.round(value * 10000000) / 10000000;else return Math.round(value * 1000000000) / 1000000000;\n  }\n}\nwindow.customElements.define('candlestick-chart', CandlestickChart, {\n  extends: 'canvas'\n});\n\n// export function CandlestickChart(props: IChart) {\n//   return <candlestick-chart {...props} />;\n// }\nexport default CandlestickChart;","map":{"version":3,"names":["Candlestick","constructor","timestamp","open","close","high","low","parseInt","toString","parseFloat","VolumeBar","volume","CandlestickChart","HTMLCanvasElement","observedAttributes","context","getContext","font","lineWidth","attachShadow","mode","addEventListener","mouseMoveHandler","bind","mouseOutHandler","style","backgroundColor","gridColor","gridTextColor","mouseHoverBackgroundColor","mouseHoverTextColor","greenColor","redColor","greenHoverColor","redHoverColor","candleWidth","marginLeft","marginRight","marginTop","marginBottom","yStart","yEnd","yRange","yPixelRange","height","xStart","xEnd","xRange","xPixelRange","width","xGridCells","yGridCells","drawMouseOverlay","mousePosition","x","y","xMouseHover","yMouseHover","hoveredCandlestickID","candlesticks","connectedCallback","disconnectedCallback","adoptedCallback","addCandlestick","candlestick","push","event","getMousePos","yToValueCoords","xToValueCoords","candlestickDelta","Math","floor","xToPixelCoords","draw","rect","getBoundingClientRect","clientX","left","clientY","top","clearRect","calculateYRange","calculateXRange","drawGrid","length","color","i","drawLine","yToPixelCoords","fillRect","setLineDash","str","roundPriceValue","textWidth","measureText","fillStyle","fillText","formatDate","Date","yPos","drawRect","yGridSize","niceNumber","pow","ceil","log10","yStartRoundNumber","yEndRoundNumber","xGridSize","xStartRoundNumber","xEndRoundNumber","formatAsDate","day","month","minutes","date","dateStr","getDate","getMonth","getMinutes","getHours","beginPath","moveTo","lineTo","strokeStyle","stroke","fill","hours","year","getFullYear","value","round","window","customElements","define","extends"],"sources":["C:/Users/Lucian/Documents/DEV/nodejs/stock-market-api/dev/static/src/components/CandleStickChart.ts"],"sourcesContent":["import 'web-component-essentials';\r\n\r\nexport class Candlestick {\r\n  // timestamp: number;\r\n  // close: number;\r\n  // high: number;\r\n  // low: number;\r\n  // open: number;\r\n\r\n  constructor({ timestamp, open, close, high, low } /*: TCandleStick*/ ) {\r\n    this.timestamp = parseInt(timestamp.toString());\r\n    this.open = parseFloat(open.toString());\r\n    this.close = parseFloat(close.toString());\r\n    this.high = parseFloat(high.toString());\r\n    this.low = parseFloat(low.toString());\r\n  }\r\n}\r\n\r\nexport class VolumeBar {\r\n  // timestamp: number;\r\n  // volume: number;\r\n\r\n  constructor({ timestamp, volume } /*: TVolume*/) {\r\n    this.timestamp = parseInt(timestamp.toString());\r\n    this.volume = parseFloat(volume.toString());\r\n  }\r\n}\r\n\r\nexport class CandlestickChart extends HTMLCanvasElement {\r\n  // private candlesticks: Candlestick[];\r\n  // gridColor: string;\r\n  // gridTextColor: string;\r\n  // mouseHoverBackgroundColor: string;\r\n  // mouseHoverTextColor: string;\r\n  // greenColor: string;\r\n  // redHoverColor: string;\r\n  // candleWidth: number;\r\n  // marginLeft: number;\r\n  // marginRight: number;\r\n  // marginTop: number;\r\n  // marginBottom: number;\r\n  // yStart: number;\r\n  // yEnd: number;\r\n  // yRange: number;\r\n  // yPixelRange: number;\r\n  // xEnd: number;\r\n  // xGridCells: number;\r\n  // drawMouseOverlay: boolean;\r\n  // mousePosition: { x: number; y: number; };\r\n  // xMouseHover: number;\r\n  // yMouseHover: number;\r\n  // hoveredCandlestickID: number;\r\n  // xPixelRange: number;\r\n  // xStart: number;\r\n  // xRange: number;\r\n  // redColor: string;\r\n  // greenHoverColor: string;\r\n  // yGridCells: number;\r\n\r\n  // Returns an array of attributes that the browser will observe.\r\n  static observedAttributes() {\r\n    return [];\r\n  }\r\n\r\n  // It’s called when the component is first initialized.\r\n  // It must call super() and can set any defaults or perform other pre-rendering processes.\r\n  constructor() {\r\n    super();\r\n\r\n    const context = this.getContext('2d'); // as CanvasRenderingContext2D;\r\n\r\n    context.font = '12px sans-serif';\r\n    context.lineWidth = 1;\r\n\r\n    this.attachShadow({ mode: 'open' });\r\n\r\n    this.addEventListener('mousemove', this.mouseMoveHandler.bind(this));\r\n    this.addEventListener('mouseout', this.mouseOutHandler.bind(this));\r\n\r\n    this.style.backgroundColor = '#252525';\r\n\r\n    this.gridColor = '#444444';\r\n    this.gridTextColor = '#aaaaaa';\r\n    this.mouseHoverBackgroundColor = '#eeeeee';\r\n    this.mouseHoverTextColor = '#000000';\r\n    this.greenColor = '#00cc00';\r\n    this.redColor = '#cc0000';\r\n    this.greenHoverColor = '#00ff00';\r\n    this.redHoverColor = '#ff0000';\r\n\r\n    this.candleWidth = 5;\r\n\r\n    this.marginLeft = 10;\r\n    this.marginRight = 100;\r\n    this.marginTop = 10;\r\n    this.marginBottom = 30;\r\n\r\n    this.yStart = 0;\r\n    this.yEnd = 0;\r\n    this.yRange = 0;\r\n    this.yPixelRange = this.height-this.marginTop-this.marginBottom;\r\n\r\n    this.xStart = 0;\r\n    this.xEnd = 0;\r\n    this.xRange = 0;\r\n    this.xPixelRange = this.width-this.marginLeft-this.marginRight;\r\n\r\n    // these are only approximations, the grid will be divided in a way so the numbers are nice\r\n    this.xGridCells = 16;\r\n    this.yGridCells = 16;\r\n\r\n    this.drawMouseOverlay = false;\r\n    this.mousePosition = { x: 0 , y: 0 };\r\n    this.xMouseHover = 0;\r\n    this.yMouseHover = 0;\r\n    this.hoveredCandlestickID = 0;\r\n\r\n    this.candlesticks = [];\r\n  }\r\n\r\n  // // Called whenever an observed attribute is changed.\r\n  // // Those defined in HTML are passed immediately, but JavaScript can modify them:\r\n  // attributeChangedCallback(propertyName: string, oldValue: any, newValue: any) {\r\n  //   // document.querySelector('hello-world').setAttribute('name', 'Everyone');\r\n  //   // The method may need to trigger a re-render when this occurs.\r\n  // }\r\n\r\n  // This function is called when the Web Component is appended to a Document Object Model.\r\n  // It should run any required rendering.\r\n  connectedCallback() {}\r\n\r\n  // It’s called when the Web Component is removed from a Document Object Model.\r\n  // This may be useful if you need to clean up, such as removing stored state or\r\n  // aborting Ajax requests.\r\n  disconnectedCallback() {}\r\n\r\n  // This function is called when a Web Component is moved from one document to another.\r\n  // You may find a use for this, although I’ve struggled to think of any cases!\r\n  adoptedCallback() {}\r\n\r\n  addCandlestick(candlestick /*: Candlestick*/) {\r\n    this.candlesticks.push(candlestick);\r\n  }\r\n\r\n  mouseMoveHandler(event /* : MouseEvent */) {\r\n    this.mousePosition = this.getMousePos(event);\r\n    this.mousePosition.x += this.candleWidth / 2;\r\n    this.drawMouseOverlay = true;\r\n    if (this.mousePosition.x < this.marginLeft) this.drawMouseOverlay = false;\r\n    if (this.mousePosition.x > this.width - this.marginRight + this.candleWidth)\r\n      this.drawMouseOverlay = false;\r\n    if (this.mousePosition.y > this.height - this.marginBottom)\r\n      this.drawMouseOverlay = false;\r\n    if (this.drawMouseOverlay) {\r\n      this.yMouseHover = this.yToValueCoords(this.mousePosition.y);\r\n      this.xMouseHover = this.xToValueCoords(this.mousePosition.x);\r\n      // snap to candlesticks\r\n      const candlestickDelta = this.candlesticks[1].timestamp - this.candlesticks[0].timestamp;\r\n      this.hoveredCandlestickID = Math.floor( (this.xMouseHover - this.candlesticks[0].timestamp) / candlestickDelta);\r\n      this.xMouseHover = Math.floor(this.xMouseHover / candlestickDelta) * candlestickDelta;\r\n      this.mousePosition.x = this.xToPixelCoords(this.xMouseHover);\r\n      this.draw();\r\n    } else this.draw();\r\n  }\r\n\r\n  mouseOutHandler(event /*: MouseEvent*/) {\r\n    this.drawMouseOverlay = false;\r\n    this.draw();\r\n  }\r\n\r\n  getMousePos(event /*: MouseEvent*/) {\r\n    const rect = this.getBoundingClientRect();\r\n    return { x: event.clientX - rect.left, y: event.clientY - rect.top };\r\n  }\r\n\r\n  draw() {\r\n    const context = this.getContext('2d'); // as CanvasRenderingContext2D;\r\n\r\n    // clear background\r\n    context.clearRect(0, 0, this.width, this.height);\r\n    this.calculateYRange();\r\n    this.calculateXRange();\r\n\r\n    this.drawGrid();\r\n\r\n    this.candleWidth = this.xPixelRange / this.candlesticks.length;\r\n    this.candleWidth--;\r\n    if (this.candleWidth % 2 === 0) this.candleWidth--;\r\n\r\n    for (let color, candlestick, i = 0; i < this.candlesticks.length; ++i) {\r\n      candlestick = this.candlesticks[i];\r\n      color = candlestick.close > candlestick.open ? this.greenColor : this.redColor;\r\n\r\n      if (i === this.hoveredCandlestickID) {\r\n        if (color === this.greenColor) color = this.greenHoverColor;\r\n        else if (color === this.redColor) color = this.redHoverColor;\r\n      }\r\n\r\n      // draw the wick\r\n      this.drawLine(\r\n        this.xToPixelCoords(candlestick.timestamp),\r\n        this.yToPixelCoords(candlestick.low),\r\n        this.xToPixelCoords(candlestick.timestamp),\r\n        this.yToPixelCoords(candlestick.high),\r\n        color\r\n      );\r\n\r\n      // draw the candle\r\n      this.fillRect(\r\n        this.xToPixelCoords(candlestick.timestamp) - Math.floor(this.candleWidth / 2),\r\n        this.yToPixelCoords(candlestick.open),\r\n        this.candleWidth,\r\n        this.yToPixelCoords(candlestick.close) - this.yToPixelCoords(candlestick.open),\r\n        color\r\n      );\r\n    }\r\n\r\n    // draw mouse hover\r\n    if (this.drawMouseOverlay && context) {\r\n      // price line\r\n      context.setLineDash([5, 5]);\r\n      this.drawLine(0, this.mousePosition.y, this.width, this.mousePosition.y, this.mouseHoverBackgroundColor);\r\n      context.setLineDash([]);\r\n      let str = this.roundPriceValue(this.yMouseHover).toString();\r\n      let textWidth = context.measureText(str).width;\r\n      this.fillRect(this.width - 70, this.mousePosition.y - 10, 70, 20, this.mouseHoverBackgroundColor);\r\n      context.fillStyle = this.mouseHoverTextColor;\r\n      context.fillText(str, this.width - textWidth - 5, this.mousePosition.y + 5);\r\n\r\n      // time line\r\n      context.setLineDash([5, 5]);\r\n      this.drawLine(this.mousePosition.x, 0, this.mousePosition.x, this.height, this.mouseHoverBackgroundColor);\r\n      context.setLineDash([]);\r\n      str = this.formatDate(new Date(this.xMouseHover)).toString();\r\n      textWidth = context.measureText(str).width;\r\n      this.fillRect(this.mousePosition.x - textWidth / 2 - 5, this.height - 20, textWidth + 10, 20, this.mouseHoverBackgroundColor);\r\n      context.fillStyle = this.mouseHoverTextColor;\r\n      context.fillText(str, this.mousePosition.x - textWidth / 2, this.height - 5);\r\n\r\n      // data\r\n      let yPos = this.mousePosition.y - 95;\r\n      if (yPos < 0) {\r\n        yPos = this.mousePosition.y + 15;\r\n      }\r\n\r\n      this.fillRect(this.mousePosition.x + 15, yPos, 100, 80, this.mouseHoverBackgroundColor);\r\n      const color =\r\n        this.candlesticks[this.hoveredCandlestickID].close >\r\n        this.candlesticks[this.hoveredCandlestickID].open ? this.greenColor : this.redColor;\r\n      this.fillRect(this.mousePosition.x + 15, yPos, 10, 80, color);\r\n      context.lineWidth = 2;\r\n      this.drawRect(this.mousePosition.x + 15, yPos, 100, 80, color);\r\n      context.lineWidth = 1;\r\n\r\n      context.fillStyle = this.mouseHoverTextColor;\r\n      context.fillText(\r\n        'O: ' + this.candlesticks[this.hoveredCandlestickID].open,\r\n        this.mousePosition.x + 30,\r\n        yPos + 15\r\n      );\r\n      context.fillText(\r\n        'C: ' + this.candlesticks[this.hoveredCandlestickID].close,\r\n        this.mousePosition.x + 30,\r\n        yPos + 35\r\n      );\r\n      context.fillText(\r\n        'H: ' + this.candlesticks[this.hoveredCandlestickID].high,\r\n        this.mousePosition.x + 30,\r\n        yPos + 55\r\n      );\r\n      context.fillText(\r\n        'L: ' + this.candlesticks[this.hoveredCandlestickID].low,\r\n        this.mousePosition.x + 30,\r\n        yPos + 75\r\n      );\r\n    }\r\n  }\r\n\r\n  drawGrid() {\r\n    const context = this.getContext('2d'); // as CanvasRenderingContext2D ;\r\n\r\n    // roughly divide the yRange into cells\r\n    const yGridSize = this.yRange / this.yGridCells;\r\n  \r\n    // try to find a nice number to round to\r\n    let niceNumber = Math.pow(10, Math.ceil(Math.log10(yGridSize)));\r\n    if (yGridSize < 0.25 * niceNumber) niceNumber = 0.25 * niceNumber;\r\n    else if (yGridSize < 0.5 * niceNumber) niceNumber = 0.5 * niceNumber;\r\n  \r\n    // find next largest nice number above yStart\r\n    const yStartRoundNumber = Math.ceil(this.yStart / niceNumber) * niceNumber;\r\n    // find next lowest nice number below yEnd\r\n    const yEndRoundNumber = Math.floor(this.yEnd / niceNumber) * niceNumber;\r\n  \r\n    for (let textWidth, y = yStartRoundNumber; y <= yEndRoundNumber; y += niceNumber) {\r\n      this.drawLine(0, this.yToPixelCoords(y), this.width, this.yToPixelCoords(y), this.gridColor);\r\n      textWidth = context.measureText(this.roundPriceValue(y).toString()).width;\r\n      context.fillStyle = this.gridTextColor;\r\n      context.fillText(this.roundPriceValue(y).toString(), this.width - textWidth - 5, this.yToPixelCoords(y) - 5);\r\n    }\r\n  \r\n    // roughly divide the xRange into cells\r\n    const xGridSize = this.xRange / this.xGridCells;\r\n  \r\n    // try to find a nice number to round to\r\n    niceNumber = Math.pow(10, Math.ceil(Math.log10(xGridSize)));\r\n    if (xGridSize < 0.25 * niceNumber) {\r\n      niceNumber = 0.25 * niceNumber;\r\n    } else if (xGridSize < 0.5 * niceNumber) {\r\n      niceNumber = 0.5 * niceNumber;\r\n    }\r\n\r\n    // find next largest nice number above yStart\r\n    const xStartRoundNumber = Math.ceil(this.xStart / niceNumber) * niceNumber;\r\n    // find next lowest nice number below yEnd\r\n    const xEndRoundNumber = Math.floor(this.xEnd / niceNumber) * niceNumber;\r\n  \r\n    // if the total x range is more than 5 days, format the timestamp as date instead of hours\r\n    let formatAsDate = (this.xRange > 60 * 60 * 24 * 1000 * 5);\r\n  \r\n    for (let day, month, minutes, date, dateStr, x = xStartRoundNumber; x <= xEndRoundNumber; x += niceNumber) {\r\n      this.drawLine(this.xToPixelCoords(x), 0, this.xToPixelCoords(x), this.height, this.gridColor);\r\n      date = new Date(x);\r\n      dateStr = '';\r\n      if (formatAsDate) {\r\n        day = date.getDate();\r\n        // if (day < 10) day = '0' + day;\r\n        month = date.getMonth() + 1;\r\n        // if (month < 10) month = '0' + month;\r\n        dateStr = `${(day < 10) ? '0' + day : day}.${(month < 10) ? '0' + month : month}`;\r\n      } else {\r\n        minutes = date.getMinutes();\r\n        if (minutes < 10) {\r\n          minutes = '0' + minutes;\r\n        }\r\n        dateStr = date.getHours() + ':' + minutes;\r\n      }\r\n      context.fillStyle = this.gridTextColor;\r\n      context.fillText(dateStr, this.xToPixelCoords(x) + 5, this.height - 5);\r\n    }\r\n  }\r\n\r\n  calculateYRange() {\r\n    for (let i = 0; i < this.candlesticks.length; ++i) {\r\n      if (i === 0) {\r\n        this.yStart = this.candlesticks[i].low;\r\n        this.yEnd = this.candlesticks[i].high;\r\n      } else {\r\n        if (this.candlesticks[i].low < this.yStart) {\r\n          this.yStart = this.candlesticks[i].low;\r\n        }\r\n        if (this.candlesticks[i].high > this.yEnd) {\r\n          this.yEnd = this.candlesticks[i].high;\r\n        }\r\n      }\r\n    }\r\n    this.yRange = this.yEnd - this.yStart;\r\n  }\r\n\r\n  calculateXRange() {\r\n    this.xStart = this.candlesticks[0].timestamp;\r\n    this.xEnd = this.candlesticks[this.candlesticks.length - 1].timestamp;\r\n    this.xRange = this.xEnd - this.xStart;\r\n  }\r\n\r\n  yToPixelCoords(y /* : number */) {\r\n    return (this.height - this.marginBottom - ((y - this.yStart) * this.yPixelRange) / this.yRange);\r\n  }\r\n\r\n  xToPixelCoords(x /* : number */) {\r\n    return this.marginLeft + ((x - this.xStart) * this.xPixelRange) / this.xRange;\r\n  }\r\n\r\n  yToValueCoords(y /* : number */) {\r\n    return (this.yStart + ((this.height - this.marginBottom - y) * this.yRange) / this.yPixelRange);\r\n  }\r\n\r\n  xToValueCoords(x /* : number */) {\r\n    return this.xStart + ((x - this.marginLeft) * this.xRange) / this.xPixelRange;\r\n  }\r\n\r\n  drawLine( xStart /* : number */, yStart /* : number */, xEnd /* : number */, yEnd /* : number */, color /*: string | CanvasGradient | CanvasPattern */) {\r\n    const context = this.getContext('2d'); // as CanvasRenderingContext2D ;\r\n    context.beginPath();\r\n    // to get a crisp 1 pixel wide line, we need to add 0.5 to the coords\r\n    context.moveTo(xStart + 0.5, yStart + 0.5);\r\n    context.lineTo(xEnd + 0.5, yEnd + 0.5);\r\n    context.strokeStyle = color;\r\n    context.stroke();\r\n  }\r\n\r\n  fillRect(x /* : number */, y /* : number */, width /* : number */, height /* : number */, color /*: string | CanvasGradient | CanvasPattern */) {\r\n    const context = this.getContext('2d'); // as CanvasRenderingContext2D ;\r\n    context.beginPath();\r\n    context.fillStyle = color;\r\n    context.rect(x, y, width, height);\r\n    context.fill();\r\n  }\r\n  \r\n  drawRect(x /* : number */, y /* : number */, width /* : number */, height /* : number */, color /*: string | CanvasGradient | CanvasPattern */) {\r\n    const context = this.getContext('2d'); // as CanvasRenderingContext2D ;\r\n    context.beginPath();\r\n    context.strokeStyle = color;\r\n    context.rect(x, y, width, height);\r\n    context.stroke();\r\n  }\r\n\r\n  formatDate(date /*: Date */) {\r\n    const day = date.getDate();\r\n    const month = date.getMonth() + 1;\r\n    const hours = date.getHours();\r\n    const minutes = date.getMinutes();\r\n    const year = date.getFullYear();\r\n\r\n    return `${(day < 10) ? '0' + day : day}/${(month < 10) ? '0' + month : month}/${year} - ${(hours < 10) ? '0' + hours : hours}:${(minutes < 10) ? '0' + minutes : minutes}`;\r\n  }\r\n  \r\n  roundPriceValue(value /* : number */) {\r\n    if (value > 1.0) return Math.round(value * 100) / 100;\r\n    if (value > 0.001) return Math.round(value * 1000) / 1000;\r\n    if (value > 0.00001) return Math.round(value * 100000) / 100000;\r\n    if (value > 0.0000001) return Math.round(value * 10000000) / 10000000;\r\n    else return Math.round(value * 1000000000) / 1000000000;\r\n  }\r\n}\r\nwindow.customElements.define('candlestick-chart', CandlestickChart, { extends: 'canvas' });\r\n\r\n\r\n// export function CandlestickChart(props: IChart) {\r\n//   return <candlestick-chart {...props} />;\r\n// }\r\nexport default CandlestickChart;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}